<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[KotlinThree's Blog]]></title>
  <subtitle><![CDATA[for the dream]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-12-26T12:20:41.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[KotlinThree]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[类与对象——泛型]]></title>
    <link href="http://yoursite.com/2015/12/22/class-object-generic/"/>
    <id>http://yoursite.com/2015/12/22/class-object-generic/</id>
    <published>2015-12-22T15:08:50.000Z</published>
    <updated>2015-12-26T12:20:41.000Z</updated>
    <content type="html"><![CDATA[<p>与java一样，Kotlin也提供泛型，为类型安全提供保证，消除类型强转的烦恼。</p>
<h3 id="u6CDB_u578B_u5B9A_u4E49"><a href="#u6CDB_u578B_u5B9A_u4E49" class="headerlink" title="泛型定义"></a>泛型定义</h3><p>好吧，如果只是简单声明一个泛型，和<code>Java</code>没有什么大的区别，你可以这样声明：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span><span class="inheritance">&lt;<span class="parent">T</span></span>&gt;(<span class="title">t</span>: <span class="title">T</span>) &#123;</span></span><br><span class="line">    var value = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以这样使用</p>
<a id="more"></a>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val <span class="keyword">box</span>: <span class="built_in">Box</span>&lt;Int&gt; = <span class="built_in">Box</span>&lt;Int&gt;(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">val <span class="keyword">box</span> = <span class="built_in">Box</span>(<span class="number">1</span>) <span class="comment">// 编译器会进行类型推断</span></span><br></pre></td></tr></table></figure>
<h3 id="u6CDB_u578B_u7EA6_u675F"><a href="#u6CDB_u578B_u7EA6_u675F" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>和类的继承一样，<code>Kotlin</code>中使用<code>:</code>代替<code>extends</code>对泛型的的类型上限进行约束。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwipeRefreshableView</span><span class="inheritance">&lt;<span class="parent">T</span></span> : <span class="title">View</span>&gt;&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>不过这里你可以进行多个类型的上限约束：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwipeRefreshableView</span>&lt;<span class="type">T</span>&gt;</span></span><br><span class="line">    where T : View,</span><br><span class="line">          T : Refreshable &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">cloneWhenGreater</span><span class="params">(list: <span class="typename">List&lt;T&gt;, threshold: T</span>)</span>: List<span class="type">&lt;T&gt;</span></span></span><br><span class="line">    where T : Comparable,</span><br><span class="line">          T : Cloneable &#123;</span><br><span class="line">  <span class="keyword">return</span> list.filter &#123; it &gt; threshold &#125;.map &#123; it.clone() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，对于之前用过泛型的同学来说都没有什么难度。so，kotlin还有什么java里没有的东西吗？</p>
<h3 id="in_u548Cout"><a href="#in_u548Cout" class="headerlink" title="in和out"></a><code>in</code>和<code>out</code></h3><p><code>Kotlin</code>中引入两个新的泛型修饰符<code>in</code>和<code>out</code>，要解释这两个关键字的用法，我们先从另外两个概念说起‘covariant（协变性）’和‘contravariance（逆变性）’（不知道的可以<a href="http://www.cnblogs.com/Figgy/p/4575719.html" target="_blank" rel="external">参考</a>）。我们都知道在java中List不是协变的，而Array是协变的：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer<span class="string">[]</span> intArray = new Integer<span class="string">[10]</span>;</span><br><span class="line">Number<span class="string">[]</span> numberArray = intArray;</span><br><span class="line">numberArray<span class="string">[0]</span> = <span class="number">1</span>.0f;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>Integer[]</code>被认为是<code>Number[]</code>的子类型，所以可以将<code>intArray</code>赋值给<code>numberArray</code>，但是在随后的代码，我们将<code>1.0f</code>赋给<code>numberArray[0]</code>，因为在这里看来，将一个浮点型赋给一个Number对象不会有什么问题。最后悲剧发生了，当执行时，程序crash了。</p>
<p>但是当你使用泛型的的时候：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; strs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; objs = strs; <span class="comment">// error, compiler complain</span></span><br></pre></td></tr></table></figure>
<p><code>List&lt;String&gt;</code>并不是<code>List&lt;Object&gt;</code>的子类型，于是编译器告诉你，不能直接赋值。或许你会说我们可以使用通配符<code>? extends T</code>让它变得协变。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; strs = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">strs.add(<span class="string">"0"</span>);</span><br><span class="line">strs.add(<span class="string">"1"</span>);</span><br><span class="line"><span class="built_in">List</span>&lt;? <span class="keyword">extends</span> <span class="built_in">Object</span>&gt; objs = strs;</span><br><span class="line"><span class="comment">//编译通过</span></span><br></pre></td></tr></table></figure>
<p><code>List&lt;String&gt;</code>是<code>List&lt;? extends Object&gt;</code>的子类，所以上面的代码的确能够编译运行，但是当你尝试为<code>objs</code>添加内容时：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//然后添加一个int型试试</span></span><br><span class="line">objs.<span class="built_in">add</span>(<span class="number">1</span>); <span class="comment">// error, compiler complain</span></span><br><span class="line"><span class="comment">// 编译器编译出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在再添加一个String</span></span><br><span class="line">objs.<span class="built_in">add</span>(<span class="string">"1"</span>); <span class="comment">// error, compiler complain</span></span><br><span class="line"><span class="comment">// 编译出错</span></span><br></pre></td></tr></table></figure>
<p>对于objs并不会因为<code>objs = strs;</code>的赋值，而将<code>objs</code>的泛型类型转化为<code>String</code>类型，所以在不能判断objs的泛型类型的情况下，往objs添加任何类型的对象都是不被允许的。但是我们明确知道objs的所有类型上限（upper bound），于是我们可以通过<code>objs.get(0)</code>获取Object的对象。</p>
<p> 小结一下，我们可以用通配符<code>? extends T</code>让泛型类变得协变，但是对于具体泛型类型的对象我们不能赋值，只能获取。于是在下面的假设中java就可以这么写：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="keyword">Source</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T getT();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setT(T t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">copy</span>(<span class="keyword">Source</span>&lt;String&gt; strs)&#123;</span><br><span class="line">    <span class="keyword">Source</span>&lt;? <span class="keyword">extends</span> Object&gt; objs = strs;</span><br><span class="line">    objs.setT(<span class="string">"a"</span>); <span class="comment">// error, compiler complain</span></span><br><span class="line">	String str = (String) objs.getT();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Kotlin</code>中就可以这么写：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span><span class="inheritance">&lt;<span class="parent">T</span></span>&gt; &#123;</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">getT</span></span>(): <span class="constant">T</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">setT</span></span>(<span class="symbol">t:</span> <span class="constant">T</span>)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copyT</span></span>(<span class="symbol">strs:</span> <span class="constant">Source</span>&lt;<span class="constant">String</span>&gt;)&#123;</span><br><span class="line">    val <span class="symbol">objs:</span> <span class="constant">Source</span>&lt;<span class="keyword">out</span> <span class="constant">Any</span>?&gt; = strs;</span><br><span class="line">    objs.setT(<span class="string">"a"</span>) /<span class="regexp">/ error, compiler complain</span><br><span class="line">    objs.getT()</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的<code>out Any?</code>可以用<code>*</code>代替。</p>
<p>如果我们可以确定<code>Source</code>这个类不会有<code>abstract fun setT(t: T)</code>类似的操作，我们可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Source</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line">    abstract <span class="function"><span class="keyword">fun</span> <span class="title">getT</span><span class="params">()</span>: T</span></span><br><span class="line">    <span class="comment">// 如果下面出现会编译不过</span></span><br><span class="line">    <span class="comment">// abstract fun setT(t: T) // error, compiler complain</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copyT</span><span class="params">(strs: <span class="typename">Source&lt;String&gt;</span>)</span>&#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> objs</span>: Source<span class="type">&lt;Any&gt;</span> = strs;</span><br><span class="line">    objs.setT(<span class="string">"a"</span>) <span class="comment">// error, compiler complain</span></span><br><span class="line">    objs.getT()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结一下，在定义泛型类<code>C&lt;T&gt;</code>时，当我们在泛型类型<code>T</code>前面添加<code>out</code>，<code>C</code>为<code>T</code>的协变类。在该类的作用域内，类型<code>T</code>只能作为该类中函数的返回类型，不能作为参数传递进来，这时也称做<code>C</code>为<code>T</code>的生产者（Producer）。</p>
<p>以此类推，在定义泛型类<code>C&lt;T&gt;</code>时，当我们在泛型类型<code>T</code>前面添加<code>in</code>，<code>C</code>为<code>T</code>的逆变类。在该类的作用域内，类型<code>T</code>只能作为该类中函数的参数传递进来，不能作为返回类型，这时也称做<code>C</code>为<code>T</code>的消费者（Consumer）。</p>
<p>类似于<code>java</code>中的<a href="http://www.importnew.com/8966.html" target="_blank" rel="external">PECS</a>（Producer Extends，Consumer Super），我们可以总结出：‘Consumer in, Producer out’。</p>
<p>如果在泛型类型使用测，在对应泛型的具体类型前面使用<code>out</code>，则等同于使用<code>java</code>中的<code>extends</code>字段，<code>in</code>则等同于<code>super</code>。</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun copy(<span class="keyword">from</span>: <span class="built_in">Array</span>&lt;out String&gt;, <span class="keyword">to</span>: <span class="built_in">Array</span>&lt;<span class="built_in">in</span> String&gt;) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="keyword">from</span>.<span class="built_in">size</span> == <span class="keyword">to</span>.<span class="built_in">size</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="built_in">in</span> <span class="keyword">from</span>.indices)</span><br><span class="line">        <span class="keyword">to</span>[i] = <span class="keyword">from</span>[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">public void copy(<span class="built_in">List</span>&lt;? extends String&gt; <span class="keyword">from</span>, <span class="built_in">List</span>&lt;? super String&gt; <span class="keyword">to</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>PS： 这里Array 与 List 不是对等关系。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.cnblogs.com/panjun-Donet/archive/2008/09/27/1300609.html" target="_blank" rel="external">java泛型</a></li>
<li><a href="http://www.cnblogs.com/Figgy/p/4575719.html" target="_blank" rel="external">不变性、协变性和逆变性（Invariance, Covariance &amp; Contravariance</a></li>
<li><a href="http://www.importnew.com/8966.html" target="_blank" rel="external">Java 泛型: 什么是PECS（Producer Extends, Consumer Super）</a></li>
<li><a href="https://kotlinlang.org/docs/reference/generics.html" target="_blank" rel="external">Kotlin-Generics</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>与java一样，Kotlin也提供泛型，为类型安全提供保证，消除类型强转的烦恼。</p>
<h3 id="u6CDB_u578B_u5B9A_u4E49"><a href="#u6CDB_u578B_u5B9A_u4E49" class="headerlink" title="泛型定义"></a>泛型定义</h3><p>好吧，如果只是简单声明一个泛型，和<code>Java</code>没有什么大的区别，你可以这样声明：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span><span class="inheritance">&lt;<span class="parent">T</span></span>&gt;(<span class="title">t</span>: <span class="title">T</span>) &#123;</span></span><br><span class="line">    var value = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以这样使用</p>]]>
    
    </summary>
    
      <category term="generics" scheme="http://yoursite.com/tags/generics/"/>
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
      <category term="泛型" scheme="http://yoursite.com/tags/%E6%B3%9B%E5%9E%8B/"/>
    
      <category term="类与对象" scheme="http://yoursite.com/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[类与对象 -- object]]></title>
    <link href="http://yoursite.com/2015/12/19/class-object-object/"/>
    <id>http://yoursite.com/2015/12/19/class-object-object/</id>
    <published>2015-12-19T11:02:38.000Z</published>
    <updated>2015-12-26T12:21:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5BF9_u8C61_uFF08object_uFF09_u8868_u8FBE_u5F0F_u548C_u5BF9_u8C61_u58F0_u660E"><a href="#u5BF9_u8C61_uFF08object_uFF09_u8868_u8FBE_u5F0F_u548C_u5BF9_u8C61_u58F0_u660E" class="headerlink" title="对象（object）表达式和对象声明"></a>对象（object）表达式和对象声明</h2><p>Kotlin中提供关键object，与java中的“Object”不同（在java中“Object”是所有类的基类，等同于Kotlin的“Any”，参考<a href="https://kotlinlang.org/docs/reference/java-interop.html#mapped-types" target="_blank" rel="external">java-interop</a>），用于直接申明一个对象，有两种使用写法：对象表达式和对象声明</p>
<h3 id="u5BF9_u8C61_u8868_u8FBE_u5F0F"><a href="#u5BF9_u8C61_u8868_u8FBE_u5F0F" class="headerlink" title="对象表达式"></a>对象表达式</h3><p>通过对象表达式可以越过类的定义直接得到一个对象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> point</span> = <span class="keyword">object</span> &#123;</span><br><span class="line">	<span class="variable"><span class="keyword">var</span> x</span>: <span class="typename">Int</span> = <span class="number">0</span></span><br><span class="line">	<span class="variable"><span class="keyword">var</span> y</span>: <span class="typename">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个对象可以继承于某个基类，或者实现其他接口:</p>
<a id="more"></a>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Device</span></span>(<span class="variable"><span class="keyword">var</span> name</span>: String) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Vedio &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">play</span><span class="params">()</span>&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">var</span> television</span> = <span class="keyword">object</span> : Device(<span class="string">"Sony"</span>), Vedio&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这可以方便的实现一个匿名内部类的对象用于方法的参数中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="typename">MouseEvent</span>)</span> &#123;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="typename">MouseEvent</span>)</span> &#123;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在对象表达中可以方便的访问到作用域中的其他变量，及时这个变量并不是<code>final</code>的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countClicks</span><span class="params">(window: <span class="typename">JComponent</span>)</span> &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> clickCount</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> enterCount</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="typename">MouseEvent</span>)</span> &#123;</span></span><br><span class="line">            clickCount++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="typename">MouseEvent</span>)</span> &#123;</span></span><br><span class="line">            enterCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u5BF9_u8C61_u58F0_u660E"><a href="#u5BF9_u8C61_u58F0_u660E" class="headerlink" title="对象声明"></a>对象声明</h3><p>对象声明可类似定义一个类一样定义一个对象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> RCtrl : Device(<span class="string">"Remote Control"</span>), Infrared &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(command: <span class="typename">Int</span>)</span> &#123;</span></span><br><span class="line">        <span class="comment">// send command</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> RCtrl : Device(<span class="string">"Remote Control"</span>), Infrared &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用的时候可以直接使用定义的对象：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span></span>(<span class="symbol">args:</span> <span class="constant">Array</span>&lt;<span class="constant">String</span>&gt;) &#123;</span><br><span class="line">    <span class="constant">RCtrl</span>.send(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然你也可以定义一个变量来获取获取这个对象，当时当你定义两个不同的变量来获取这个对象时，你会发现你并不能得到两个不同的变量。也就是说通过这种方式，我们获得一个<strong><em>单例</em></strong>。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> rCtrl1 = RCtrl</span><br><span class="line"><span class="tag">var</span> rCtrl2 = RCtrl</span><br><span class="line">rCtrl1<span class="class">.name</span> = <span class="string">"TV Control"</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"rCtrl2 name = $&#123;rCtrl2.name&#125;"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>在Kotlin中我们可以方便的通过对象声明来获得一个单例。</p>
<p>不过需要注意的是，对象声明不能直接定义在一个函数中。</p>
<p>与对象表达式不同，当对象声明在另一个类的内部时，这个对象并不能通过外部类的实例访问到该对象，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desk</span></span>&#123;</span><br><span class="line">	<span class="variable"><span class="keyword">var</span> legCount</span> = <span class="number">4</span></span><br><span class="line">	<span class="keyword">object</span> DeskTop&#123;</span><br><span class="line">       <span class="variable"><span class="keyword">var</span> area</span> = <span class="number">0</span></span><br><span class="line">       <span class="function"><span class="keyword">fun</span> <span class="title">showLegs</span><span class="params">()</span>&#123;</span></span><br><span class="line">       	print&#123;<span class="string">"desk legs $legCount"</span>&#125; <span class="comment">// error, compile complain</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="typename">Array&lt;String&gt;</span>)</span> &#123;</span></span><br><span class="line">	<span class="variable"><span class="keyword">var</span> desk</span> = Desk()</span><br><span class="line">   	desk.DeskTop.area <span class="comment">// error, compile complain</span></span><br><span class="line">   	Desk.DeskTop.area <span class="comment">// right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="companion_u5BF9_u8C61"><a href="#companion_u5BF9_u8C61" class="headerlink" title="companion对象"></a>companion对象</h3><p>当对象声明在另一个对象中时，我们可以通过关键字<code>companion</code>将对象与外部类关联在一起，这样我们就可以直接通过外部类访问到对象的内部元素。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Factory &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span>: MyClass = <span class="title">MyClass</span><span class="params">()</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">val</span> instance</span> = MyClass.create()</span><br></pre></td></tr></table></figure>
<p>我们甚至可以省略掉该对象的对象名，然后使用<code>Companion</code>替代需要声明的对象名：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">val</span> x</span> = MyClass.Companion</span><br></pre></td></tr></table></figure>
<p>看到上面的例子我们我们就会思考如果我们定义两个内部关联对象怎么办，答案当然是不行，不管是否声明对象名，一个类里面只能声明一个内部关联对象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desk</span></span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> DeskTop &#123;</span><br><span class="line">        <span class="variable"><span class="keyword">var</span> area</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Leg&#123;  <span class="comment">// error, compile complain</span></span><br><span class="line">        <span class="variable"><span class="keyword">var</span> lenght</span> = <span class="number">80</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://kotlinlang.org" target="_blank" rel="external">kotlin</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5BF9_u8C61_uFF08object_uFF09_u8868_u8FBE_u5F0F_u548C_u5BF9_u8C61_u58F0_u660E"><a href="#u5BF9_u8C61_uFF08object_uFF09_u8868_u8FBE_u5F0F_u548C_u5BF9_u8C61_u58F0_u660E" class="headerlink" title="对象（object）表达式和对象声明"></a>对象（object）表达式和对象声明</h2><p>Kotlin中提供关键object，与java中的“Object”不同（在java中“Object”是所有类的基类，等同于Kotlin的“Any”，参考<a href="https://kotlinlang.org/docs/reference/java-interop.html#mapped-types">java-interop</a>），用于直接申明一个对象，有两种使用写法：对象表达式和对象声明</p>
<h3 id="u5BF9_u8C61_u8868_u8FBE_u5F0F"><a href="#u5BF9_u8C61_u8868_u8FBE_u5F0F" class="headerlink" title="对象表达式"></a>对象表达式</h3><p>通过对象表达式可以越过类的定义直接得到一个对象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> point</span> = <span class="keyword">object</span> &#123;</span><br><span class="line">	<span class="variable"><span class="keyword">var</span> x</span>: <span class="typename">Int</span> = <span class="number">0</span></span><br><span class="line">	<span class="variable"><span class="keyword">var</span> y</span>: <span class="typename">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个对象可以继承于某个基类，或者实现其他接口:</p>]]>
    
    </summary>
    
      <category term="companion" scheme="http://yoursite.com/tags/companion/"/>
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
      <category term="object" scheme="http://yoursite.com/tags/object/"/>
    
      <category term="单例" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B/"/>
    
      <category term="对象" scheme="http://yoursite.com/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2015/12/17/new-to-kotlin/"/>
    <id>http://yoursite.com/2015/12/17/new-to-kotlin/</id>
    <published>2015-12-17T04:07:11.000Z</published>
    <updated>2015-12-17T04:07:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Kotlin_u7B80_u4ECB"><a href="#Kotlin_u7B80_u4ECB" class="headerlink" title="Kotlin简介"></a>Kotlin简介</h1><h2 id="Kotlin_u662F_u4EC0_u4E48"><a href="#Kotlin_u662F_u4EC0_u4E48" class="headerlink" title="Kotlin是什么"></a>Kotlin是什么</h2><p>发布于2011年，是一门适用于JVM, Android以及浏览器静态语言，<strong><em>100% 兼容Java™</em></strong></p>
<h2 id="u4E3A_u4EC0_u4E48_u9009_u62E9Kotlin"><a href="#u4E3A_u4EC0_u4E48_u9009_u62E9Kotlin" class="headerlink" title="为什么选择Kotlin"></a>为什么选择Kotlin</h2><ul>
<li>简洁，大幅度减少你需要写的重复代码</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用lambda表达式来过滤链表：</span><br><span class="line">val positiveNumbers = <span class="type">list</span>.filter &#123;<span class="keyword">it</span> &gt; <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>安全，避免整个类中类似空指针异常这样的错误，测试妹妹再也不用担心你的NullPointException了</p>
</li>
<li><p>通用，可以用于构建服务器端程序、Android程序或者运行在浏览器里的前端程序</p>
</li>
<li><p>互操作，重用已有的JVM平台框架或库，与Java无缝兼容，可直接在之前项目上面使用Kotlin</p>
</li>
<li><p>工具，一门语言需要工具化，这正是JetBrains做得最好的地方</p>
</li>
<li><p>可靠，JetBrains提供技术支持</p>
</li>
</ul>
<a id="more"></a>
<h2 id="u8BD5_u7528Kotlin"><a href="#u8BD5_u7528Kotlin" class="headerlink" title="试用Kotlin"></a>试用Kotlin</h2><ul>
<li>单独编译，你可以使用ant、maven或者gradle编译kotlin，<a href="https://kotlinlang.org/docs/tutorials/command-line.html" target="_blank" rel="external">编译器下载</a></li>
<li>在IntelliJ IDEA或者Android Studio上编写kotlin，<a href="https://kotlinlang.org/docs/tutorials/getting-started.html" target="_blank" rel="external">安装插件</a></li>
<li>在eclipse上编写kotlin，<a href="https://kotlinlang.org/docs/tutorials/getting-started-eclipse.html" target="_blank" rel="external">安装插件</a></li>
<li><a href="http://try.kotlinlang.org/" target="_blank" rel="external">在线编辑</a></li>
</ul>
<h2 id="u76F8_u5173_u8D44_u6E90"><a href="#u76F8_u5173_u8D44_u6E90" class="headerlink" title="相关资源"></a>相关资源</h2><ul>
<li><a href="https://kotlinlang.org/" target="_blank" rel="external">官方网站</a></li>
<li><a href="http://kotlinlang.cn/" target="_blank" rel="external">中文网站</a></li>
<li><a href="https://kotlinlang.org/docs/kotlin-docs.pdf" target="_blank" rel="external">文档下载</a></li>
<li><a href="https://kotlinthree.github.io/" target="_blank" rel="external">KotlinThree</a></li>
</ul>
<h2 id="u53C2_u8003_u5185_u5BB9"><a href="#u53C2_u8003_u5185_u5BB9" class="headerlink" title="参考内容"></a>参考内容</h2><p><a href="http://kotlinlang.cn/" target="_blank" rel="external">Kotlin</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Kotlin_u7B80_u4ECB"><a href="#Kotlin_u7B80_u4ECB" class="headerlink" title="Kotlin简介"></a>Kotlin简介</h1><h2 id="Kotlin_u662F_u4EC0_u4E48"><a href="#Kotlin_u662F_u4EC0_u4E48" class="headerlink" title="Kotlin是什么"></a>Kotlin是什么</h2><p>发布于2011年，是一门适用于JVM, Android以及浏览器静态语言，<strong><em>100% 兼容Java™</em></strong></p>
<h2 id="u4E3A_u4EC0_u4E48_u9009_u62E9Kotlin"><a href="#u4E3A_u4EC0_u4E48_u9009_u62E9Kotlin" class="headerlink" title="为什么选择Kotlin"></a>为什么选择Kotlin</h2><ul>
<li>简洁，大幅度减少你需要写的重复代码</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用lambda表达式来过滤链表：</span><br><span class="line">val positiveNumbers = <span class="type">list</span>.filter &#123;<span class="keyword">it</span> &gt; <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>安全，避免整个类中类似空指针异常这样的错误，测试妹妹再也不用担心你的NullPointException了</p>
</li>
<li><p>通用，可以用于构建服务器端程序、Android程序或者运行在浏览器里的前端程序</p>
</li>
<li><p>互操作，重用已有的JVM平台框架或库，与Java无缝兼容，可直接在之前项目上面使用Kotlin</p>
</li>
<li><p>工具，一门语言需要工具化，这正是JetBrains做得最好的地方</p>
</li>
<li><p>可靠，JetBrains提供技术支持</p>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Welcome]]></title>
    <link href="http://yoursite.com/2015/12/15/welcome/"/>
    <id>http://yoursite.com/2015/12/15/welcome/</id>
    <published>2015-12-15T13:36:29.000Z</published>
    <updated>2015-12-16T09:42:17.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img4.duitang.com/uploads/blog/201312/13/20131213162251_ueFLz.jpeg" alt="Zenus"></p>
<a id="more"></a>
<h2 id="KotlinThree_u7EC4_u7EC7_u6210_u7ACB_u4E86_uFF01_uFF01_uFF01_u6B22_u8FCE_u5927_u5BB6_u524D_u6765_u505A_u5BA2_uFF01_28_u6B64_u5904_u5E94_u6709_u638C_u58F0_7E_29_2C__u6B22_u8FCE_u5927_u5BB6_u4E00_u8D77_u6765_u5B66_u4E60_u63A2_u8BA8Kotlin"><a href="#KotlinThree_u7EC4_u7EC7_u6210_u7ACB_u4E86_uFF01_uFF01_uFF01_u6B22_u8FCE_u5927_u5BB6_u524D_u6765_u505A_u5BA2_uFF01_28_u6B64_u5904_u5E94_u6709_u638C_u58F0_7E_29_2C__u6B22_u8FCE_u5927_u5BB6_u4E00_u8D77_u6765_u5B66_u4E60_u63A2_u8BA8Kotlin" class="headerlink" title="KotlinThree组织成立了！！！欢迎大家前来做客！(此处应有掌声~), 欢迎大家一起来学习探讨Kotlin"></a><strong>KotlinThree组织成立了</strong>！！！欢迎大家前来做客！(此处应有掌声~), 欢迎大家一起来学习探讨Kotlin</h2>]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img4.duitang.com/uploads/blog/201312/13/20131213162251_ueFLz.jpeg" alt="Zenus"></p>]]>
    
    </summary>
    
      <category term="star" scheme="http://yoursite.com/tags/star/"/>
    
  </entry>
  
</feed>
