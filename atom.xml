<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KotlinThree&#39;s Blog</title>
  <subtitle>Kotliner 上海分会</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-25T06:35:57.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>KotlinThree</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/05/25/sk_love_block/"/>
    <id>http://yoursite.com/2017/05/25/sk_love_block/</id>
    <published>2017-05-25T06:35:57.000Z</published>
    <updated>2017-05-25T06:35:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我与-Kotlin-的爱恨情仇之浅谈-block"><a href="#我与-Kotlin-的爱恨情仇之浅谈-block" class="headerlink" title="我与 Kotlin 的爱恨情仇之浅谈 block"></a>我与 Kotlin 的爱恨情仇之浅谈 block</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>hi, IMSK。是的，你没看错，没迷路，这里是 <code>Kotlin</code>  ，不是 <code>Objective-C</code>，别怕接下来跟我一起认识认识这个 block 的前世今生。前方高能，请您带上耳机，戴上眼镜。</p>
<h2 id="block是什么？"><a href="#block是什么？" class="headerlink" title="block是什么？"></a>block是什么？</h2><p>先来看看 Kotlin 代码长什么样子：</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/2874486-92b0b5724169c608.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>其中 <code>body</code> 就是一个 block， <code>() -&gt; T</code> 是一个 函数块（ 函数签名 ）。block 可以当做参数传入， 也可以当做返回值返回。在这里我就沿用我之前写 Objective-C 的习惯，暂且称作他为 闭包。</p>
<h2 id="我爱-block"><a href="#我爱-block" class="headerlink" title="我爱 block"></a>我爱 block</h2><p>再来对比一下 Objective-C 里的 block：</p>
<p>double (^multiplyTwoValues)(double, double);</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2874486-9893735489e0c33f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如果之前没有写过 OC，那么我想第一反应只能无奈的说一句：不觉明历。回头来看看，还是 Kotlin 更加亲切一些，直接  <code>() -&gt; T</code> ，<code>{}</code>， 随便怎么玩，详细用法看官网吧<br><a href="https://kotlinlang.org/docs/reference/lambdas.html" target="_blank" rel="external">《Higher-Order Functions and Lambdas》</a> 。</p>
<p> 为什么爱上 block， 举个简单例子: 我们经常要处理一个异步请求，等数据返回的时候，回调给调用方，如果是用 Java 来写，可能要用到接口（callback）来实现了的。那么在 Kotlin 里怎么办呢？</p>
<p> 声明：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2874486-e2d2fbc43ee9ba8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>调用：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2874486-ca3216bbf543510f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>看到了么？不用在像以前那样还要单独去写一个 <code>callback</code>  的 <code>interface</code> 类了，是不是很简洁。</p>
<h2 id="我不爱-block"><a href="#我不爱-block" class="headerlink" title="我不爱 block"></a>我不爱 block</h2><p> 当然很大一部分原因是因为当年被 OC 中的 block 折磨的心累，写法让人难受不说，OC 先天的冗长代码实在是累，如果是个新手，还经常内存泄露，折磨的死去活来的。这里提一下，block是一个闭包，开发过程中，切记由于闭包是可以访问上文数据，处理不当就会导致内存泄露哦。</p>
<p> 当然还有另外一方面的原因，就是声明多参数的时候，比较难受，OC实在是不想在提了的，事实上 Kotlin 还算可以接受的，比如：</p>
<ul>
<li><p>Kotlin 中 block 多参数声明</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2874486-50b716e7833401b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>Kotlin 中 block 多参数调用</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2874486-dd20a3173a6a8837.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>Kotlin 中 block 随处可见 <code>{ ..do somethings.}</code>，所以咱必须得掌握它.</p>
<p>比如结合提供的列表操作的语法糖：</p>
<pre><code>strings.filter{ it.length == 5 }.sortBy{ it }.map{ it.toUpperCase() }
</code></pre><p>比如在 Android 中写一个延迟的 <code>Runnable</code>：</p>
<pre><code>postDelayed({
    //do somethings block
},300)
</code></pre><p> block 让代码写起来更加方便，更加灵活（比如尾闭包等），函数式编程三板斧离不开它，但 block 同时带来的弊端也是有的，比如可读性差/内存管头疼等。但个人愚见，利大于弊，虽然一直褒贬不一，饱受争议的一个神奇的东西。既然提到 block 那么当然离不开另外一个神奇的东西 <code>typedef</code> 。还好最新的 Kotlin 中已经有了 一个类似的东西 <code>Type aliases</code> ((<a href="https://kotlinlang.org/docs/reference/type-aliases.html" target="_blank" rel="external">Type aliases (since 1.1) - Kotlin Programming Language</a>) . 如果大家感兴趣的话，那我下一章来谈谈这个 block 离不开的小情人吧。</p>
<p> BTW  上面文中提到，block 会有内存泄露问题，无论还是 OC 是 Kotlin，当然我并没有提到如何解决，留给你第一个想象空间，那么第二个想象空间就是，既然有内存泄露，那么 block 的实现原理又是什么呢？ 跟匿名内部类有什么区别呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;我与-Kotlin-的爱恨情仇之浅谈-block&quot;&gt;&lt;a href=&quot;#我与-Kotlin-的爱恨情仇之浅谈-block&quot; class=&quot;headerlink&quot; title=&quot;我与 Kotlin 的爱恨情仇之浅谈 block&quot;&gt;&lt;/a&gt;我与 Kotlin 的爱恨情
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/05/25/sk_love_Type%20aliases/"/>
    <id>http://yoursite.com/2017/05/25/sk_love_Type aliases/</id>
    <published>2017-05-25T06:35:57.000Z</published>
    <updated>2017-05-25T06:35:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我与-Kotlin-的爱恨情仇之浅谈-Type-aliases"><a href="#我与-Kotlin-的爱恨情仇之浅谈-Type-aliases" class="headerlink" title="我与 Kotlin 的爱恨情仇之浅谈 Type aliases"></a>我与 Kotlin 的爱恨情仇之浅谈 Type aliases</h1><blockquote>
<p>在上一篇文章 <a href="http://www.jianshu.com/p/53c657bed4ab" target="_blank" rel="external">《我与 Kotlin 的爱恨情仇之浅谈 block》</a>最后, 我提到了 <code>Kotlin</code> 已经引入 <code>Type aliases</code> ，今天就跟大家一起来聊聊吧。</p>
</blockquote>
<h2 id="Type-aliases-是什么？"><a href="#Type-aliases-是什么？" class="headerlink" title="Type aliases 是什么？"></a>Type aliases 是什么？</h2><p>接受一个新的东西的时候，我们首先都会从字面去猜测它大概是用来做什么的，<code>Type aliases</code> 也不例外。<br> <code>Type</code> 顾名思义 <code>类型</code> , <code>aliases</code> 我想大伙也并不会太陌生，意味着 <code>别名</code>，很多时候我们会在系统的 <code>profile</code> 中加入一些 <code>aliases</code>，方便我们使用命令。二者联合起来就是： <code>给一个类型起一个别名</code>。</p>
<h2 id="我爱-Type-aliases"><a href="#我爱-Type-aliases" class="headerlink" title="我爱 Type aliases"></a>我爱 Type aliases</h2><ul>
<li><p>怎么用？</p>
<p>使用关键字 <code>typealias</code>，举个例子：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">typealias NodeSet = Set&lt;Network.Node&gt;</div><div class="line"></div><div class="line">typealias Predicate&lt;T&gt; = (T) -&gt; Boolean</div></pre></td></tr></table></figure>
<ul>
<li><p>我写项目的时候已经用到了哪些呢？</p>
<p><code>block</code> 闭包更加简洁，增加可复用，可读性。</p>
<p>上一篇文中讲解有趣的 <code>block</code>，总结中提到让人头疼声明冗长，可读性差的问题。举个例子：让你去封装一个网络下载的API，方法是异步更新状态。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1ffvimjc007j31kk036t9c.jpg" alt=""></p>
<p>一个方法还是可以接受，假如由于需求的变更，需要重载很多方法出来的时候怎么办呢？难道要这样子么？</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1ffvisrohxxj31kw09bgni.jpg" alt=""></p>
</li>
</ul>
<p>WTF,当然是review都不能通过的代码，看着新好累，当然在1.1之前抛开使用 block 而使用 interface，估计也只能选择无奈的review通过代码。但现在不用了的，使用 <code>typealias</code> 完美解决：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1ffw359wvmfj31g40dodik.jpg" alt=""></p>
<p>更多例子还是看官方文档吧：<a href="https://kotlinlang.org/docs/reference/type-aliases.html" target="_blank" rel="external">《reference/type-aliases》</a></p>
<h2 id="我不爱-Type-aliases"><a href="#我不爱-Type-aliases" class="headerlink" title="我不爱 Type aliases"></a>我不爱 Type aliases</h2><p>只是按照之前的吐槽方式而已，才有了这一个节点，可以忽略，因为我很爱 <code>Type aliases</code>。如果非要我吐槽的话，只能说来的太迟了把。哈哈哈。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p><code>Type aliases</code>的使用，能够让代码写起来更舒服。但切记不要滥用，比如文档中提到的 <code>typealias AInner = A.Inner</code>, 用的好的话还好，用的不好的话，别个接手你的代码要去跳转到定义里面才能看到这个别名到底是干嘛的。但它真是个好利器，赶紧用起来吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;我与-Kotlin-的爱恨情仇之浅谈-Type-aliases&quot;&gt;&lt;a href=&quot;#我与-Kotlin-的爱恨情仇之浅谈-Type-aliases&quot; class=&quot;headerlink&quot; title=&quot;我与 Kotlin 的爱恨情仇之浅谈 Type aliase
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/05/25/sk_love_Extensions/"/>
    <id>http://yoursite.com/2017/05/25/sk_love_Extensions/</id>
    <published>2017-05-25T06:35:57.000Z</published>
    <updated>2017-05-25T06:35:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我与-Kotlin-的爱恨情仇之浅谈-Extensions"><a href="#我与-Kotlin-的爱恨情仇之浅谈-Extensions" class="headerlink" title="我与 Kotlin 的爱恨情仇之浅谈 Extensions"></a>我与 Kotlin 的爱恨情仇之浅谈 Extensions</h1><blockquote>
<p>Kotlin, similar to C# and Gosu, provides the ability to extend a class with new functionality without having to inherit from the class or use any type of design pattern such as Decorator. This is done via special declarations called extensions. Kotlin supports extension functions and extension properties.</p>
</blockquote>
<p>上一个章节<a href="http://www.jianshu.com/p/2932135247af" target="_blank" rel="external">《我与 Kotlin 的爱恨情仇之浅谈 Type aliases》</a>中，带领大家一起领略了一下 <code>typealias</code>的基本用法。可以让你写出更加优美的代码。今天再带大家一起来领略一下 <code>Kotlin</code> 中另一个神奇好玩的东西: <code>Extensions</code>.</p>
<h2 id="Extensions-是什么？"><a href="#Extensions-是什么？" class="headerlink" title="Extensions 是什么？"></a>Extensions 是什么？</h2><p>千万不要被 <code>JAVA</code> 中的 <code>extend</code> 给带歪了的，一个是扩展，一个是继承，完全不是一码事。而且这也是我讨厌的一点，至于原因我接下来就会讲到，当然纯属我个人认知喜好问题。</p>
<p>文章口头就引用了<a href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="external">《reference/extensions》</a>中的一段话，已经解释了 <code>Kotlin</code> 具备可以 <code>extension</code> (扩展) <code>functions</code> 以及 <code>properties</code> 的能力。</p>
<h2 id="我爱-Extensions"><a href="#我爱-Extensions" class="headerlink" title="我爱 Extensions"></a>我爱 Extensions</h2><ul>
<li><p>Extension Functions 我们可以给任何一个 <code>类</code> 包括系统的类追加扩展方法</p>
<p>  给 <code>MutableList</code> 扩展(追加) 一个 <code>swap</code> 方法，用于交互两个 <code>index</code> 的 <code>value</code> :</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) &#123;</div><div class="line">    val tmp = this[index1] // &apos;this&apos; corresponds to the list</div><div class="line">    this[index1] = this[index2]</div><div class="line">    this[index2] = tmp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  具体用的时候:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">val l = mutableListOf(1, 2, 3)</div><div class="line">l.swap(0, 2) // &apos;this&apos; inside &apos;swap()&apos; will hold the value of &apos;l&apos;</div></pre></td></tr></table></figure>
<ul>
<li><p>Extension Properties 我们可以给任何一个 <code>类</code> 包括系统的类追加属性，但切记属性必须按约定来</p>
<p> 我们可以给给 <code>List</code> 追加一个 <code>lastIndex</code> 属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val &lt;T&gt; List&lt;T&gt;.lastIndex: Int</div><div class="line">get() = size - 1</div><div class="line">```    </div><div class="line"></div><div class="line">但是我说的约束是不能这样子写</div></pre></td></tr></table></figure>
<p> val Foo.bar = 1 // error: initializers are not allowed for extension properties<br>```</p>
<p>更多注意事项请看 <a href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="external">《官方文档》</a></p>
</li>
</ul>
</li>
</ul>
<h3 id="我们项目中拿他来干什么呢？"><a href="#我们项目中拿他来干什么呢？" class="headerlink" title="我们项目中拿他来干什么呢？"></a>我们项目中拿他来干什么呢？</h3><p>  <code>Google</code> 一搜索一大把，比如出了名的 <a href="https://github.com/Kotlin/anko" target="_blank" rel="external">anko</a> ，里面提供大量的 <code>Extension</code>。 但我并没有用过 <code>anko</code>，虽然使用 <code>Kotlin</code> 写 <code>Android</code> 项目已经超过两年了的，原因是个人觉得太重了的，我们自己也封装了一个轻量级的 <a href="https://github.com/KotlinThree/AndroidExtension" target="_blank" rel="external">AndroidExtension</a></p>
<p>  比如万恶的 <code>findViewById</code>,可以写成这样：</p>
<pre><code>val textview = findview(R.id.txt)
</code></pre><p> 比如臭长的 <code>Toast</code>, 现在也可以简单到这样啦：</p>
<pre><code>toast(&quot;hello,I&apos;M SK&quot;)
</code></pre><p> 还有更多有意思的，可以大大提高开发效率的扩展，具体可以查看我们的 <a href="https://github.com/KotlinThree" target="_blank" rel="external">KotlinThree GitHub</a></p>
<h2 id="我不爱-Extensions"><a href="#我不爱-Extensions" class="headerlink" title="我不爱 Extensions"></a>我不爱 Extensions</h2><p>no, no, no 不能不爱，用起来实在是太爽了的，极大的提高了我的日常开发效率，但非要让我挑毛病的话，我只能说因为当初的 <code>Swift</code> 坑了我吧，我第一反应是跟 <code>Swift extension</code> 一样，终于可以摆脱之前要在一个类的开头，写一堆的接口，类似这样:</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1ffwstpktgkj31060mk79f.jpg" alt="image.png"><br>    但在 <code>Swift</code> 中可以用 <code>extension</code> 完美解决这个问题：<br>    <img src="https://ws3.sinaimg.cn/large/006tNbRwgy1ffwsub7k3yj317k0j641m.jpg" alt=""><br>好吧，所以在没有看仔细看 <code>Kotlin</code> 文档的时候，我以为 <code>extension</code> 用法和 <code>Swift</code> 一样呢，但完全不是一个概念。<code>Kotlin</code> 中压根就没有这个 <code>extension</code> 关键字。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p> 这个语法糖，你可以随便去扩展你自己想要的功能，从而极大的提高我们开发效率，用起来确实让人爱不释手。那么 <code>Kotlin</code>  内部是怎么实现的？ 可以看看编译出来的文件，其实是帮忙做了一层转换，把我们的扩展的方法做成一个 <code>static method</code>, 然后调用的地方其实是调用生成的的这个 <code>static method</code>，之前<a href="http://www.jianshu.com/p/53c657bed4ab" target="_blank" rel="external">《我与 Kotlin 的爱恨情仇之浅谈 block》</a>谈到的另一把我爱不释手的利器 <code>block</code> 在评论中我也说了的，都是人家最后帮我们去生成了代码，然后一样的做法，虽然效率并没有任何提升，有兴趣的话，您不妨自己反编译试试。但却不得不说，大大提高了我们本身编码效率，毕竟重复的代码，谁写着都觉得心累。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;我与-Kotlin-的爱恨情仇之浅谈-Extensions&quot;&gt;&lt;a href=&quot;#我与-Kotlin-的爱恨情仇之浅谈-Extensions&quot; class=&quot;headerlink&quot; title=&quot;我与 Kotlin 的爱恨情仇之浅谈 Extensions&quot;&gt;&lt;/a
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/05/25/kotlin_do_java_not/"/>
    <id>http://yoursite.com/2017/05/25/kotlin_do_java_not/</id>
    <published>2017-05-25T06:35:57.000Z</published>
    <updated>2017-05-25T06:35:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="那些年Kotlin轻易能实现，java很难实现的语法糖"><a href="#那些年Kotlin轻易能实现，java很难实现的语法糖" class="headerlink" title="那些年Kotlin轻易能实现，java很难实现的语法糖"></a>那些年Kotlin轻易能实现，java很难实现的语法糖</h2><p>做android开发那么多年， 一直都是兢兢业业用java去码代码，直到两年前的一天发现了kotlin这门神奇的语言。犀利的语法特性，优雅的表达方式，从此掉入此坑。</p>
<p>这里有个<a href="http://www.jcodecraeer.com/demo/from-java-to-kotlin/classes.html" target="_blank" rel="external">对比链接</a>可以看到表达同一个含义，kotlin相对java在表达上的优势。 </p>
<p>最近google io大会把kotlin定为Android开发第一级语言，着实掀起了一股讨论kotlin的浪潮。那么，未来的androider是不是会用kotlin替代java呢？这里我们来讨论下一个话题：那些Kotlin轻易能实现，java很难实现的语法糖，由此来看一看kotlin的独特魅力。</p>
<h2 id="函数编程"><a href="#函数编程" class="headerlink" title="函数编程"></a>函数编程</h2><p>在kotlin中，函数和类一样是一等公民，函数也可以作为参数传递（高阶函数特性），且可执行(闭包特性)。举个栗子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 函数作为对象</div><div class="line">val magic = fun(name: String) &#123;</div><div class="line">    println(&quot;hello $name&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 函数闭包执行</div><div class="line">magic(&quot;tom&quot;)</div><div class="line"></div><div class="line"></div><div class="line">// 函数作为参数</div><div class="line">fun test(funParam: (String) -&gt; Unit) &#123;</div><div class="line">    funParam(&quot;tom2&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">test(magic)</div></pre></td></tr></table></figure>
<p>在集合类的数据处理上，kotlin中的<code>filter</code>、<code>map</code>等能方便做到数据转换。举个栗子，给定一个数字数组，过滤出数字为3的倍数的数字集合，数字前加#，以逗号分隔输出。如数组为<code>0~10</code>， 打印输出<code>#0, #3, #6, #9</code></p>
<p>java代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">private static String solveList(List&lt;Integer&gt; list) &#123;</div><div class="line">    // filter</div><div class="line">    List&lt;Integer&gt; filterResult = new ArrayList&lt;&gt;();</div><div class="line">    for (Integer i : list) &#123;</div><div class="line">        if (i % 3 == 0) &#123;</div><div class="line">            filterResult.add(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // map</div><div class="line">    List&lt;String&gt; mapResult = new ArrayList&lt;&gt;();</div><div class="line">    for (Integer i : filterResult) &#123;</div><div class="line">        mapResult.add(&quot;#&quot; + i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 逗号分隔</div><div class="line">    StringBuilder sb = new StringBuilder();</div><div class="line">    for (String s : mapResult) &#123;</div><div class="line">        sb.append(s).append(&quot;, &quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (sb.length() &gt; 0) &#123;</div><div class="line">        return sb.substring(0, sb.length() - 2);</div><div class="line">    &#125; else &#123;</div><div class="line">        return &quot;&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>kotlin代码如下，异常的简洁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun solveList(list: List&lt;Int&gt;) : String &#123;</div><div class="line">    return list.filter &#123; it % 3 == 0 &#125;.map &#123; &quot;#$it&quot; &#125;.reduce &#123; s1, s2 -&gt; &quot;$s1, $s2&quot; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>kotlin用的是函数式思维方式，函数式三板斧<code>filter</code>, <code>map</code>, <code>reduce</code> 接受函数作为参数，屏蔽了内部实现。 比如说这里3的倍数改成5的倍数，kotlin只要改<code>filter</code>的参数（函数参数）即可，java则要改方法的内部实现。</p>
<h2 id="Extension"><a href="#Extension" class="headerlink" title="Extension"></a>Extension</h2><p>kotlin可对系统类进行方法扩展，如可以为集合增加<code>swap</code>函数功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun &lt;T&gt; MutableList&lt;T&gt;.swap(index1: Int, index2: Int) &#123;</div><div class="line">    val tmp = this[index1] // &apos;this&apos; corresponds to the list</div><div class="line">    this[index1] = this[index2]</div><div class="line">    this[index2] = tmp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义之后<code>MutableList</code>类型就可以直接调用<code>swap</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val list = mutableListOf(&quot;aa&quot;, &quot;bb&quot;)</div><div class="line">list.swap(0, 1)</div></pre></td></tr></table></figure>
<p>这种形式java是无法做到的，java要实现同样的功能必须额外定义一个新类。（事实上kotlin extension原理也是编译器生成一个新类~~）</p>
<h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><p>数据类大量重复的getter和setter相信会是很多人在开发过程中吐槽的一个点。举一个很经典的例子，我们需要一个Person的数据类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public class Person &#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">    private int sex;</div><div class="line">    private float height;</div><div class="line"></div><div class="line">    public Person(String name, int age, int sex, float height) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.sex = sex;</div><div class="line">        this.age = age;</div><div class="line">        this.height = height;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getAge() &#123;</div><div class="line">        return age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setAge(int age) &#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getSex() &#123;</div><div class="line">    	 return sex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setSex(int sex) &#123;</div><div class="line">    	this.sex = sex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public float getHeight() &#123;</div><div class="line">        return height;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setHeight(float height) &#123;</div><div class="line">        this.height = height;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;Person&#123;&quot; +</div><div class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</div><div class="line">                &quot;, age=&quot; + age +</div><div class="line">                &quot;, sex=&quot; + (sex == 0 ? &quot;男&quot; : &quot;女&quot;) +</div><div class="line">                &quot;, height=&quot; + height +</div><div class="line">                &quot;&#125;&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Kotlin里，我们只需要一行代码就能完成以上的功能： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data class Person(var name: String, var age: Int, var sex: Int, var height: Float)</div></pre></td></tr></table></figure>
<p><code>data class</code>有效的提供了一种构建器模式，可以指定参数初始化，同时默认提供<code>clone</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//创建对象</div><div class="line">val person: Person = Person(name=&quot;tom&quot;, age = 10, height = 1.7f)</div></pre></td></tr></table></figure>
<h2 id="Type-alias"><a href="#Type-alias" class="headerlink" title="Type alias"></a>Type alias</h2><p>java没alias的说法, kotlin type alias暂时很少用到，就不细讲了，有兴趣的参考官网链接 <a href="https://kotlinlang.org/docs/reference/type-aliases.html" target="_blank" rel="external">type-aliases</a></p>
<h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><p>kotlin通过<code>${expression}</code>输出字符串，<code>expression</code>表示任意表达式 如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">println(&quot;My name&apos;s &#123;user.name&#125;&quot;)</div><div class="line">println(&quot;1 + 2 = $&#123;1 + 2&#125;&quot;)</div></pre></td></tr></table></figure>
<p>java用<code>String.format</code>形式实现</p>
<p>kotlin输出<code>list</code>, <code>map</code>等类型就友好的多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">val list = (0..10).toMutableList()</div><div class="line">println(&quot;list=$list&quot;)</div><div class="line">// 输出list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</div><div class="line"></div><div class="line">val map = mapOf(1 to &quot;One&quot;, 2 to &quot;Two&quot;, 3 to &quot;Three&quot;)</div><div class="line">println(&quot;map=$map&quot;)</div><div class="line"></div><div class="line">// 输出map=&#123;1=One, 2=Two, 3=Three&#125;</div></pre></td></tr></table></figure>
<h2 id="option参数"><a href="#option参数" class="headerlink" title="option参数"></a>option参数</h2><p>kotlin有option参数的说法，如定义个图片加载接口，java需要通过重载方式定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">interface IHJImageLoader &#123;</div><div class="line">    public void displayImage(String uri, ImageView imageView);</div><div class="line"></div><div class="line">    public void displayImage(String uri, ImageView imageView, HJImageLoaderOptiono option);</div><div class="line"></div><div class="line">    public void displayImage(String uri, ImageView imageView, HJImageLoaderListener loaderListener);</div><div class="line"></div><div class="line">    public void displayImage(String uri, ImageView imageView, HJImageLoaderOptiono option, HJImageLoaderListener loaderListener);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而kotlin只要定义个一个方法就行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface IHJImageLoader &#123;</div><div class="line">    fun displayImage(uri: String?, imageView: ImageView?, option: HJImageLoaderOption? = HJImageLoaderOption.defaultOption(), loaderListener: HJImageLoaderListener? = null)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用方式都是类似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val imageLoaderImpl: IHJImageLoader = ...</div><div class="line"></div><div class="line">imageLoaderImpl.displayImage(uri, imageView)</div><div class="line">imageLoaderImpl.displayImage(uri, imageView, option)</div><div class="line">imageLoaderImpl.displayImage(uri, imageView, option, loaderListener)</div></pre></td></tr></table></figure>
<h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>kotlin操作符重载在DSL中得以发扬光大, 如下面一段语句表达</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">html &#123;</div><div class="line">	body &#123;</div><div class="line">		div &#123;</div><div class="line">			a(&quot;http://kotlinlang.org&quot;) &#123;</div><div class="line">				target = ATarget.blank</div><div class="line">				+&quot;Main site&quot;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>java要表达同样的含义，至少得<code>html</code>, <code>body</code>, <code>div</code>, <code>a</code>对象都<code>new</code>一遍，且要设置成员变量。冗余度和可读性上都远不如上面的表达来的舒爽。</p>
<h2 id="协程编程"><a href="#协程编程" class="headerlink" title="协程编程"></a>协程编程</h2><p>todo</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;那些年Kotlin轻易能实现，java很难实现的语法糖&quot;&gt;&lt;a href=&quot;#那些年Kotlin轻易能实现，java很难实现的语法糖&quot; class=&quot;headerlink&quot; title=&quot;那些年Kotlin轻易能实现，java很难实现的语法糖&quot;&gt;&lt;/a&gt;那些年Ko
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>玩转 Kotlin 委托属性</title>
    <link href="http://yoursite.com/2017/05/22/kotlin_properties_delegate/"/>
    <id>http://yoursite.com/2017/05/22/kotlin_properties_delegate/</id>
    <published>2017-05-22T13:04:43.000Z</published>
    <updated>2017-05-22T13:04:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>tags: Kotlin</p>
<h2 id="Kotlin-属性"><a href="#Kotlin-属性" class="headerlink" title="Kotlin 属性"></a>Kotlin 属性</h2><p>要讲 Kotlin 的委托属性，要先从 Kotlin 的属性说起，当然关于属性的定义就不多介绍了。这里介绍一下 Kotlin 区别于 Java 独有的 back field 的概念。用过 Kotlin 的人都知道，Kotlin 的属性是天生带 Setter/Getter 方法的，不过如果要重写他们的话，写法有所不同。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a: String = &quot;1&quot;</div><div class="line">	get() = field</div><div class="line">	set(value) &#123;</div><div class="line">        field = value</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，当需要重写 Setter/Getter 方法的时候，就需要用到 field 这个新概念，它其实是代表这个域本身。有些人刚开始看到这个东西的时候，可能会觉得很神秘，其实它里面的实现逻辑很简单，就是对应到 Java 中 Setter/Getter 方法，然后 field 在 Java 的方法中就是该属性本身，上面的代码编译后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@NotNull</div><div class="line">private String a = &quot;1&quot;;</div><div class="line"></div><div class="line">@NotNull</div><div class="line">public final String getA() &#123;</div><div class="line">  return this.a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public final void setA(@NotNull String value) &#123;</div><div class="line">  Intrinsics.checkParameterIsNotNull(value, &quot;value&quot;);</div><div class="line">  this.a = value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基于这样的逻辑，对于 <code>Kotlin</code> 属性的 <code>lateinit</code> 修饰符的实现原理，就可以很简单的推理出来，在属性的 <code>Getter</code> 方法中先判断该属性是否被赋值，否则的话抛出异常，下面就是一个用 <code>lateinit</code> 修饰的属性生成的 <code>Getter</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@NotNull</div><div class="line">public final String getPropLateInit() &#123;</div><div class="line">  String var10000 = this.propLateInit;</div><div class="line">  if(this.propLateInit == null) &#123;</div><div class="line">     Intrinsics.throwUninitializedPropertyAccessException(&quot;propLateInit&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return var10000;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>讲到这里，反应快的人应该能猜到到，下面要讲的属性委托是基于什么原理实现的了。</p>
<h2 id="Kotlin-委托属性"><a href="#Kotlin-委托属性" class="headerlink" title="Kotlin 委托属性"></a>Kotlin 委托属性</h2><h3 id="委托属性的声明"><a href="#委托属性的声明" class="headerlink" title="委托属性的声明"></a>委托属性的声明</h3><p>定义一个委托属性的语法是 <code>val/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt;</code>，其中 <code>by</code> 后面的就是属性的委托。属性委托不用继承什么特别的接口，只要拥有用 <code>operator</code> 修饰的 <code>getValue()</code> 和 <code>setValue()</code> (适用 var)的函数就可以了。</p>
<p>需要注意的是在官方的文档里，要求 <code>getValue()</code> 和 <code>setValue()</code> 两个函数提供固定的参数，就像下面的例子一样。但是事实其实并非如此，这里我们先按照官方的说法继续，后面再解释这里的差异。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Delegate &#123;</div><div class="line">    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123;</div><div class="line">        return &quot;$thisRef, thank you for delegating &apos;$&#123;property.name&#125;&apos; to me!&quot;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123;</div><div class="line">        println(&quot;$value has been assigned to &apos;$&#123;property.name&#125; in $thisRef.&apos;&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于参数的描述这里做一个简单描述：</p>
<ul>
<li><code>thisRef</code>，属性的拥有者；</li>
<li><code>property</code>，对属性的描述，是 KProperty&lt;*&gt; 类型或是它的父类；</li>
<li><code>value</code>，属性的值。</li>
</ul>
<h3 id="委托属性的背后实现"><a href="#委托属性的背后实现" class="headerlink" title="委托属性的背后实现"></a>委托属性的背后实现</h3><p>Kotlin 官方在官方标准库里提供委托属性的三个常用场景，作为委托属性的范例。这里重点分析一下 <code>lazy</code> 的背后的实现原理，然后顺带讲一下 <code>Observable</code> 和 <code>storing</code> 的用法。</p>
<h4 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h4><p>通过 <code>lazy</code> 我们可以定义一个懒加载的属性，该属性的初始化不会再类创建的时候发生，而是在第一次用到它的时候赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val propLazy: Int by lazy&#123;1&#125;</div></pre></td></tr></table></figure>
<p>我们查看一下编译后的 <code>bytecode</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">	LINENUMBER 4 L1</div><div class="line">	ALOAD 0</div><div class="line">	GETSTATIC PropertiesDemo$propLazy$2.INSTANCE : LPropertiesDemo$propLazy$2;</div><div class="line">	CHECKCAST kotlin/jvm/functions/Function0</div><div class="line">	INVOKESTATIC kotlin/LazyKt.lazy (Lkotlin/jvm/functions/Function0;)Lkotlin/Lazy;</div><div class="line">	PUTFIELD PropertiesDemo.propLazy$delegate : Lkotlin/Lazy;</div><div class="line">L2</div></pre></td></tr></table></figure>
<p>字节码的可读性太差，我们反编译一下，找到相关的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public PropertiesDemo() &#123;</div><div class="line">  this.propLazy$delegate = LazyKt.lazy((Function0)null.INSTANCE);</div><div class="line">&#125;</div><div class="line">   </div><div class="line">@NotNull</div><div class="line">private final Lazy propLazy$delegate;</div><div class="line"></div><div class="line">static final KProperty[] $$delegatedProperties = new KProperty[]&#123;(KProperty)Reflection.property1(new PropertyReference1Impl(Reflection.getOrCreateKotlinClass(PropertiesDemo.class), &quot;propLazy&quot;, &quot;getPropLazy()I&quot;)))&#125;;</div><div class="line">   </div><div class="line">public final int getPropLazy() &#123;</div><div class="line">  Lazy var1 = this.propLazy$delegate;</div><div class="line">  KProperty var3 = $$delegatedProperties[0];</div><div class="line">  return ((Number)var1.getValue()).intValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 Kotlin 为我们生成了一个 <code>Lazy</code> 类型的 <code>propLazy$delegate</code> 属性，同时生成一个 <code>getPropLazy()</code> 方法，但是我们并没有找到 <code>propLazy</code> 属性的定义（这一点我们先不管，后面再说）。</p>
<p>在 <code>getPropLazy()</code> 的实现里可以看到返回的是 <code>propLazy$delegate.getValue()</code> 的值，再看下 <code>propLazy$delegate</code> 的赋值是在类的构造函数里面 <code>this.propLazy$delegate = LazyKt.lazy((Function0)null.INSTANCE);</code>。LazyKt 是系统的 <code>Lazy.kt</code> 文件生成的类文件，找到 <code>Lazy.kt</code> 的 <code>lazy()</code> 方法，返回的是 <code>SynchronizedLazyImpl</code> 的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@kotlin.jvm.JvmVersion</div><div class="line">public fun &lt;T&gt; lazy(initializer: () -&gt; T): Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)</div></pre></td></tr></table></figure>
<p>在 <code>SynchronizedLazyImpl</code> 实现代码里，通过 <code>_value</code> 用来真正保存属性的值。<code>_value</code> 的默认值是 <code>UNINITIALIZED_VALUE</code> (一个自定义的对象)。当 <code>_value</code> 不是默认值的时候，就会直接把 <code>_value</code> 的值作为 <code>getValue()</code> 的返回；当 <code>_value</code> 还是默认值的时候，就会调用 <code>initializer</code> 初始化表达式完成初始化，赋值给 <code>_value</code> 并作为 <code>getValue()</code> 的返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">private object UNINITIALIZED_VALUE</div><div class="line">private class SynchronizedLazyImpl&lt;out T&gt;(initializer: () -&gt; T, lock: Any? = null) : Lazy&lt;T&gt;, Serializable &#123;</div><div class="line">    private var initializer: (() -&gt; T)? = initializer</div><div class="line">    @Volatile private var _value: Any? = UNINITIALIZED_VALUE</div><div class="line">    // final field is required to enable safe publication of constructed instance</div><div class="line">    private val lock = lock ?: this</div><div class="line"></div><div class="line">    override val value: T</div><div class="line">        get() &#123;</div><div class="line">            val _v1 = _value</div><div class="line">            if (_v1 !== UNINITIALIZED_VALUE) &#123;</div><div class="line">                @Suppress(&quot;UNCHECKED_CAST&quot;)</div><div class="line">                return _v1 as T</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return synchronized(lock) &#123;</div><div class="line">                val _v2 = _value</div><div class="line">                if (_v2 !== UNINITIALIZED_VALUE) &#123;</div><div class="line">                    @Suppress(&quot;UNCHECKED_CAST&quot;) (_v2 as T)</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    val typedValue = initializer!!()</div><div class="line">                    _value = typedValue</div><div class="line">                    initializer = null</div><div class="line">                    typedValue</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE</div><div class="line"></div><div class="line">    override fun toString(): String = if (isInitialized()) value.toString() else &quot;Lazy value not initialized yet.&quot;</div><div class="line"></div><div class="line">    private fun writeReplace(): Any = InitializedLazyImpl(value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们发现 <code>SynchronizedLazyImpl</code> 的 <code>getValue()</code> 方法并没有带参数，在反编译的 <code>getPropLazy()</code> 代码中 <code>KProperty var3 = $$delegatedProperties[0];</code> 这个变量其实根本没有用到，其实在正常的委托的反编译的代码是类似这样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return (String)this.propObservable$delegate.getValue(this, $$delegatedProperties[1]);</div></pre></td></tr></table></figure>
<p>所以说其实我们在定义委托的时候，<code>getValue()</code> 和 <code>setValue()</code> 方法是可以不带参数的，只是官方在编译阶段做了限制，导致我们只能拥有带参数的方法。为了验证如果这个想法，我参考 <code>lazy</code> 实现了一个类似的功能，发现根本不能通过编译。</p>
<h5 id="关于-propLazy-属性本身"><a href="#关于-propLazy-属性本身" class="headerlink" title="关于 propLazy 属性本身"></a>关于 <code>propLazy</code> 属性本身</h5><p>前面我们有提到在生成的字节码中，并不能找到 <code>propLazy</code> 这个属性的定义，我们先看看官网怎么说的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class C &#123;</div><div class="line">    var prop: Type by MyDelegate()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// this code is generated by the compiler instead:</div><div class="line">class C &#123;</div><div class="line">    private val prop$delegate = MyDelegate()</div><div class="line">    var prop: Type</div><div class="line">        get() = prop$delegate.getValue(this, this::prop)</div><div class="line">        set(value: Type) = prop$delegate.setValue(this, this::prop, value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据官方的文档描述，<code>Kotlin</code> 会自动生成 <code>prop$delegate</code> 属性，并复写 <code>prop</code> 的 <code>Setter/Getter</code> 方法。按照这个说话的话，我们上面在编译后的字节码里面应该是可以找到 <code>propLazy</code> 属性的。</p>
<p>为了验证这个问题，我首先想到是不是因为这个属性是私有变量，在类里面没有使用，所以 <code>Kotlin</code> 编译器为了优化生成字节码的数量而故意去掉了呢。于是我故意在另外一个方法里尝试输出该属性，但是最后发现在编译后该处的使用被替换成 <code>getPropLazy()</code> 方法的调用，所以看来 <code>propLazy</code> 是真的没有了。</p>
<p>为了进一步验证这个想法，我们还在运行时用反射的方法去获取该属性，发现的确找不到该属性，最后我们得出结论是委托属性在编译后会生成对应的 <code>prop$delegate</code> （被委托的属性」），然后生成生成委托属性的 <code>Setter/Getter</code> 方法，但是该属性本身并不在类的域定义里面，这个时候尝试用反射的方法直接拿到这个属性是做不到的（当然你可以通过 <code>prop$delegate</code> 反射到你想要的内容）。</p>
<h3 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h3><p>官方推荐另外一个委托属性的应用就是 <code>Observable</code>，让属性在发生变动的时候可以被关注的地方观察到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class User &#123;</div><div class="line">    var name: String by Delegates.observable(&quot;&lt;no name&gt;&quot;) &#123;</div><div class="line">        prop, old, new -&gt;</div><div class="line">        println(&quot;$old -&gt; $new&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val user = User()</div><div class="line">    user.name = &quot;first&quot;</div><div class="line">    user.name = &quot;second&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;no name&gt; -&gt; first</div><div class="line">first -&gt; second</div></pre></td></tr></table></figure>
<p>想了解 <code>Observable</code> 的实现方式，大家可以参考前面分析 <code>lazy</code> 的方法，去探究一下。关于 <code>Observable</code> 的进一步实现场景，我们一直有一个想法，就是基于这个特性封装出一套 MVVM 的框架，等到这个框架实现以后，再和大家分享。</p>
<h3 id="Storing"><a href="#Storing" class="headerlink" title="Storing"></a>Storing</h3><p><code>Storing</code> 的使用场景是被模型的属性全部委托到 <code>Map</code> 的结构去真实的存储数据，用于解析 <code>Json</code> 或者做一些动态的事情。</p>
<pre><code>class User(val map: Map&lt;String, Any?&gt;) {
    val name: String by map
    val age: Int     by map
}
</code></pre><p>不过根据我的了解，一些 Json 的解析库是直接用反射的方式实现的反序列化，根据我们前面的分析，这里根本解析不出来，所以这个场景看来是使用不了了。</p>
<h2 id="关于-BufferKnife-和-KotterKnife"><a href="#关于-BufferKnife-和-KotterKnife" class="headerlink" title="关于 BufferKnife 和 KotterKnife"></a>关于 <code>BufferKnife</code> 和 <code>KotterKnife</code></h2><h3 id="BufferKnife"><a href="#BufferKnife" class="headerlink" title="BufferKnife"></a><code>BufferKnife</code></h3><p>在 <code>Kotlin</code> 刚推出来的时候，由于不支持 <code>apt</code> ，所以会导致 <code>BufferKnife</code> 这类用注解实现的框架会使用不了，但是  <code>Kotlin</code> 很快就意识到这个问题并推出 <code>kapt</code>。在 <code>kapt</code> 推出来以后其实 <code>BufferKnife</code> 就可以正常使用了，我们也在我们的代码里使用了 <code>BufferKnife</code>。但当时 <code>BufferKnife</code> 在增量编译的时候有时候的确会出一些问题，导致我们那个时候最后选择了放弃，我们自己简单封装下 <code>findViewById</code> 的操作，有兴趣的可以看下 <a href="https://github.com/KotlinThree/AndroidExtension" target="_blank" rel="external">AndroidExtension</a> 。可能有些人关于 <code>Kotlin</code> 和 <code>BufferKnife</code> 的冲突信息是来自我们当时不准确的描述，导致认为他们不能一起使用。而且经过这么久的迭代，我相信官方应该早就解决这个问题了。</p>
<h3 id="KotterKnife"><a href="#KotterKnife" class="headerlink" title="KotterKnife"></a><code>KotterKnife</code></h3><p><code>KotterKnife</code> 这个库的存在可能也是很多人认为 <code>Kotlin</code> 不能使用 <code>BufferKnife</code> 的一个因素。在我看来 <code>KotterKnife</code> 创建的时机是 <code>Kotlin</code> 还不支持 <code>apt</code> 的时候，在  <code>Kotlin</code> 推出 <code>kapt</code> 以后这个库就已经不怎么更新了，而且这个库从来没有发布过一个正式版本，所以可以看出这只是大神在用 <code>Kotlin</code> 做的一些新的尝试而已（这一点我是通过查看代码发现 <code>KotterKnife</code> 主要使用「委托属性」这个特性猜想出来的，仅供参考）。</p>
<hr>
<p><img src="http://7xpox6.com1.z0.glb.clouddn.com/kotlin-three-wechat.jpg" alt=""></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="external">官方文档</a></li>
<li><a href="https://github.com/JakeWharton/kotterknife" target="_blank" rel="external">kotterknife</a></li>
<li><a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">butterknife</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tags: Kotlin&lt;/p&gt;
&lt;h2 id=&quot;Kotlin-属性&quot;&gt;&lt;a href=&quot;#Kotlin-属性&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 属性&quot;&gt;&lt;/a&gt;Kotlin 属性&lt;/h2&gt;&lt;p&gt;要讲 Kotlin 的委托属性，要先从 Kotlin 的属性说起，当然关于属性的定义就不多介绍了。这里介绍一下 Kotlin 区别于 Java 独有的 back field 的概念。用过 Kotlin 的人都知道，Kotlin 的属性是天生带 Setter/Getter 方法的，不过如果要重写他们的话，写法有所不同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Swift vs. Kotlin 漫谈之函数定义</title>
    <link href="http://yoursite.com/2017/05/22/swiftvskotlin_define_function/"/>
    <id>http://yoursite.com/2017/05/22/swiftvskotlin_define_function/</id>
    <published>2017-05-22T05:07:40.000Z</published>
    <updated>2017-05-22T05:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>tags: Kotlin, Swift</p>
<p>Kotlin 君和 Swift 君在一个团队一起开发已经很久了，由于平台的差异性，他们经常会进行一些技术上的交流（PK），「Kotlin vs. Swift」课程就是他们在互相切磋是的语录。</p>
<a id="more"></a>
<h2 id="技术漫谈"><a href="#技术漫谈" class="headerlink" title="技术漫谈"></a>技术漫谈</h2><p><strong>Swift：</strong></p>
<p>Hi，又见面了。</p>
<p><strong>Kotlin：</strong></p>
<p>恩，上次没分出胜负，这次再来。</p>
<p><strong>Swift：</strong></p>
<p>好，今天讲讲函数，你们是怎么定义函数的呀？</p>
<p><strong>Kotlin：</strong></p>
<p>我们是这样定义的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun &lt;functionName&gt;(&lt;parameters&gt;)[: &lt;Type&gt;] &#123;</div><div class="line">    &lt;block&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你们呢？</p>
<p><strong>Swift：</strong></p>
<p>我们是这么定义的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func &lt;function name&gt;(&lt;parameters&gt;) -&gt; &lt;return type&gt; &#123;</div><div class="line">    &lt;statements&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Kotlin：</strong></p>
<p>区别就是个 <code>-&gt;</code> 和 <code>:</code> 的区别啊，其它都一样。</p>
<p><strong>Swift：</strong></p>
<p>嗯嗯嗯。还有个 <code>func</code> 和 <code>fun</code> 的区别。</p>
<p><strong>Kotlin：</strong></p>
<p>我们还可以用「单一表达式」直接声明函数，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun &lt;functionName&gt;(&lt;parameters&gt;)[: &lt;Type&gt;] = &lt;singleExpression&gt;</div></pre></td></tr></table></figure>
<p>在使用「单一表达式」来声明函数的时候返回的类型可以被推断出来，所以可以忽略不写。</p>
<p><strong>Swift：</strong></p>
<p>牛X。</p>
<p><strong>Kotlin：</strong></p>
<p>服不？</p>
<p><strong>Swift：</strong></p>
<p>不服，说说函数参数吧。</p>
<p><strong>Kotlin：</strong></p>
<p>Kotlin 中函数的参数使用帕斯卡尔（Pascal）符号定义，例如 <code>name: type</code>，使用逗号分割不同的参数，必须明确定义参数的类型。</p>
<p><strong>Swift：</strong></p>
<p>Swift 的参数也差不多，有外部名和内部名之分，外部名就是实参名，内部名就是形参名。</p>
<p><strong>Kotlin：</strong></p>
<p>那是咋定义的？</p>
<p><strong>Swift：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func f(valueA x: Int, valueB y: Int) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里 valueA 和 valueB 就是外部参数名，x 和 y 是内部参数名<br>函数在调用时要写上外部参数名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(valueA: 1, valueB: 2)</div></pre></td></tr></table></figure>
<p><strong>Kotlin：</strong></p>
<p>如果不想写参数名呢？</p>
<p><strong>Swift：</strong></p>
<p>那在定义的时候用 _ 指代外部名就行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">f(_ x: Int, _ y: Int) &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">f(1, 2) // 函数调用</div></pre></td></tr></table></figure>
<p><strong>Kotlin：</strong> </p>
<p>666666666666</p>
<p><strong>Swift：</strong></p>
<p>你们的参数可以加默认值吗？</p>
<p><strong>Kotlin：</strong></p>
<p>可以呀，后面 <code>=</code> 一个值就行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun read(off: Int = 0) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Swift：</strong></p>
<p>我们也是一模一样的。</p>
<p><strong>Kotlin：</strong></p>
<p>赞</p>
<p><strong>Swift：</strong></p>
<p>再说说可变参数吧，我们可变参数的定义是在参数类型后面加三个点<code>...</code>，然后这个参数就可以当做数组使用了</p>
<p><strong>Kotlin：</strong></p>
<p>我们是用 <code>vararg</code> 关键字</p>
<p><strong>Swift：</strong></p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func arithmeticMean(_ numbers: Double...) -&gt; Double &#123;</div><div class="line">    var total: Double = 0</div><div class="line">    for number in numbers &#123;</div><div class="line">        total += number</div><div class="line">    &#125;</div><div class="line">    return total / Double(numbers.count)</div><div class="line">&#125;</div><div class="line">arithmeticMean(1, 2, 3, 4, 5)</div><div class="line">// 结果是 3.0</div><div class="line"></div><div class="line">arithmeticMean(3, 8.25, 18.75)</div><div class="line">// 结果是 10.0</div></pre></td></tr></table></figure>
<p><strong>Kotlin：</strong></p>
<p>我们是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun &lt;T&gt; asList(vararg ts: T): List&lt;T&gt; &#123;</div><div class="line">    val result = ArrayList&lt;T&gt;()</div><div class="line">    for (t in ts) // ts is an Array</div><div class="line">        result.add(t)</div><div class="line">    return result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Swift：</strong></p>
<p>就是关键字不一样，其它还是非常相似的。</p>
<p><strong>Kotlin：</strong></p>
<p>恩，惺惺相惜。</p>
<h1 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h1><h2 id="Swift-中函数的定义"><a href="#Swift-中函数的定义" class="headerlink" title="Swift 中函数的定义"></a>Swift 中函数的定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func &lt;function name&gt;(&lt;parameters&gt;) -&gt; &lt;return type&gt; &#123;</div><div class="line">    &lt;statements&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果函数没有返回值，则定义方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func &lt;function name&gt;(&lt;parameters&gt;) &#123;</div><div class="line">    &lt;statements&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func f(x: Int, y: Int) -&gt; Int &#123;    </div><div class="line">	return x + y  </div><div class="line">&#125;</div><div class="line"></div><div class="line">f(x: 1, y: 2) // 函数调用</div></pre></td></tr></table></figure>
<h2 id="Swift-中函数的参数"><a href="#Swift-中函数的参数" class="headerlink" title="Swift 中函数的参数"></a>Swift 中函数的参数</h2><p>函数参数声明方式和声明变量相同，不过函数参数有外部名（实参名）和内部名（形参名）之分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func f(valueA x: Int, valueB y: Int) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里 valueA 和 valueB 就是外部参数名，x 和 y 是内部参数名<br>函数在调用是必须写上外部参数名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(valueA: 1, valueB: 2)</div></pre></td></tr></table></figure>
<p>如果想要函数在调用时省略外部参数名，则可以在函数声明时把外部参数名指定为 _（下划线）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">f(_ x: Int, _ y: Int) &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">f(1, 2) // 函数调用</div></pre></td></tr></table></figure>
<p>如果不区分外部和内部参数名，则外部和内部参数名相同，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func f(x: Int, y: Int) -&gt; Int &#123;    </div><div class="line">	return x + y  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个函数的外部参数名和内部参数名都是 x 和 y</p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>函数参数类型后面加三个点”…”，则可把这个参数声明成可变参数<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func arithmeticMean(_ numbers: Double...) -&gt; Double &#123;</div><div class="line">    var total: Double = 0</div><div class="line">    for number in numbers &#123;</div><div class="line">        total += number</div><div class="line">    &#125;</div><div class="line">    return total / Double(numbers.count)</div><div class="line">&#125;</div><div class="line">arithmeticMean(1, 2, 3, 4, 5)</div><div class="line">// returns 3.0</div><div class="line"></div><div class="line">arithmeticMean(3, 8.25, 18.75)</div><div class="line">// returns 10.0</div></pre></td></tr></table></figure>
<h2 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h2><p>函数的参数可以指定默认值，这样这个函数在调用是可以省略这个参数<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func f(x: Int, y: Int = 3) -&gt; Int &#123;    </div><div class="line">	return x + y  </div><div class="line">&#125;</div><div class="line"></div><div class="line">f(x: 1)</div><div class="line">// 结果为 4</div></pre></td></tr></table></figure>
<h2 id="Kotlin-函数定义"><a href="#Kotlin-函数定义" class="headerlink" title="Kotlin 函数定义"></a>Kotlin 函数定义</h2><p>Kotlin 用 <code>fun</code> 关键字来声明函数，常见的是用块（block）来声明函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun &lt;functionName&gt;(&lt;parameters&gt;)[: &lt;Type&gt;] &#123;</div><div class="line">    &lt;block&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还可以用「单一表达式」直接声明函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun &lt;functionName&gt;(&lt;parameters&gt;)[: &lt;Type&gt;] = &lt;singleExpression&gt;</div></pre></td></tr></table></figure>
<p>在用「块」来声明函数的时候，返回的类型只有在没有返回（Kotlin 默认返回 Unit）的时候可以不定义。在使用「单一表达式」来声明函数的时候返回的类型可以被推断出来，所以可以忽略不写。</p>
<h2 id="Kotlin-中函数的参数"><a href="#Kotlin-中函数的参数" class="headerlink" title="Kotlin 中函数的参数"></a>Kotlin 中函数的参数</h2><p>Kotlin 中函数的参数使用帕斯卡尔（Pascal）符号定义，例如 <code>name: type</code>，使用逗号分割不同的参数，必须明确定义参数的类型。</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>Kotlin 的函数中允许直接为参数提供默认值，在调用的时候如果使用默认值可以忽略这个参数不传递。默认参数的定义方式是在类型定义后面用 <code>=</code> 传递默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun read(b: Array&lt;Byte&gt;, off: Int = 0, len: Int = b.size()) &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="可变参数-1"><a href="#可变参数-1" class="headerlink" title="可变参数"></a>可变参数</h3><p>对于参数数量可变的情况，在 Kotlin 中可以用 <code>vararg</code> 关键字来标记，和 Java 里面  <code>...</code> 是一个用途。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun &lt;T&gt; asList(vararg ts: T): List&lt;T&gt; &#123;</div><div class="line">    val result = ArrayList&lt;T&gt;()</div><div class="line">    for (t in ts) // ts is an Array</div><div class="line">        result.add(t)</div><div class="line">    return result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val list = asList(1, 2, 3)</div></pre></td></tr></table></figure>
<p>关于函数相关的知识，无论是 Swift 还是 Kotlin 都还有很多东西可以 PK，不过这篇这是基础语法篇，想要了解更多的和函数相关的 PK，敬请期待后面的更新。</p>
<hr>
<p><img src="http://7xpox6.com1.z0.glb.clouddn.com/kotlin-three-wechat.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tags: Kotlin, Swift&lt;/p&gt;
&lt;p&gt;Kotlin 君和 Swift 君在一个团队一起开发已经很久了，由于平台的差异性，他们经常会进行一些技术上的交流（PK），「Kotlin vs. Swift」课程就是他们在互相切磋是的语录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>参与《Swift vs. Kotlin 漫谈》系列</title>
    <link href="http://yoursite.com/2017/05/22/swiftvs.kotlin_project/"/>
    <id>http://yoursite.com/2017/05/22/swiftvs.kotlin_project/</id>
    <published>2017-05-22T04:53:10.000Z</published>
    <updated>2017-05-22T04:55:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>无论你是 Kotlin 开发者，</p>
<p>还是 Swift 开发者，</p>
<p>或者你两者都会，</p>
<p>你对参与 《Swift vs. Kotlin 漫谈》系列感兴趣的话，可以联系我。</p>
<a id="more"></a>
<p>我们这里列出了 《Swift vs. Kotlin 漫谈》系列的大纲，如果你对里面某一块感兴趣，就可以参与进来。</p>
<p>当然如果你对大纲调整有意见，也可以给我们提建议。</p>
<h2 id="参与方式"><a href="#参与方式" class="headerlink" title="参与方式"></a>参与方式</h2><ul>
<li>扫描或长按下面的二维码联系我，我会把你拉到我们的群里</li>
<li>在目录中尚未编辑的章节中选择自己感兴趣，然后参考之前的文章总结出相应的知识点</li>
<li>在群里找到另一门语言对此感兴趣的哥们（如果没有的话，就是刘铎或哦好么人）</li>
<li>然后你们一起完成这个章节</li>
</ul>
<p><img src="http://7xpox6.com1.z0.glb.clouddn.com/WechatIMG616.jpeg?imageview2/2/w/720" alt=""></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="属性定义（已完成）"><a href="#属性定义（已完成）" class="headerlink" title="属性定义（已完成）"></a>属性定义（已完成）</h3><h3 id="函数定义（已完成）"><a href="#函数定义（已完成）" class="headerlink" title="函数定义（已完成）"></a>函数定义（已完成）</h3><h3 id="基本类型和操作（编辑中…）"><a href="#基本类型和操作（编辑中…）" class="headerlink" title="基本类型和操作（编辑中…）"></a>基本类型和操作（编辑中…）</h3><h3 id="控制流（编辑中…）"><a href="#控制流（编辑中…）" class="headerlink" title="控制流（编辑中…）"></a>控制流（编辑中…）</h3><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="类与继承（包含内部类）"><a href="#类与继承（包含内部类）" class="headerlink" title="类与继承（包含内部类）"></a>类与继承（包含内部类）</h3><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><h3 id="类的扩展"><a href="#类的扩展" class="headerlink" title="类的扩展"></a>类的扩展</h3><h3 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h3><h3 id="枚举（包含密封类）"><a href="#枚举（包含密封类）" class="headerlink" title="枚举（包含密封类）"></a>枚举（包含密封类）</h3><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><h2 id="函数与表达式"><a href="#函数与表达式" class="headerlink" title="函数与表达式"></a>函数与表达式</h2><h3 id="函数与表达式（包含内联函数）"><a href="#函数与表达式（包含内联函数）" class="headerlink" title="函数与表达式（包含内联函数）"></a>函数与表达式（包含内联函数）</h3><h3 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h3><h3 id="协同程序"><a href="#协同程序" class="headerlink" title="协同程序"></a>协同程序</h3><h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><h3 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h3><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><h3 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h3><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><h2 id="标准库（1，2，3…）"><a href="#标准库（1，2，3…）" class="headerlink" title="标准库（1，2，3…）"></a>标准库（1，2，3…）</h2><h2 id="开源框架（1，2，3-）"><a href="#开源框架（1，2，3-）" class="headerlink" title="开源框架（1，2，3..）"></a>开源框架（1，2，3..）</h2><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><h3 id="语言设计"><a href="#语言设计" class="headerlink" title="语言设计"></a>语言设计</h3><hr>
<p><img src="http://7xpox6.com1.z0.glb.clouddn.com/kotlin-three-wechat.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论你是 Kotlin 开发者，&lt;/p&gt;
&lt;p&gt;还是 Swift 开发者，&lt;/p&gt;
&lt;p&gt;或者你两者都会，&lt;/p&gt;
&lt;p&gt;你对参与 《Swift vs. Kotlin 漫谈》系列感兴趣的话，可以联系我。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift vs. Kotlin 之变量定义</title>
    <link href="http://yoursite.com/2017/05/18/swiftvskotlin_variables/"/>
    <id>http://yoursite.com/2017/05/18/swiftvskotlin_variables/</id>
    <published>2017-05-18T04:59:58.000Z</published>
    <updated>2017-05-19T16:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>tags: Kotlin, Swift</p>
<p>Kotlin 君和 Swift 君在一个团队一起开发已经很久了，由于平台的差异性，他们经常会进行一些技术上的交流（PK），「Kotlin vs. Swift」课程就是他们在互相切磋是的语录。</p>
<a id="more"></a>
<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><h4 id="Kotlin："><a href="#Kotlin：" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>你看下我们 Kotlin 定义变量太酷了，比我们之前用 Java 方便太多了，你们 Swift 声明变量方便吗？</p>
<h4 id="Swift："><a href="#Swift：" class="headerlink" title="Swift："></a>Swift：</h4><p>哦，你们是怎么样的？</p>
<h4 id="Kotlin：-1"><a href="#Kotlin：-1" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>我们可以直接这样定义一个变量 <code>val b = 2</code>，Kotlin 可以自行推断变量的类型，要是 Java 就不行了，必须要给每个变量定义类型。</p>
<h4 id="Swift：-1"><a href="#Swift：-1" class="headerlink" title="Swift："></a>Swift：</h4><p>我们这里也有类型推断的功能，我们声明一个变量直接 <code>let count = 10</code> 就可以了，和你们差不多。</p>
<h4 id="Kotlin：-2"><a href="#Kotlin：-2" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>咦，你们用 <code>let</code> 声明变量，和我们不太一样。</p>
<h4 id="Swift：-2"><a href="#Swift：-2" class="headerlink" title="Swift："></a>Swift：</h4><p>是的，我们用 <code>let</code> 声明常量，用 <code>var</code> 声明变量，而且我们常量还分为储值变量和计算变量。</p>
<h4 id="Kotlin：-3"><a href="#Kotlin：-3" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>储值变量和计算变量？是个什么概念，我们这里没有。</p>
<h4 id="Swift：-3"><a href="#Swift：-3" class="headerlink" title="Swift："></a>Swift：</h4><p>像 <code>var count = 10</code> 这样的定义就是储值变量。像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var &lt;variable name&gt;: &lt;type&gt; &#123;</div><div class="line">    get &#123;</div><div class="line">        &lt;statements&gt;</div><div class="line">    &#125;</div><div class="line">    set(&lt;setter name&gt;) &#123;</div><div class="line">        &lt;statements&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样定义为变量自定义了 getter 和 setter 方法，这样每次获取变量值得时候都要经过一些的计算才能得到变量的值，所以叫计算变量。</p>
<h4 id="Kotlin：-4"><a href="#Kotlin：-4" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>这个和我们定义 getter 和 setter 方法一样吗。我们完整的变量定义是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</div><div class="line">    [&lt;getter&gt;]</div><div class="line">    [&lt;setter&gt;]</div></pre></td></tr></table></figure>
<p>其中 initializer、getter 和 setter 是可以省略的，但是我们没有计算变量这个概念。</p>
<h4 id="Swift：-4"><a href="#Swift：-4" class="headerlink" title="Swift："></a>Swift：</h4><p>恩，我们定义变量的语法是差不多的，除了 <code>let</code> 和 <code>val</code> 的差别。</p>
<h4 id="Kotlin：-5"><a href="#Kotlin：-5" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>哎，你们的计算变量能不能给自己赋值啊？如果可以赋值的话，和储值变量有什么差别呢？</p>
<p>我们 getter 和 setter 方法里面有个「支持域」的概念，可以通过「支持域」直接给变量赋值，所以重写 getter 和 setter 方法也只是实现不一样，本身没有质的差别。</p>
<h4 id="Swift：-5"><a href="#Swift：-5" class="headerlink" title="Swift："></a>Swift：</h4><p>我们不行，在 getter 和 setter 只能通过另外一个储值变量来保存计算的结果。</p>
<h4 id="Kotlin：-6"><a href="#Kotlin：-6" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>这点还是有差异的，因为你们 getter 和 setter 不能给当前变量赋值，只能进行计算的工作，所以你们才有计算变量的概念。</p>
<h4 id="Swift：-6"><a href="#Swift：-6" class="headerlink" title="Swift："></a>Swift：</h4><p>应该是这样的。</p>
<h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h2><h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>Kotlin 定义变量的完整语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</div><div class="line">    [&lt;getter&gt;]</div><div class="line">    [&lt;setter&gt;]</div></pre></td></tr></table></figure>
<p>其中 initializer、getter 和 setter 是并不是必须的。在属性类型可以通过 initializer 推断的情况下，属性类型也可以不声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val a: Int = 1  // 直接声明</div><div class="line">val b = 2   // `Int` 类型是推断出来的</div><div class="line">val c: Int  // 在没有初始化赋值的化，需要定义类型</div></pre></td></tr></table></figure>
<p>Kotlin 制定定义只读变量(read-only variable，又叫常量)和变量(mutable variable)，分别用 <code>val</code> 和 <code>var</code> 关键字修饰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val a: Int = 1 // 不可再次赋值</div><div class="line">var b: Int = 1 // 可再次赋值</div></pre></td></tr></table></figure>
<h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><p>Swift 声明常量，用 let 关键字，常量的值在初始化后不能被再次修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let &lt;constant name&gt;[: &lt;type&gt;] = &lt;expression&gt;</div></pre></td></tr></table></figure>
<p>Swift 声明储值变量，用 var 关键字，变量的值可以被任意修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var &lt;variable name&gt;[: &lt;type&gt;] = &lt;expression&gt;</div></pre></td></tr></table></figure>
<p>Swift 声明计算变量，用 var 关键字，同时需要指定 set 和 get 的方式，仅指定 get 则为只读计算变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var &lt;variable name&gt;: &lt;type&gt; &#123;</div><div class="line">    get &#123;</div><div class="line">        &lt;statements&gt;</div><div class="line">    &#125;</div><div class="line">    set(&lt;setter name&gt;) &#123;</div><div class="line">        &lt;statements&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Swift 支持类型推断，在有初始值的情况下，可以省去类型声明，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let count: Int = 10 // 常量</div><div class="line">var message: String = &quot;Hello&quot; // 变量</div></pre></td></tr></table></figure>
<p>可以简写为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let count = 10 // Int 类型</div><div class="line">var message = &quot;Hello&quot; // String 类型</div></pre></td></tr></table></figure>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tags: Kotlin, Swift&lt;/p&gt;
&lt;p&gt;Kotlin 君和 Swift 君在一个团队一起开发已经很久了，由于平台的差异性，他们经常会进行一些技术上的交流（PK），「Kotlin vs. Swift」课程就是他们在互相切磋是的语录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Primer·第五章·函数与闭包</title>
    <link href="http://yoursite.com/2017/04/09/2017-04-09-01/"/>
    <id>http://yoursite.com/2017/04/09/2017-04-09-01/</id>
    <published>2017-04-09T05:48:44.000Z</published>
    <updated>2017-05-19T15:56:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>题外话：全书的目录以及主要内容已经公开，可在我公众号【<a href="http://mp.weixin.qq.com/s/3W6ciZYM1o_J5VqIFyNIpQ" target="_blank" rel="external">技术实验室</a>】的历史推送文章查看</p>
<p>第一部分——快速上手<br><a href="http://shanghai.kotliner.cn/2017/02/03/2017-02-03-01/" target="_blank" rel="external">第一章·启程</a><br><a href="http://shanghai.kotliner.cn/2017/02/04/2017-02-04-01/" target="_blank" rel="external">第二章·基本语法</a><br><a href="http://shanghai.kotliner.cn/2017/02/07/2017-02-07-01/" target="_blank" rel="external">第三章·Kotlin 与 Java 混编</a><br>第二部分——开始学习 Kotlin<br><a href="http://shanghai.kotliner.cn/2017/02/12/2017-02-12-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(上)</a><br><a href="http://shanghai.kotliner.cn/2017/02/26/2017-02-26-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(下)</a><br><a href="http://shanghai.kotliner.cn/2017/04/09/2017-04-09-01/" target="_blank" rel="external">第五章·函数与闭包</a> </p>
</blockquote>
<p>函数与闭包的特性可以算是 Kotlin 语言最大的特性了。  </p>
<h3 id="5-1-函数"><a href="#5-1-函数" class="headerlink" title="5.1 函数"></a>5.1 函数</h3><p>即使 Kotlin 是一门面向对象的编程语言，它也是有函数的概念的——而不像 Java 那样，仅仅有“方法”。<br>回顾一下前面第二章讲述的函数声明语法：</p>
<a id="more"></a>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">say</span><span class="params">(str: <span class="type">String</span>)</span></span>: String &#123;</div><div class="line">	<span class="keyword">return</span> str</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数使用关键字 <code>fun</code> 声明，如下代码创建了一个名为 say() 的函数，它接受一个 String 类型的参数，并返回一个 String 类型的值。</p>
<h4 id="5-1-1-Unit"><a href="#5-1-1-Unit" class="headerlink" title="5.1.1 Unit"></a>5.1.1 Unit</h4><p>如果一个函数是空函数，比如 Android 开发中的 TextWatch 接口，通常只会用到一个方法，但必须把所有方法都重写一遍，就可以通过这种方式来简写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">editText.addTextChangedListener(<span class="keyword">object</span> : TextWatcher &#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterTextChanged</span><span class="params">(s: <span class="type">Editable</span>?)</span></span> = <span class="built_in">Unit</span></div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeTextChanged</span><span class="params">(s: <span class="type">CharSequence</span>?, start: <span class="type">Int</span>, count: <span class="type">Int</span>, after: <span class="type">Int</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTextChanged</span><span class="params">(s: <span class="type">CharSequence</span>?, start: <span class="type">Int</span>, before: <span class="type">Int</span>, count: <span class="type">Int</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Unit 表示的是一个值的类型。 这种类型对应于Java中的 <code>void</code> 类型。</p>
<h4 id="5-1-2-Nothing"><a href="#5-1-2-Nothing" class="headerlink" title="5.1.2 Nothing"></a>5.1.2 Nothing</h4><p>如果一个函数不会返回（也就是说只要调用这个函数，那么在它返回之前程序肯定出错了，比如一定会抛出异常的函数），理论上你可以随便给他一个返回值，通常我们会声明为返回 Nothing 类型。我们看到 Nothing 的注释：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Nothing has no instances. You can use Nothing to represent "a value that never exists": for example,</div><div class="line"> * if a function has the return type of Nothing, it means that it never returns (always throws an exception).</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Nothing</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>()</div></pre></td></tr></table></figure>
<p>没有任何实例。 您可以使用 Nothing 来表示“永远不存在的值”.</p>
<h3 id="5-2-复杂的特性"><a href="#5-2-复杂的特性" class="headerlink" title="5.2 复杂的特性"></a>5.2 复杂的特性</h3><h4 id="5-2-1-嵌套函数"><a href="#5-2-1-嵌套函数" class="headerlink" title="5.2.1 嵌套函数"></a>5.2.1 嵌套函数</h4><p>Kotlin 的函数有一些非常有意思的特性，比如函数中再声明函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">function</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> valuesInTheOuterScope = <span class="string">"Kotlin is awesome!"</span></div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">theFunctionInside</span><span class="params">(int: <span class="type">Int</span> = <span class="number">10</span>)</span></span> &#123;</div><div class="line">    println(valuesInTheOuterScope)</div><div class="line">    <span class="keyword">if</span> (int &gt;= <span class="number">5</span>) theFunctionInside(int - <span class="number">1</span>)</div><div class="line">  &#125;</div><div class="line">  theFunctionInside()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与内部类有些类似，内部函数可以直接访问外部函数的局部变量、常量，这种写法通常使用在 <code>会在某些条件下触发递归的方法内</code>，在一般情况下是不推荐使用嵌套函数的。 </p>
<h4 id="5-2-2-运算符重载"><a href="#5-2-2-运算符重载" class="headerlink" title="5.2.2 运算符重载"></a>5.2.2 运算符重载</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span> step <span class="number">20</span>) &#123;</div><div class="line">    print(<span class="string">"<span class="subst">$i</span> "</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段函数将会输出 <code>1 21 41 61 81</code> </p>
<p>这段神奇的循环是怎么执行的？  </p>
<p>in关键字，在编译以后，会被翻译为一个迭代器方法，其源码可以在 <code>Progressions</code> 类中查看到</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: IntIterator = IntProgressionIterator(first, last, step)</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * An iterator over a progression of values of type `Int`.</div><div class="line"> */</div><div class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">IntProgressionIterator</span></span>(first: <span class="built_in">Int</span>, last: <span class="built_in">Int</span>, <span class="keyword">val</span> step: <span class="built_in">Int</span>) : IntIterator() &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> next = first</div><div class="line">    <span class="keyword">private</span> <span class="keyword">val</span> finalElement = last</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> hasNext: <span class="built_in">Boolean</span> = <span class="keyword">if</span> (step &gt; <span class="number">0</span>) first &lt;= last <span class="keyword">else</span> first &gt;= last</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = hasNext</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">nextInt</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</div><div class="line">        <span class="keyword">val</span> value = next</div><div class="line">        <span class="keyword">if</span> (value == finalElement) &#123;</div><div class="line">            hasNext = <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            next += step</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> value</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>in 关键字之后，还有两个点的 <code>..</code> ，他表示一个封闭区间，其内部实现原理是通过运算符重载来完成的。首先看到他的函数定义，你可以在  <code>Int</code> 类的源码中找到：  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/** Creates a range from this value to the specified [other] value. */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">rangeTo</span><span class="params">(other: <span class="type">Int</span>)</span></span>: IntRange</div></pre></td></tr></table></figure>
<p>运算符重载需要使用关键字<code>operator</code>修饰，其余定义与函数相同。<br>通过源码看到，上面的代码实际<code>..</code>的原理实际上就是对一个 Int 值，调用他的 <code>rangeTo</code>方法，传入一个 Int 参数，并返回一个区间对象。<br>带入到上面的代码，实际上就是把<code>..</code>看做是方法名，调用 1 的<code>rangeTo</code>方法，传入 100 作为参数，会返回一个区间对象。 然后再用迭代器 <code>in</code> 便利区间中的每一个值。<br>所以上面那种写法改写为下面这样，依旧是能正常运行的。  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>rangeTo(<span class="number">100</span>) step <span class="number">20</span>) &#123;</div><div class="line">    print(<span class="string">"<span class="subst">$i</span> "</span>)</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">&gt; 说道运算符给大家讲个笑话，在 C/C++/Java 中，其实有一个大家经常使用但是没有人知道的运算符，叫`趋近于`写法为 `--&gt;`，例如下面的代码：  </div><div class="line">&gt; int i = <span class="number">10</span>;  </div><div class="line">&gt; <span class="keyword">while</span>(i --&gt; <span class="number">0</span>)&#123;  </div><div class="line">&gt;     printf(<span class="string">"%d"</span>, i);  </div><div class="line">&gt; &#125;   </div><div class="line">&gt; 这个代码运行完后将会依次打印 <span class="number">10</span> 到 <span class="number">0</span> 数字。不信你试试</div><div class="line"></div><div class="line"></div><div class="line">#### <span class="number">5.2</span><span class="number">.3</span> 中缀表达式</div><div class="line"></div><div class="line">运算符的数量毕竟是有限的，有时并不一定有合适的。例如上面代码中的步长这个意义，就没有合适的运算符可以标识。  </div><div class="line">这时候我们可以用一个单词或字母来当运算符用(其本质还是函数调用)，叫做中缀表达式，**所谓中缀表达式就是不需要点和括号的方法调用**。  </div><div class="line">你可以在 Reangs 中看到`step`源码声明：  </div><div class="line"></div><div class="line">```kotlin</div><div class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> IntProgression.<span class="title">step</span><span class="params">(step: <span class="type">Int</span>)</span></span>: IntProgression &#123;</div><div class="line">    checkStepIsPositive(step &gt; <span class="number">0</span>, step)</div><div class="line">    <span class="keyword">return</span> IntProgression.fromClosedRange(first, last, <span class="keyword">if</span> (<span class="keyword">this</span>.step &gt; <span class="number">0</span>) step <span class="keyword">else</span> -step)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>中缀表达式需要用<code>infix</code>修饰，从源码看到，在 SDK 中定义了一个叫 step 的方法，最终返回一个<code>IntProgression</code>对象，这个对象最终会被作用到 in，也就是迭代器的第三个参数step上。  </p>
<h3 id="5-2-闭包"><a href="#5-2-闭包" class="headerlink" title="5.2 闭包"></a>5.2 闭包</h3><p>其实在 Kotlin 中与其说一等公民是函数，不如说一等公民是闭包。  </p>
<p>例如在 Kotlin 中，你可以写出这种怪异的代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    test</div><div class="line">&#125;</div><div class="line"><span class="keyword">val</span> test = <span class="keyword">if</span> (<span class="number">5</span> &gt; <span class="number">3</span>) &#123;</div><div class="line">    print(<span class="string">"yes"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    print(<span class="string">"no"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，我们都知道这段代码永远都只会输出yes。<br>这里只是为了演示，if 语句仍旧是一个闭包。而事实上，上文包括前文讲到的所有：函数、Lambda、if语句、for、when，都可以称之为闭包，但通常情况下，我们所说的闭包是 Lambda 表达式。  </p>
<h4 id="5-2-1-自执行闭包"><a href="#5-2-1-自执行闭包" class="headerlink" title="5.2.1 自执行闭包"></a>5.2.1 自执行闭包</h4><p>自执行闭包就是在定义闭包的同时直接执行闭包，一般用于初始化上下文环境。<br>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt;</div><div class="line">    println(<span class="string">"<span class="subst">$&#123;x + y&#125;</span>"</span>)</div><div class="line">&#125;(<span class="number">1</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure>
<h3 id="5-3-Lambda"><a href="#5-3-Lambda" class="headerlink" title="5.3 Lambda"></a>5.3 Lambda</h3><h4 id="5-3-1-Lambda-表达式"><a href="#5-3-1-Lambda-表达式" class="headerlink" title="5.3.1 Lambda 表达式"></a>5.3.1 Lambda 表达式</h4><p>Lambda 表达式俗称匿名函数，熟悉Java的大家应该也明白这是个什么概念。Kotlin 的 Lambda表达式更“纯粹”一点， 因为它是真正把Lambda抽象为了一种类型，而 Java 8 的 Lambda 只是单方法匿名接口实现的语法糖罢了。  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> printMsg = &#123; msg: String -&gt; </div><div class="line">	println(msg) </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  printMsg.invoke(<span class="string">"hello"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是 Lambda 表达式最简单的实例。<br>首先声明了一个名为<code>printMsg</code>的 Lambda，它接受一个 String 类型的值作为参数，然后在 main 函数中调用它。如果还想省略，你还可以在调用时直接省略invoke，像函数一样使用。  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  printMsg(<span class="string">"hello"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Lambda 表达式还有非常多的语法糖，比如  </p>
<ul>
<li>当参数只有一个的时候，声明中可以不用显示声明参数，在使用参数时可以用 it 来替代那个唯一的参数。  </li>
<li>当有多个用不到的参数时，可以用下划线来替代参数名(1.1以后的特性)，但是如果已经用下划线来省略参数时，是不能使用 it 来替代当前参数的。  </li>
<li>Lambda 最后一条语句的执行结果表示这个 Lambda 的返回值。</li>
</ul>
<p>需要注意的是：闭包是不能有变长参数的<br>例如前面讲过变长参数的函数，但是闭包的参数数量是必须固定的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printLog</span><span class="params">(<span class="keyword">vararg</span> str: <span class="type">String</span>)</span></span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-3-2-高阶函数"><a href="#5-3-2-高阶函数" class="headerlink" title="5.3.2 高阶函数"></a>5.3.2 高阶函数</h4><p>Lambda 表达式最大的特点是可以作为参数传递。当定义一个闭包作为参数的函数，称这个函数为高阶函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    log(<span class="string">"world"</span>, printMsg)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> printMsg = &#123; str: String -&gt;</div><div class="line">    println(str)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> log = &#123; str: String, printLog: (String) -&gt; <span class="built_in">Unit</span> -&gt;</div><div class="line">    printLog(str)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子中，log 是一个接受一个 String 和一个以 String 为参数并返回 Unit 的 Lambda 表达式为参数的 Lambda 表达式。<br>读起来有点绕口，其实就是 log 有两个参数，一个str:String，一个printLog: (String) -&gt; Unit。</p>
<h4 id="5-3-3-内联函数"><a href="#5-3-3-内联函数" class="headerlink" title="5.3.3 内联函数"></a>5.3.3 内联函数</h4><p>在使用高阶函数时，一定要知道内联函数这个东西。它可以大幅提升高阶函数的性能。<br>官方文档的描述是这样的：使用 高阶函数 在运行时会带来一些不利: 每个函数都是一个对象, 而且它还要捕获一个闭包, 也就是, 在函<br>数体内部访问的那些外层变量. 内存占用(函数对象和类都会占用内存) 以及虚方法调用都会带来运行时的消耗.</p>
<p>但是也不是说所有的函数都要内联，因为一旦添加了<code>inline</code>修饰，在编译阶段，编译器将会把函数拆分，插入到调用出。如果一个 inline 函数是很大的，那他会大幅增加调用它的那个函数的体积。  </p>
<h3 id="5-4-小结"><a href="#5-4-小结" class="headerlink" title="5.4 小结"></a>5.4 小结</h3><p>闭包应该算是 Kotlin 最核心特性之一了。<br>使用好闭包可以让代码量大大减少，例如 Kotlin 最著名的开源库：<code>Anko</code>，使用 Anko 去动态代码布局，比使用 Java 代码配合 xml 要更加简洁。   </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?, persistentState: <span class="type">PersistableBundle</span>?)</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState, persistentState)</div><div class="line">        MyActivityUI().setContentView(<span class="keyword">this</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivityUI</span> : <span class="type">AnkoComponent</span>&lt;<span class="type">MyActivity</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createView</span><span class="params">(ui: <span class="type">AnkoContext</span>&lt;<span class="type">MyActivity</span>&gt;)</span></span> = ui.apply &#123;</div><div class="line">        verticalLayout &#123;</div><div class="line">            editText()</div><div class="line">            button(<span class="string">"Say Hello"</span>) &#123;</div><div class="line">                onClick &#123; ctx.toast(<span class="string">"Hello!"</span>) &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;.view</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，充分运用了闭包的灵活性，省略了很多的临时变量和参数声明。<br>然而，也正是因为闭包的灵活性，造成如果泛滥的话，可能会写出可读性非常差的代码(这里就不举反例了， js 的 lambda 滥用的结果就能想象了)</p>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
]]></content>
    
    <summary type="html">
    
      久违了，Kotlin 的闭包。函数与闭包的特性可以算是 Kotlin 语言最大的特性了，所以写了很久。    
    
    </summary>
    
      <category term="code" scheme="http://yoursite.com/categories/code/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Primer·第四章·Kotlin 的类特性(下)</title>
    <link href="http://yoursite.com/2017/02/26/2017-02-26-01/"/>
    <id>http://yoursite.com/2017/02/26/2017-02-26-01/</id>
    <published>2017-02-26T03:48:44.000Z</published>
    <updated>2017-05-19T15:56:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>题外话：全书的目录以及主要内容已经公开，可在我公众号【<a href="http://mp.weixin.qq.com/s/3W6ciZYM1o_J5VqIFyNIpQ" target="_blank" rel="external">技术实验室</a>】的历史推送文章查看</p>
<p>第一部分——快速上手<br><a href="http://shanghai.kotliner.cn/2017/02/03/2017-02-03-01/" target="_blank" rel="external">第一章·启程</a><br><a href="http://shanghai.kotliner.cn/2017/02/04/2017-02-04-01/" target="_blank" rel="external">第二章·基本语法</a><br><a href="http://shanghai.kotliner.cn/2017/02/07/2017-02-07-01/" target="_blank" rel="external">第三章·Kotlin 与 Java 混编</a><br>第二部分——开始学习 Kotlin<br><a href="http://shanghai.kotliner.cn/2017/02/12/2017-02-12-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(上)</a><br><a href="http://shanghai.kotliner.cn/2017/02/26/2017-02-26-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(下)</a><br><a href="http://shanghai.kotliner.cn/2017/04/09/2017-04-09-01/" target="_blank" rel="external">第五章·函数与闭包</a>   </p>
</blockquote>
<p>前面三章的内容是写给希望快速了解 Kotlin 语言的大忙人的。<br>而从本章开始，才会真正讲述 Kotlin 语言的神奇之处。   </p>
<h3 id="4-5-类的扩展"><a href="#4-5-类的扩展" class="headerlink" title="4.5 类的扩展"></a>4.5 类的扩展</h3><a id="more"></a> 
<p>在 Java 开发的时候，经常会写一大堆的 Utils 类，甚至经常写一些common包，比如著名的 <code>apache-commons</code> 系列、<code>Guava</code>等等。<br>如果每个类在想要用这些工具类的时候，他们自己就已经具备了这些工具方法多好，<code>Kotlin</code> 的类扩展方法就是这个作用。 </p>
<h4 id="4-5-1-扩展方法"><a href="#4-5-1-扩展方法" class="headerlink" title="4.5.1 扩展方法"></a>4.5.1 扩展方法</h4><p>在之前的文章中我就讲过扩展方法了，这里就不再多赘述，只回顾一下扩展方法的格式： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun Activity.toast(message: CharSequence, duration: Int = Toast.LENGTH_SHORT) &#123;</div><div class="line">    Toast.makeText(this, message, duration).show()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先是一个 <code>fun</code> 关键字，紧接着是要扩展哪个类的类名，点方法名，然后是方法的声明和返回值以及方法体。  </p>
<h4 id="4-5-2-小心有坑"><a href="#4-5-2-小心有坑" class="headerlink" title="4.5.2 小心有坑"></a>4.5.2 小心有坑</h4><p>需要注意的是扩展方法是静态解析的，而并不是真正给类添加了这个方法。<br>举个例子：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">open class Animal&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">class Dog : Animal()</div><div class="line"></div><div class="line">object Main &#123;</div><div class="line">    fun Animal.bark() = &quot;animal&quot;</div><div class="line"></div><div class="line">    fun Dog.bark() = &quot;dog&quot;</div><div class="line"></div><div class="line">    fun Animal.printBark(anim: Animal)&#123;</div><div class="line">        println(anim.bark())</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @JvmStatic fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">        Animal().printBark(Dog())</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终的输出是 <code>animal</code>，而不是 <code>dog</code>。<br>因为扩展方法是静态解析的，在添加扩展方法的时候类型为 <code>Animal</code>，那么即便运行时传入了子类对象，也依旧会执行参数中声明时类型的方法。    </p>
<h4 id="4-6-1-强转与智能转换"><a href="#4-6-1-强转与智能转换" class="headerlink" title="4.6.1 强转与智能转换"></a>4.6.1 强转与智能转换</h4><p>在 <code>Kotlin</code> 中，用 is 来判断一个对象是否是某个类的实例，用 as 来做强转。  </p>
<p>Kotlin 有一个很好的特性，叫 <code>智能转换(smart cast)</code>，在我之前的文章中也提到过。就是当已经确定一个对象的类型后，可以自动识别为这个类的对象，而不用再手动强转。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">	var animal: Animal? = null</div><div class="line">    if (animal is Dog) &#123;</div><div class="line">    	//在这里你必须手动强转为Dog的对象</div><div class="line">       animal.bark()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-6-2-总有例外"><a href="#4-6-2-总有例外" class="headerlink" title="4.6.2 总有例外"></a>4.6.2 总有例外</h4><p>如果智能转换的对象是一个全局变量，这个变量可能在别的地方被改变赋值，所以你必须手动判断与转换它的类型。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">open class Animal &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Dog : Animal() &#123;</div><div class="line">    fun bark() &#123;</div><div class="line">        println(&quot;animal&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var animal: Animal? = null</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    if (animal is Dog) &#123;</div><div class="line">    	//在这里你必须手动强转为Dog的对象</div><div class="line">       (animal as Dog).bark()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">### 4.7 伴生对象  </div><div class="line"></div><div class="line">在上一篇 **Kotlin 与 Java 互转** 中 我们提到这样一段工具类代码</div></pre></td></tr></table></figure>
<p>class StringUtils {<br>    companion object {<br>       fun isEmpty(str: String): Boolean {<br>            return “” == str<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">由于 `Kotlin` 没有静态方法。在大多数情况下，官方建议是简单地使用 包级 函数。如果你需要写一个可以无需用一个类的实例来调用、但需要访问类内部的函数(例如,工厂方法或单利),你可以把它写成一个用 `companion` 修饰的对象内的方法。我们称 `companion` 修饰的对象为伴生对象。    </div><div class="line"></div><div class="line">将上面的代码编译后查看，实际上是编译器生成了一个 `public` 的内部对象。</div></pre></td></tr></table></figure></p>
<p>public final class StringUtils public constructor() {<br>    public companion object {<br>        public final fun isEmpty(str: kotlin.String): kotlin.Boolean {<br>        /<em> compiled code </em>/<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 4.8 单例类设计</div><div class="line"></div><div class="line">伴生对象更多的用途是用来创建一个单例类。如果只是简单的写，直接用伴生对象返回一个 `val` 修饰的外部类对象就可以了，但是更多的时候我们希望在类被调用的时候才去初始化他的对象。以下代码将线程安全问题交给虚拟机在静态内部类加载时处理，是一种推荐的写法：</div></pre></td></tr></table></figure></p>
<p>class Single private constructor() {<br>    companion object {<br>        fun get():Single{<br>            return Holder.instance<br>        }<br>    }</p>
<pre><code>private object Holder {
    val instance = Single()
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 4.9 动态代理</div><div class="line"></div><div class="line">写多继承还是要根据场景来，正好今天跟朋友聊到他们项目重构的问题，我当时就说了一句：果然还是 `Kotlin` 好，原生支持动态代理。  </div><div class="line"></div><div class="line">朋友的一个 Android 项目，所有网络请求包括回调和参数全部封装在了一个 BaseActivity 中，然后随着项目越来越大，这一些网络请求方法想要抽出来，但又害怕牵连到线上的改动，我就推荐他用个动态代理来做，但是 Java 的动态代理又得要反射，又得要额外多写很多的代码方法，又是一个大改动。  </div><div class="line"></div><div class="line">反之看 `Kotlin` 的动态代理：</div></pre></td></tr></table></figure></p>
<p>interface Animal{<br>    fun bark()<br>}</p>
<p>class Dog :Animal {<br>    override fun bark() {<br>        println(“Wang Wang”)<br>    }<br>}</p>
<p>class Cat(animal: Animal) : Animal by animal {<br>}</p>
<p>fun main(args: Array<string>) {<br>   Cat(Dog()).bark()<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这样，我们就很成功的让一只猫的叫声用狗去代理掉了，于是上面的 `main` 方法执行完后就变成了 Wang Wang。  </div><div class="line"></div><div class="line">### 4.10 伪多继承 </div><div class="line"></div><div class="line">Kotlin 的动态代理更多的是用在一种需要多继承的场景。  </div><div class="line">例如，还是之前我举的我朋友那个项目的例子，他们的问题在于，每个 `BaseActivity` 的子类，都会要请求不同的网络，可能A需要获取用户信息，B需要获取活动列表，C既需要活动列表也需要获取用户信息，D却只需要获取图片列表。  </div><div class="line"></div><div class="line">这样一个场景，使用一个代理类实现所有需要获取信息的接口方法。然后让不同的子类去实现所需的接口，请求统一交给代理类完成。这样不仅维护网络请求信息方便，而且每个类不会有额外多出来的方法防止新人接触项目的时候调用错请求方法。  </div><div class="line"></div><div class="line">还是用猫狗来举例：</div></pre></td></tr></table></figure></string></p>
<p>interface Animal{<br>    fun bark()<br>}</p>
<p>interface Food{<br>    fun eat()<br>}</p>
<p>class Delegate : Animal, Food {<br>    override fun eat() {<br>        println(“mouse”)<br>    }</p>
<pre><code>override fun bark() {
    println(&quot;Miao&quot;)
}
</code></pre><p>}</p>
<p>class Cat(animal: Animal, food: Food) : Animal by animal, Food by food {<br>}</p>
<p>@JvmStatic fun main(args: Array<string>) {<br>    val delegate: Delegate = Delegate()<br>    Cat(delegate, delegate).bark()<br>}<br>```</string></p>
<p>Kotlin 的类就介绍这么多，下一章我们讲：<strong>闭包</strong> </p>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
]]></content>
    
    <summary type="html">
    
      Kotlin 中有很多非常好的特性，扩展方法、伴生对象、原生支持动态代理、伪多继承    
    
    </summary>
    
      <category term="code" scheme="http://yoursite.com/categories/code/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Primer·第四章·Kotlin 的类特性(上)</title>
    <link href="http://yoursite.com/2017/02/12/2017-02-12-01/"/>
    <id>http://yoursite.com/2017/02/12/2017-02-12-01/</id>
    <published>2017-02-12T05:48:44.000Z</published>
    <updated>2017-05-19T15:56:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>题外话：全书的目录以及主要内容已经公开，可在我公众号【<a href="http://mp.weixin.qq.com/s/3W6ciZYM1o_J5VqIFyNIpQ" target="_blank" rel="external">技术实验室</a>】的历史推送文章查看</p>
<p>第一部分——快速上手<br><a href="http://shanghai.kotliner.cn/2017/02/03/2017-02-03-01/" target="_blank" rel="external">第一章·启程</a><br><a href="http://shanghai.kotliner.cn/2017/02/04/2017-02-04-01/" target="_blank" rel="external">第二章·基本语法</a><br><a href="http://shanghai.kotliner.cn/2017/02/07/2017-02-07-01/" target="_blank" rel="external">第三章·Kotlin 与 Java 混编</a><br>第二部分——开始学习 Kotlin<br><a href="http://shanghai.kotliner.cn/2017/02/12/2017-02-12-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(上)</a><br><a href="http://shanghai.kotliner.cn/2017/02/26/2017-02-26-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(下)</a><br><a href="http://shanghai.kotliner.cn/2017/04/09/2017-04-09-01/" target="_blank" rel="external">第五章·函数与闭包</a>   </p>
</blockquote>
<p>前面三章的内容是写给希望快速了解 Kotlin 语言的大忙人的。<br>而从本章开始，才会真正讲述 Kotlin 语言的神奇之处。   </p>
<p>与 Java 相同，Kotlin 声明类的关键字是 <code>class</code>。类声明由类名、类头和类体构成。<br>其中 <code>类头</code> 和 <code>类体</code> 都是可选的; 如果一个类没有类体，那么花括号也是可以省略的。</p>
<h3 id="4-1-构造函数"><a href="#4-1-构造函数" class="headerlink" title="4.1 构造函数"></a>4.1 构造函数</h3><a id="more"></a>
<p>Kotlin 的构造函数可以写在类头中，跟在类名后面，如果有注解还需要加上关键字 <code>constructor</code>。这种写法声明的构造函数，我们称之为主构造函数。例如下面我们为 <code>Person</code> 创建带一个 <code>String</code> 类型参数的构造函数。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Person(private val name: String) &#123;</div><div class="line">    fun sayHello() &#123;</div><div class="line">        println(&quot;hello $name&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在构造函数中声明的参数，它们默认属于类的公有字段，可以直接使用，如果你不希望别的类访问到这个变量，可以用 <code>private</code> 修饰。<br>在主构造函数中不能有任何代码实现，如果有额外的代码需要在构造方法中执行，你需要放到 <code>init</code> 代码块中执行。同时，在本示例中由于需要更改 name 参数的值，我们将 val 改为 var,表明 name 参数是一个可改变的参数。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Person(private var name: String) &#123;</div><div class="line">	</div><div class="line">    init &#123;</div><div class="line">        name = &quot;Zhang Tao&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    internal fun sayHello() &#123;</div><div class="line">        println(&quot;hello $name&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个非抽象类没有声明任何(主或次)构造函数，它会有一个生成的不带参数的主构造函数。构造函数的可见性是 public。如果你不希望你的类 有一个公有构造函数,你需要声明一个带有非默认可见性的空的主构造函数。<br>另外，在 JVM 上,如果主构造函数的所有的参数都有默认值，编译器会生成一个额外的无参构造函数,它将使用默认值。   </p>
<h3 id="4-2-次级构造函数"><a href="#4-2-次级构造函数" class="headerlink" title="4.2 次级构造函数"></a>4.2 次级构造函数</h3><p>一个类当然会有多个构造函数的可能，只有主构造函数可以写在类头中，其他的次级构造函数(Secondary Constructors)就需要写在类体中了。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Person(private var name: String) &#123;</div><div class="line"></div><div class="line">    private var description: String? = null</div><div class="line">    </div><div class="line">    init &#123;</div><div class="line">        name = &quot;Zhang Tao&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    constructor(name: String, description: String) : this(name) &#123;</div><div class="line">        this.description = description</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    internal fun sayHello() &#123;</div><div class="line">        println(&quot;hello $name&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们让次级构造函数调用了主构造函数，完成 name 的赋值。由于次级构造函数不能直接将参数转换为字段，所以需要手动声明一个 description 字段，并为 description 字段赋值。  </p>
<h3 id="4-3-修饰符"><a href="#4-3-修饰符" class="headerlink" title="4.3 修饰符"></a>4.3 修饰符</h3><p>点开 IDEA，工程目录中的 out 列表，看到我们写完的 <code>Person</code> 被编译为 class 文件后的样子。    </p>
<p><img src="http://cdn.kymjs.com/kotlin/4-3-1.png" alt="Kotlin"></p>
<h4 id="4-3-1-open-修饰符"><a href="#4-3-1-open-修饰符" class="headerlink" title="4.3.1 open 修饰符"></a>4.3.1 open 修饰符</h4><p>Kotlin 默认会为每个变量和方法添加 final 修饰符。这么做的目的是为了程序运行的性能，其实在 Java 程序中，你也应该尽可能为每个类添加final 修饰符( 见 Effective Java 第四章 17 条)。<br>为每个类加了 <code>final</code> 也就是说，在 Kotlin 中默认每个类都是不可被继承的。如果你确定这个类是会被继承的，那么你需要给这个类添加 <code>open</code> 修饰符。  </p>
<h4 id="4-3-2-internal-修饰符"><a href="#4-3-2-internal-修饰符" class="headerlink" title="4.3.2 internal 修饰符"></a>4.3.2 internal 修饰符</h4><p>写过 Java 的同学一定知道，Java 有三种访问修饰符，public/private/protected，还有一个默认的包级别访问权限没有修饰符。<br>在 Kotlin 中，默认的访问权限是 public。而多增加了一种访问修饰符叫 <code>internal</code>。它是模块级别的访问权限。<br>何为模块(module)，我们称被一起编译的一系列 Kotlin 文件为一个模块。在 IDEA 中可以很明确的看到一个 <code>module</code> 就是一个模块，当跨 <code>module</code> 的时候就无法访问另一个 <code>module</code> 的 <code>internal</code> 变量或方法。 </p>
<h3 id="4-4-一些特殊的类"><a href="#4-4-一些特殊的类" class="headerlink" title="4.4 一些特殊的类"></a>4.4 一些特殊的类</h3><h4 id="4-4-1-枚举类"><a href="#4-4-1-枚举类" class="headerlink" title="4.4.1 枚举类"></a>4.4.1 枚举类</h4><p>在 Kotlin 中，每个枚举常量都是一个对象。枚举常量用逗号分隔。<br>例如我们写一个枚举类 Programer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">enum class Programer &#123;</div><div class="line">    JAVA, KOTLIN, C, CPP, ANDROID;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当它被编译成 class 后，将转为如下代码实际就是一个私有了构造函数的 <code>kotlin.Enum</code> 继承类。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final enum class Programer </div><div class="line">private constructor() : kotlin.Enum&lt;Programer&gt; &#123;</div><div class="line">    JAVA, KOTLIN, C, CPP, ANDROID;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着我们再来看 <code>kotlin.Enum</code> 这个类(节选)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public abstract class Enum&lt;E : Enum&lt;E&gt;&gt;</div><div class="line">(name: String, ordinal: Int): Comparable&lt;E&gt; &#123;</div><div class="line">    companion object &#123;&#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Returns the name of this enum constant,</div><div class="line">     *  exactly as declared in its enum declaration.</div><div class="line">     */</div><div class="line">    public final val name: String</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Returns the ordinal of this enumeration </div><div class="line">     * constant (its position in its enum </div><div class="line">     * declaration, where the initial constant</div><div class="line">     * is assigned an ordinal of zero).</div><div class="line">     */</div><div class="line">    public final val ordinal: Int</div><div class="line"></div><div class="line">    public override final fun compareTo(other: E): Int</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>发现，其实在 Kotlin 中，枚举的本质是一个实现了 <code>Comparable</code> 的 class，其排序就是按照字段在枚举类中定义的顺序来的。  </p>
<h4 id="4-4-2-sealed-密封类"><a href="#4-4-2-sealed-密封类" class="headerlink" title="4.4.2 sealed 密封类"></a>4.4.2 sealed 密封类</h4><p>sealed 修饰的类称为密封类，用来表示受限的类层次结构。例如当一个值为有限集中的 类型、而不能有任何其他类型时。在某种意义上,他们是枚举类的扩展:枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例,而密封类的一个子类可以有可包含状态的多个实例。  </p>
<h4 id="4-4-3-data-数据类"><a href="#4-4-3-data-数据类" class="headerlink" title="4.4.3 data 数据类"></a>4.4.3 data 数据类</h4><p>data 修饰的类称之为数据类。它通常用在我们写的一些 POJO 类上。<br>当 data 修饰后，会自动将所有成员用 <code>operator</code> 声明，即为这些成员生成类似 Java 的 getter/setter 方法。   </p>
<p>本章就先介绍到这，下一章我们讲继承与组合，伪多继承与接口等内容。</p>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
]]></content>
    
    <summary type="html">
    
      前面三章的内容是写给希望快速了解 Kotlin 语言的大忙人的。   而从本章开始，才会真正讲述 Kotlin 语言的神奇之处。    
    
    </summary>
    
      <category term="code" scheme="http://yoursite.com/categories/code/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Primer·第三章·Kotlin 与 Java 混编</title>
    <link href="http://yoursite.com/2017/02/07/2017-02-07-01/"/>
    <id>http://yoursite.com/2017/02/07/2017-02-07-01/</id>
    <published>2017-02-07T07:34:14.000Z</published>
    <updated>2017-05-19T15:56:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>题外话：全书的目录以及主要内容已经公开，可在我公众号【<a href="http://mp.weixin.qq.com/s/3W6ciZYM1o_J5VqIFyNIpQ" target="_blank" rel="external">技术实验室</a>】的历史推送文章查看</p>
<p>第一部分——快速上手<br><a href="http://shanghai.kotliner.cn/2017/02/03/2017-02-03-01/" target="_blank" rel="external">第一章·启程</a><br><a href="http://shanghai.kotliner.cn/2017/02/04/2017-02-04-01/" target="_blank" rel="external">第二章·基本语法</a><br><a href="http://shanghai.kotliner.cn/2017/02/07/2017-02-07-01/" target="_blank" rel="external">第三章·Kotlin 与 Java 混编</a><br>第二部分——开始学习 Kotlin<br><a href="http://shanghai.kotliner.cn/2017/02/12/2017-02-12-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(上)</a><br><a href="http://shanghai.kotliner.cn/2017/02/26/2017-02-26-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(下)</a><br><a href="http://shanghai.kotliner.cn/2017/04/09/2017-04-09-01/" target="_blank" rel="external">第五章·函数与闭包</a>   </p>
</blockquote>
<p>虽然 Kotlin 的开发很方便，但当你与他人协作时，总会碰到 Java 与 Kotlin 代码共存的代码项目。<br>本章就教你如何优雅的实现 Kotlin 与 Java 混合编程。   </p>
<h3 id="3-1-直接转换"><a href="#3-1-直接转换" class="headerlink" title="3.1 直接转换"></a>3.1 直接转换</h3><h4 id="3-1-1-将-Java-转换为-Kotlin"><a href="#3-1-1-将-Java-转换为-Kotlin" class="headerlink" title="3.1.1 将 Java 转换为 Kotlin"></a>3.1.1 将 Java 转换为 Kotlin</h4><a id="more"></a>
<p>如果你之前使用 Java 语言而没有 Kotlin 开发经验，不用担心，Intellij IDEA 会帮你一键转换，将 Java 代码转换成 Kotlin 代码(但是反过来就不行了)。<br>在 Mac 上，系统默认的快捷键为 <code>control+shift+command+K</code> ，这个组合键实在有点反人类，建议你自定义一个你觉得舒服的快捷键。<br>快捷键可以通过你的编译器 <em>keymap</em> 中修改：<code>command+,</code> -&gt; 搜索<code>keymap</code> -&gt; 右侧搜索<code>kotlin</code>，可以查看到<code>Convert Java File to Kotlin File</code>项。  </p>
<p><img src="http://cdn.kymjs.com/kotlin/3-1-1.png" alt="图3-1-1">  </p>
<h4 id="3-1-2-注意-Class-调用"><a href="#3-1-2-注意-Class-调用" class="headerlink" title="3.1.2 注意 Class 调用"></a>3.1.2 注意 Class 调用</h4><p>在 Java 或 Android 开发中，经常会直接调用一个类的 Class 文件。但是当你用上文介绍的转换方法去转换 <code>XXX.class</code>  这样的代码时，是无法直接转换的(也许未来会修复这个问题，但目前你扔需要手动修改)。在 M13 之前，Java 中的 <code>XXX.class</code> 对应 Kotlin 代码中的 <code>JavaClass&lt;XXX&gt;</code>，而 M13 之后写法已被改为 <code>XXX::class.java</code>。    </p>
<h4 id="3-1-3-Android-proguard-的坑"><a href="#3-1-3-Android-proguard-的坑" class="headerlink" title="3.1.3 Android proguard 的坑"></a>3.1.3 Android proguard 的坑</h4><p>注：我们团队遇到过这样的一个坑，在 Android 开发的时候，如下代码会在混淆以后，发生异常   </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = some?.s?.d ?: <span class="string">""</span></div><div class="line">```  </div><div class="line">这段代码在正常debug模式编译运行完全正常，但是一旦执行混淆，就会发生所在函数被移除的现象。  </div><div class="line">但是如果改写为以下写法就能正常运行：  </div><div class="line"></div><div class="line">```kotlin</div><div class="line"><span class="keyword">var</span> str = some?.s?.d ?: String()</div></pre></td></tr></table></figure>
<p>猜想应该是 proguard 不知道如何处理这段代码，无法识别出最后两个引号是一个 <code>String</code>，最后直接将整个函数移除掉了。   </p>
<p>同样的代码还有：  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> list = some?.<span class="keyword">data</span>?.list:mutableListof()</div></pre></td></tr></table></figure>
<p>但是如下代码即使混淆后也是可以完全正常执行的  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = some?.s ?: <span class="string">""</span>  </div><div class="line"><span class="keyword">var</span> s = some.d ?: <span class="string">""</span></div><div class="line"><span class="keyword">var</span> list = some?.<span class="keyword">data</span>?.list:klist  </div><div class="line"><span class="keyword">var</span> <span class="keyword">data</span> = some?.<span class="keyword">data</span> ?: <span class="keyword">return</span></div></pre></td></tr></table></figure>
<h4 id="3-1-4-开发-Android-library-的建议"><a href="#3-1-4-开发-Android-library-的建议" class="headerlink" title="3.1.4 开发 Android library 的建议"></a>3.1.4 开发 Android library 的建议</h4><p>如果你是开发 Android library 程序，建议你不要使用 Kotlin 代码。因为作为 library，如果使用它的工程是纯 Java 完成的，引入后会额外增大 200k 左右大小，同时它有可能会造成某些情况下编译异常。    </p>
<h3 id="3-2-在-Kotlin-中调用-Java-代码"><a href="#3-2-在-Kotlin-中调用-Java-代码" class="headerlink" title="3.2 在 Kotlin 中调用 Java 代码"></a>3.2 在 Kotlin 中调用 Java 代码</h3><h4 id="3-2-1-返回-void-的方法"><a href="#3-2-1-返回-void-的方法" class="headerlink" title="3.2.1 返回 void 的方法"></a>3.2.1 返回 void 的方法</h4><p>如果一个 Java 方法返回 void，对应的在 Kotlin 代码中它将返回 Unit。关于 Unit，本书将在 第五章 <code>函数</code> 部分着重讲解。<br>现在你只需要知道在Java 中返回为 void 的函数，在 Kotlin 中可以省略这个返回类型。   </p>
<h4 id="3-2-2-与-Kotlin-关键字冲突的处理"><a href="#3-2-2-与-Kotlin-关键字冲突的处理" class="headerlink" title="3.2.2 与 Kotlin 关键字冲突的处理"></a>3.2.2 与 Kotlin 关键字冲突的处理</h4><p>Java 有 static 关键字，在 Kotlin 中没有这个关键字，你需要使用 <code>@JvmStatic</code> 替代这个关键字。<br>同样，在 Kotlin 中也有很多的关键字是 Java 中是没有的。例如 <code>in</code>,<code>is</code>,<code>data</code>等。如果 Java 中使用了这些关键字，需要加上反引号(`)转义来避免冲突。例如   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// Java 代码中有个方法叫 is()</div><div class="line">public void is()&#123;</div><div class="line">	//...</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 转换为 Kotlin 代码需要加反引号转义</div><div class="line">fun `is`() &#123;</div><div class="line">   //...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-3-在-Java-中调用-Kotlin-代码"><a href="#3-3-在-Java-中调用-Kotlin-代码" class="headerlink" title="3.3 在 Java 中调用 Kotlin 代码"></a>3.3 在 Java 中调用 Kotlin 代码</h3><h4 id="3-3-1-static-方法"><a href="#3-3-1-static-方法" class="headerlink" title="3.3.1 static 方法"></a>3.3.1 static 方法</h4><p>上文已经提到过，在 Kotlin 中没有 <code>static</code>关键字,那么如果在 Java 代码中想要通过类名调用一个 Kotlin 类的方法，你需要给这个方法加入<code>@JvmStatic</code>注解。否则你必须通过对象调用这个方法。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">StringUtils.isEmpty(&quot;hello&quot;);  </div><div class="line">StringUtils.INSTANCE.isEmpty2(&quot;hello&quot;);</div><div class="line"></div><div class="line">object StringUtils &#123;</div><div class="line">    @JvmStatic fun isEmpty(str: String): Boolean &#123;</div><div class="line">        return &quot;&quot; == str</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fun isEmpty2(str: String): Boolean &#123;</div><div class="line">        return &quot;&quot; == str</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">如果你阅读 Kotlin 代码，应该经常看到这样一种写法。</div></pre></td></tr></table></figure>
<p>class StringUtils {<br>    companion object {<br>       fun isEmpty(str: String): Boolean {<br>            return “” == str<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">```companion object</div></pre></td></tr></table></figure></p>
<p>表示外部类的一个伴生对象，你可以把他理解为外部类自动创建了一个对象作为自己的<code>field</code>。<br>与上面的类似，Java 在调用时，可以这样写：<code>StringUtils.Companion. isEmpty();</code><br>关于伴生对象，我们将在下一章 <code>类与对象</code> 详细讲解。  </p>
<h4 id="3-3-2-包级别函数"><a href="#3-3-2-包级别函数" class="headerlink" title="3.3.2 包级别函数"></a>3.3.2 包级别函数</h4><p>与 Java 不同，Kotlin 允许函数独立存在，而不必依赖于某个类，这类函数我们称之为<strong>包级别函数</strong>(Package-Level Functions)。<br>为了兼容 Java，Kotlin 默认会将所有的包级别函数放在一个自动生成的叫 <code>ExampleKt</code> 的类中， 在 Java 中想要调用包级别函数时，需要通过这个类来调用。<br>当然，也是可以自定义的，你只需要通过注解 <code>@file:JvmName(&quot;Example&quot;)</code> 即可将当前文件中的所有包级别函数放到一个自动生成的名为 Example 的类中。   </p>
<h4 id="3-3-3-空安全性"><a href="#3-3-3-空安全性" class="headerlink" title="3.3.3 空安全性"></a>3.3.3 空安全性</h4><p>在 Java 中，如果你调用的 kotlin 方法参数声明了非空类型，如果你在 Java 代码中传入一个空值，将在运行时抛出 <code>NullPointerException</code>。其内部原因在于 Kotlin 为每个非空类型加了断言，如果传入空值则会立刻抛出异常。<br>同样，如果你使用 null 对象去调用一个 kotlin 方法，将会立刻抛出<code>NullPointerException</code>（就算是调用普通 java 方法也是一样会抛出 NullPointerException ）   </p>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
]]></content>
    
    <summary type="html">
    
      前三章的内容是为方便想在短时间内马上用上Kotlin的人，例如作为一个刚入职的新人，公司的代码已经是用Kotlin编写了，你应该如何更快的融入与适应。   
    
    </summary>
    
      <category term="code" scheme="http://yoursite.com/categories/code/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Primer·第二章·基本语法</title>
    <link href="http://yoursite.com/2017/02/04/2017-02-04-01/"/>
    <id>http://yoursite.com/2017/02/04/2017-02-04-01/</id>
    <published>2017-02-04T07:44:44.000Z</published>
    <updated>2017-05-19T15:56:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>题外话：全书的目录以及主要内容已经公开，可在我公众号【<a href="http://mp.weixin.qq.com/s/3W6ciZYM1o_J5VqIFyNIpQ" target="_blank" rel="external">技术实验室</a>】的历史推送文章查看</p>
<p>第一部分——快速上手<br><a href="http://shanghai.kotliner.cn/2017/02/03/2017-02-03-01/" target="_blank" rel="external">第一章·启程</a><br><a href="http://shanghai.kotliner.cn/2017/02/04/2017-02-04-01/" target="_blank" rel="external">第二章·基本语法</a><br><a href="http://shanghai.kotliner.cn/2017/02/07/2017-02-07-01/" target="_blank" rel="external">第三章·Kotlin 与 Java 混编</a><br>第二部分——开始学习 Kotlin<br><a href="http://shanghai.kotliner.cn/2017/02/12/2017-02-12-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(上)</a><br><a href="http://shanghai.kotliner.cn/2017/02/26/2017-02-26-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(下)</a><br><a href="http://shanghai.kotliner.cn/2017/04/09/2017-04-09-01/" target="_blank" rel="external">第五章·函数与闭包</a>  </p>
</blockquote>
<p>Kotlin 程序是什么样子的？如果浏览过本书，你会看到许多例子。很有可能你觉得 Kotlin 语言有点古怪，充满了 <code>var field: String</code> 这样的语法。然而读完本章后，你将不再对这些语法感到陌生，甚至很可能喜欢上它们。  </p>
<h3 id="2-1-变量"><a href="#2-1-变量" class="headerlink" title="2.1 变量"></a>2.1 变量</h3><a id="more"></a>
<p>让我们来看一个很简单的程序。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> quantity = <span class="number">5</span></div><div class="line">    <span class="keyword">val</span> price: <span class="built_in">Double</span> = <span class="number">20.3</span></div><div class="line">    <span class="keyword">val</span> name: String = <span class="string">"大米"</span></div><div class="line"></div><div class="line">    println(<span class="string">"单价:<span class="subst">$price</span>"</span>)</div><div class="line">    println(<span class="string">"数量:<span class="subst">$quantity</span>"</span>)</div><div class="line">    println(<span class="string">"产品:<span class="subst">$name</span> 总计:<span class="subst">$&#123;quantity * price&#125;</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码中，首先创建了一个名为 <code>quantity</code> 的变量用以表示产品的数量，并初始化为 5。<br>一个值为 20.3 的常量 <code>price</code>，用来表示产品的单价。<br>一个表示产品名字的字符串常量 <code>name</code>。  </p>
<p>通过这段代码我们可以看到，Kotlin 语言声明一个变量使用关键字 <code>var</code>，声明一个常量使用 <code>val</code>，声明时 Kotlin 语言是可以自动推测出字段类型的，例如上面代码中的 <code>var quantity = 5</code> 会被认为是 <code>Int</code> 类型，但如果你希望它是一个 <code>Double</code> 类型，则需要显示声明类型，例如 <code>var quantity: Double = 5</code>。</p>
<h3 id="2-2-语句"><a href="#2-2-语句" class="headerlink" title="2.2 语句"></a>2.2 语句</h3><h4 id="2-2-1-in关键字的使用"><a href="#2-2-1-in关键字的使用" class="headerlink" title="2.2.1 in关键字的使用"></a>2.2.1 in关键字的使用</h4><p>判断一个对象是否在某一个区间内，可以使用in关键字  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果存在于区间(1,Y-1)，则打印OK</span></div><div class="line"><span class="keyword">if</span> (x <span class="keyword">in</span> <span class="number">1.</span>.y<span class="number">-1</span>) </div><div class="line">  print(<span class="string">"OK"</span>)</div><div class="line"></div><div class="line"><span class="comment">//如果x不存在于array中，则输出Out</span></div><div class="line"><span class="keyword">if</span> (x !<span class="keyword">in</span> <span class="number">0.</span>.array.lastIndex) </div><div class="line">  print(<span class="string">"Out"</span>)</div><div class="line"></div><div class="line"><span class="comment">//打印1到5</span></div><div class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) </div><div class="line">  print(x)</div><div class="line"></div><div class="line"><span class="comment">//遍历集合(类似于Java中的for(String name : names))</span></div><div class="line"><span class="keyword">for</span> (name <span class="keyword">in</span> names)</div><div class="line">  println(name)</div><div class="line"></div><div class="line"><span class="comment">//如果names集合中包含text对象则打印yes</span></div><div class="line"><span class="keyword">if</span> (text <span class="keyword">in</span> names)</div><div class="line">  print(<span class="string">"yes"</span>)</div></pre></td></tr></table></figure>
<h4 id="2-2-2-when表达式"><a href="#2-2-2-when表达式" class="headerlink" title="2.2.2 when表达式"></a>2.2.2 when表达式</h4><p>类似于 Java 中的 switch，但是 Kotlin 更加智能，可以自动判断参数的类型并转换为响应的匹配值。 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cases</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123; </div><div class="line">  <span class="keyword">when</span> (obj) &#123;</div><div class="line">    <span class="number">1</span>       -&gt; print(<span class="string">"第一项"</span>)</div><div class="line">    <span class="string">"hello"</span> -&gt; print(<span class="string">"这个是字符串hello"</span>)</div><div class="line">    <span class="keyword">is</span> <span class="built_in">Long</span> -&gt; print(<span class="string">"这是一个Long类型数据"</span>)</div><div class="line">    !<span class="keyword">is</span> String -&gt; print(<span class="string">"这不是String类型的数据"</span>)</div><div class="line">    <span class="keyword">else</span>    -&gt; print(<span class="string">"else类似于Java中的default"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-2-3-智能类型推测"><a href="#2-2-3-智能类型推测" class="headerlink" title="2.2.3 智能类型推测"></a>2.2.3 智能类型推测</h4><p>判断一个对象是否为一个类的实例，可以使用is关键字<br>与 Java 中的<figure class="highlight plain"><figcaption><span>Kotlin 中如果已经确定了一个对象的类型，可以在接下来的代码块中直接作为这个确定类型使用。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```kotlin</div><div class="line">fun getStringLength(obj: Any): Int? &#123;</div><div class="line">  if (obj is String) &#123;</div><div class="line">    // 做过类型判断以后，obj会被系统自动转换为String类型</div><div class="line">    return obj.length </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //同时还可以使用!is，来取反</div><div class="line">  if (obj !is String)&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 代码块外部的obj仍然是Any类型的引用</div><div class="line">  return null</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-2-4-空值检测"><a href="#2-2-4-空值检测" class="headerlink" title="2.2.4 空值检测"></a>2.2.4 空值检测</h4><p>Kotlin 是空指针安全的，也就意味着你不会再看到那恼人的空指针异常。<br>例如这句代码 <code>println(files?.size)</code>，只会在 <code>files</code>不为空时执行。<br>以及，你可以这样写  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//当data不为空的时候，执行语句块</span></div><div class="line"><span class="keyword">data</span>?.let&#123;</div><div class="line">	<span class="comment">//... </span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//相反的，以下代码当data为空时才会执行</span></div><div class="line"><span class="keyword">data</span>?:let&#123;</div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-3-函数"><a href="#2-3-函数" class="headerlink" title="2.3 函数"></a>2.3 函数</h3><h4 id="2-3-1-函数的声明"><a href="#2-3-1-函数的声明" class="headerlink" title="2.3.1 函数的声明"></a>2.3.1 函数的声明</h4><p>函数使用关键字 <code>fun</code> 声明，如下代码创建了一个名为 <code>say()</code> 的函数，它接受一个 <code>String</code> 类型的参数，并返回一个 <code>String</code> 类型的值  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">say</span><span class="params">(str: <span class="type">String</span>)</span></span>: String &#123;</div><div class="line">	<span class="keyword">return</span> str</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时，在 Kotlin 中，如果像这种简单的函数，可以简写为 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">say</span><span class="params">(str: <span class="type">String</span>)</span></span>: String = str</div></pre></td></tr></table></figure>
<p>如果是返回<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```kotlin</div><div class="line">fun getIntValue(value: Int) = value</div></pre></td></tr></table></figure></p>
<h4 id="2-3-2-函数的默认参数"><a href="#2-3-2-函数的默认参数" class="headerlink" title="2.3.2 函数的默认参数"></a>2.3.2 函数的默认参数</h4><p>你也可以使用默认参数来实现重载类似的功能  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">say</span><span class="params">(str: <span class="type">String</span> = <span class="string">"hello"</span>)</span></span>: String = str</div></pre></td></tr></table></figure>
<p>这时候你可以调用<figure class="highlight plain"><figcaption><span>```"hello"```，也可以自己传入参数```say("world")```来得到传入参数值。   </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">有时参数非常多的时候，也可以使用多行参数的写法，它们是相同的  </div><div class="line"></div><div class="line">```kotlin</div><div class="line">fun say(firstName: String = &quot;Tao&quot;,</div><div class="line">		lastName: String = &quot;Zhang&quot;)&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-3-3-变参函数"><a href="#2-3-3-变参函数" class="headerlink" title="2.3.3 变参函数"></a>2.3.3 变参函数</h4><p>同 Java 的变长参数一样，Kotlin 也支持变长参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在Java中，我们这么表示一个变长函数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasEmpty</span><span class="params">(String... strArray)</span></span>&#123;</div><div class="line">	<span class="keyword">for</span> (String str : strArray)&#123;</div><div class="line">		<span class="keyword">if</span> (<span class="string">""</span>.equals(str) || str == <span class="keyword">null</span>)</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//在Kotlin中，使用关键字vararg来表示</span></div><div class="line"><span class="function">fun <span class="title">hasEmpty</span><span class="params">(vararg strArray: String?)</span>: Boolean</span>&#123;</div><div class="line">	<span class="keyword">for</span> (str in strArray)&#123;</div><div class="line">		<span class="keyword">if</span> (<span class="string">""</span>.equals(str) || str == <span class="keyword">null</span>)</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>	</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-3-4-扩展函数"><a href="#2-3-4-扩展函数" class="headerlink" title="2.3.4 扩展函数"></a>2.3.4 扩展函数</h4><p>你可以给父类添加一个方法，这个方法将可以在所有子类中使用<br>例如，在 Android 开发中，我们常常使用这样的扩展函数：  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> Activity.<span class="title">toast</span><span class="params">(message: <span class="type">CharSequence</span>, duration: <span class="type">Int</span> = Toast.LENGTH_SHORT)</span></span> &#123;</div><div class="line">    Toast.makeText(<span class="keyword">this</span>, message, duration).show()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这样，我们就可以在每一个 <code>Activity</code> 中直接使用toast()函数了。   </p>
<h4 id="2-3-5-将函数作为参数"><a href="#2-3-5-将函数作为参数" class="headerlink" title="2.3.5 将函数作为参数"></a>2.3.5 将函数作为参数</h4><p> Kotlin 中，可以将一个函数作为参数传递给另一个函数  </p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">fun</span> lock<span class="type">&lt;T&gt;</span><span class="params">(lock: <span class="type">Lock</span>, body: ()</span></span> -&gt; T ) : T &#123;</div><div class="line">	    lock.lock()</div><div class="line">	    <span class="keyword">try</span> &#123;</div><div class="line">	        <span class="keyword">return</span> body()</div><div class="line">	    &#125;</div><div class="line">	    <span class="keyword">finally</span> &#123;</div><div class="line">	        lock.unlock()</div><div class="line">	    &#125;</div><div class="line">&#125;</div><div class="line"> ``` </div><div class="line">上面的代码中，我们传入了一个无参的 body() 作为 lock() 的参数，</div><div class="line"></div><div class="line">### <span class="number">2.4</span> 小结  </div><div class="line"></div><div class="line">最后，我们用一段代码来总结本章内容，你能看懂吗？  </div><div class="line"></div><div class="line">```kotlin</div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">val</span> firstName: String = <span class="string">"Tao"</span></div><div class="line">    <span class="keyword">val</span> lastName: String? = <span class="string">"Zhang"</span></div><div class="line"></div><div class="line">    println(<span class="string">"my name is <span class="subst">$&#123;getName(firstName, lastName)&#125;</span>"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasEmpty</span><span class="params">(<span class="keyword">vararg</span> strArray: <span class="type">String</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</div><div class="line">    <span class="keyword">for</span> (str <span class="keyword">in</span> strArray) &#123;</div><div class="line">        str ?: <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">(firstName: <span class="type">String</span>?, lastName: <span class="type">String</span>? = <span class="string">"unknow"</span>)</span></span>: String &#123;</div><div class="line">    <span class="keyword">if</span> (hasEmpty(firstName, lastName)) &#123;</div><div class="line">        lastName?.let &#123; <span class="keyword">return</span><span class="symbol">@getName</span> <span class="string">"<span class="subst">$&#123;checkName(firstName)&#125;</span> <span class="subst">$lastName</span>"</span> &#125;</div><div class="line">        firstName?.let &#123; <span class="keyword">return</span><span class="symbol">@getName</span> <span class="string">"<span class="subst">$firstName</span> <span class="subst">$&#123;checkName(lastName)&#125;</span>"</span> &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">"<span class="subst">$firstName</span> <span class="subst">$lastName</span>"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkName</span><span class="params">(name: <span class="type">String</span>?)</span></span>: String = name ?: <span class="string">"unknow"</span></div></pre></td></tr></table></figure>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt="">  </p>
]]></content>
    
    <summary type="html">
    
      前三章的内容是为方便想在短时间内马上用上Kotlin的人，例如作为一个刚入职的新人，公司的代码已经是用Kotlin编写了，你应该如何更快的融入与适应。  
    
    </summary>
    
      <category term="code" scheme="http://yoursite.com/categories/code/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Primer·第一章·启程</title>
    <link href="http://yoursite.com/2017/02/03/2017-02-03-01/"/>
    <id>http://yoursite.com/2017/02/03/2017-02-03-01/</id>
    <published>2017-02-03T09:34:14.000Z</published>
    <updated>2017-05-19T15:55:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>题外话：全书的目录以及主要内容已经公开，可在我公众号【<a href="http://mp.weixin.qq.com/s/3W6ciZYM1o_J5VqIFyNIpQ" target="_blank" rel="external">技术实验室</a>】的历史推送文章查看</p>
<p>第一部分——快速上手<br><a href="http://shanghai.kotliner.cn/2017/02/03/2017-02-03-01/" target="_blank" rel="external">第一章·启程</a><br><a href="http://shanghai.kotliner.cn/2017/02/04/2017-02-04-01/" target="_blank" rel="external">第二章·基本语法</a><br><a href="http://shanghai.kotliner.cn/2017/02/07/2017-02-07-01/" target="_blank" rel="external">第三章·Kotlin 与 Java 混编</a><br>第二部分——开始学习 Kotlin<br><a href="http://shanghai.kotliner.cn/2017/02/12/2017-02-12-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(上)</a><br><a href="http://shanghai.kotliner.cn/2017/02/26/2017-02-26-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(下)</a><br><a href="http://shanghai.kotliner.cn/2017/04/09/2017-04-09-01/" target="_blank" rel="external">第五章·函数与闭包</a>     </p>
</blockquote>
<p>欢迎阅读本书！Kotlin 语言是一种新的静态类型编程语言，可运行于 JVM 环境同时也能用来开发 Android 应用。本章为学习和使用这一新兴的语言做准备，并讨论在一些常见开发环境中运行 Kotlin 程序的方法。  </p>
<h3 id="1-1-Kotlin语言介绍"><a href="#1-1-Kotlin语言介绍" class="headerlink" title="1.1 Kotlin语言介绍"></a>1.1 Kotlin语言介绍</h3><p>Kotlin 是 JetBrains 在 2010 年推出的基于 JVM 的新编程语言。开发者称，设计它的目的是避免 Java 语言编程中的一些难题。比如：在 Kotlin 中类型系统控制了空指针引用，可以有效避免 Java 中常见的NullPointException。<br>作为一个跨平台的语言，Kotlin 可以工作于任何 Java 的工作环境：服务器端的应用，移动应用（Android版），桌面应用程序。 </p>
<a id="more"></a> 
<h3 id="1-2-Kotlin的优势"><a href="#1-2-Kotlin的优势" class="headerlink" title="1.2 Kotlin的优势"></a>1.2 Kotlin的优势</h3><p>相比于 Java，Kotlin 有着更好的语法结构，安全性和开发工具支持。<br>Kotlin 中没有基础类型，数组是定长的，泛型是安全的，即便运行时也是安全的。此外，该语言支持闭包，还可通过内联进行优化。不过，它不支持检查异常（Checked Exceptions），许多语言设计者认为这是它的瑕疵。不论如何，重要的是 Java 和 Kotlin 之间的互操作性：Kotlin 可以调用 Java，反之亦可。</p>
<h3 id="1-3-准备工作"><a href="#1-3-准备工作" class="headerlink" title="1.3 准备工作"></a>1.3 准备工作</h3><p>Intellij IDEA 是 JetBrains 提供的继承开发环境，可以用来开发 Kotlin 应用程序。<br>如果你是一名 Android 开发者，你也可以使用 Android Studio 来开发 Kotlin 程序。如你所知，Android Studio 其实就是 Intellij IDEA 的插件扩展，Intellij IDEA 是由 JetBrains 所开发，而 Kotlin 同样是由 JetBrains 创造的，其中的兼容性自然不用多说。<br>在安装好 Intellij IDEA 后，还需要安装 Kotlin 插件。<br><strong>说明</strong>：从 Intellij 15 开始，已经自带了 Kotlin 插件，无需再次下载，而 Android Studio 却没有。不过还是建议你运行一下下面的步骤，检查一下插件是否为最新版。</p>
<p>首先启动你的 IDE，按下快捷键 Ctrl+, (Mac 下为 command+,) 打开Preference 界面。<br>点击左侧 Plugin 栏，打开插件界面。<br>点击 Browse repositories（如图1-3-1）。   </p>
<p><img src="http://cdn.kymjs.com/kotlin/1-3-1.png" alt="图1-3-1：kotlin安装">    </p>
<p>在弹出的窗口上方，搜索 “Kotlin”，选中 Kotlin 和 Kotlin Extension For Android。<br>点击右侧的 Install。<br>安装完成后按钮会变成 Restart，再次点击重启 IDE。<br>刚刚安装的这两个插件分别为 Kotlin 语言支持包，和我们稍后会用到的Android 开发的扩展包。   </p>
<p><strong>一点小技巧</strong>：也许由于网络环境原因，会造成下载失败。可以根据弹出窗口中提示的(或直接在 JetBrains 插件市场搜索)下载链接，使用国内网盘的离线下载功能，下载到网盘后再从网盘下载到本地。  </p>
<h3 id="1-4-Hello-Kotlin"><a href="#1-4-Hello-Kotlin" class="headerlink" title="1.4 Hello Kotlin"></a>1.4 Hello Kotlin</h3><h4 id="1-4-1-第一个Kotlin程序"><a href="#1-4-1-第一个Kotlin程序" class="headerlink" title="1.4.1 第一个Kotlin程序"></a>1.4.1 第一个Kotlin程序</h4><p>首先我们打开 Intellij 选中 Create a new project 选项后可以看到如下界面。<br>在 Additional Libraries and Frameworks 选项框中，如果你已经成功安装 Kotlin 插件，可以直接勾选 Kotlin(Java) 选项。<br>再点击下方的 Create 按钮，在弹出的 Create Kotlin Java Runtime Library 选项框中，我们选择 Use library from plugin 并确定(如图1-4-1)。  </p>
<p><img src="http://cdn.kymjs.com/kotlin/1-4-1.png" alt="图1-4-1">  </p>
<p>点击 Next，填写工程名和路径，这里我们创建一个名为 Hello 的工程，并点击 Finish 完成创建(如图1-4-2)。  </p>
<p><img src="http://cdn.kymjs.com/kotlin/1-4-2.png" alt="图1-4-2">  </p>
<p>首次创建工程需要等待一段时间，编译器这个时候正在帮助我们下载一些必要的依赖项。<br>工程构建完成后，右键工程目录的 src 图标，选择 New -&gt; Kotlin File，这里我们新建一个名为 Hello 的 Kotlin 源码文件(如图1-4-3)。  </p>
<p> <img src="http://cdn.kymjs.com/kotlin/1-4-3.png" alt="图1-4-3">  </p>
<p>看一下左侧的工程目录，src 文件夹中存放的是源码，可以在这里新建包或类；Hello.iml 文件声明了一些项目所需的环境依赖，我们不用关心。<br>于是，终于可以开始激动人心的编码了。  </p>
<p> <img src="http://cdn.kymjs.com/kotlin/1-4-4.png" alt="图1-4-4">  </p>
<p>Kotlin 程序非常简单，简单到只需要三行代码，相比起 Java 连包名都不是必须的。  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    print(<span class="string">"hello kotlin!"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>按下 Ctrl+R 快捷键，或者右上角绿色三角形，运行写好的程序(如图1-4-5)  </p>
<p> <img src="http://cdn.kymjs.com/kotlin/1-4-5.png" alt="图1-4-5">  </p>
<p>同 Java 语言一样，Kotlin 程序主入口也是 main() 函数。但是作为函数是一等公民的语言，它不需要像 Java 那样必须声明一个类。<br>在 Kotlin 中，函数的声明用 <code>fun</code> 表示，变量也与 Java 不同，是变量名在前，变量类型在后，中间用冒号隔开。<br>同时你也一定发现了，Kotlin 程序非常简洁，连分号也不需要写，当然如果你是刚从 Java 过渡来的，改不掉或不想改掉这个习惯，写上了也不会有错，因为它是可选的。<br>同时，我们还可以发现，在左侧的工程目录多了一个红色名为 out 的目录，它是用来存放 .class 文件的。</p>
<h4 id="1-4-2-面向对象的Kotlin程序"><a href="#1-4-2-面向对象的Kotlin程序" class="headerlink" title="1.4.2 面向对象的Kotlin程序"></a>1.4.2 面向对象的Kotlin程序</h4><p>下面我们将 Hello 程序改一改，为它加入一些面向对象的特性。<br>我们创建一个包，并在包下新建名为 <code>Person</code> 的类。  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.kymjs.kotlin.helloobj</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">()</span></span> &#123;</div><div class="line">        println(name)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再回到<figure class="highlight plain"><figcaption><span>main() 函数</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```kotlin</div><div class="line">import com.kymjs.kotlin.helloobj.Person</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    println(&quot;hello kotlin!&quot;)</div><div class="line">    Person(&quot;Zhang Tao&quot;).printName()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再次按下 Ctrl+R 快捷键，或者右上角绿色三角形，运行写好的程序(如图1-4-6)  </p>
<p> <img src="http://cdn.kymjs.com/kotlin/1-4-6.png" alt="图1-4-6">  </p>
<p>细心查看代码，Kotlin 创建对象的时候并不需要<code>new</code>关键字，而是像调用普通方法一样直接调用构造方法就可以了。<br>同时，由于两个文件不在同一个包下，需要导入 <code>Person</code> 类所在的包才能找到，当然，编译器已经帮我们解决了繁杂的导包过程。  </p>
<h3 id="1-5-编码风格"><a href="#1-5-编码风格" class="headerlink" title="1.5 编码风格"></a>1.5 编码风格</h3><p>有关编码风格的一点建议，同 Java 类似，使用驼峰命名法，类名首字母大写，每个单词的首字母大写；方法和属性变量首字母小写；采用四个空格缩进。<br>值得一提的是，官方文档中建议在 Kotlin 语言中不要给属性前面加前缀，例如通常我们习惯加上一个小写 <code>m</code> 或者下划线等。<br>冒号，在分隔两个类型的时候，应该在左右都有空格，在实例和类型之间，应该紧靠实例变量，例如：  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span>&lt;<span class="type">out T : Any</span>&gt; : <span class="type">Bar &#123;</span></span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(a: <span class="type">Int</span>)</span></span>: T</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Lambdas表达式，如果是简单的只用一行就可以表示的 lambda，应当遵循在大括号的两侧、箭头的两侧、参数的两侧都使用空格隔开，例如：  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list.filter &#123; it &gt; <span class="number">10</span> &#125;.map &#123; element -&gt; element * <span class="number">2</span> &#125;</div></pre></td></tr></table></figure>
<h3 id="1-6-小结"><a href="#1-6-小结" class="headerlink" title="1.6 小结"></a>1.6 小结</h3><p>在本章中，你已经编写了两个 Kotlin 程序，相信你也已经对 Kotlin 产生了兴趣。希望你也能像我一样，沉醉于使用 Kotlin 开发。<br>继续学习下一章的内容吧，我们将进入 Kotlin 的语法世界。</p>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt="">  </p>
]]></content>
    
    <summary type="html">
    
      其实最初是准备写一本电子书然后免费开放给大家的，可惜啊可惜毅力不够，坚持不下来，所以还是当成博客来写，写好了再出电子书吧。 
    
    </summary>
    
      <category term="code" scheme="http://yoursite.com/categories/code/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin：The Good, The Bad, and The Ugly(译)</title>
    <link href="http://yoursite.com/2016/08/27/kotlin_good_bad_bugly/"/>
    <id>http://yoursite.com/2016/08/27/kotlin_good_bad_bugly/</id>
    <published>2016-08-27T08:59:00.000Z</published>
    <updated>2017-05-19T16:03:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>tags: Kotlin, Android</p>
<p>在我的 <a href="https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6" target="_blank" rel="external">上一篇文章</a>, 谈到了关于转换 Java 到 Kotlin 代码和我喜欢的一些库。现在，我想要谈谈关于 Kotlin 这门语言本身的想法，还有它和 Java 交互的方式。</p>
<a id="more"></a>
<h2 id="The-Good"><a href="#The-Good" class="headerlink" title="The Good"></a>The Good</h2><p>Kotlin 有许多让人喜欢的理由。像 <code>null safety</code>、<code>property access</code> 和 <code>unchecked exceptions</code> 类似这些明显的特性在 <a href="https://blog.jetbrains.com/kotlin/2016/01/kotlin-digest-2015/" target="_blank" rel="external">publications</a> 都有描述，我就不重复了。我只讲一些我真正喜欢但很少被提到的特性。</p>
<h3 id="Automatic-conversion-of-Java-to-Kotlin"><a href="#Automatic-conversion-of-Java-to-Kotlin" class="headerlink" title="Automatic conversion of Java to Kotlin"></a>Automatic conversion of Java to Kotlin</h3><p>JetBrains 在 IntelliJ 中集成了 <code>Java to Kotlin converter</code> 为我们节约了大量的时间。虽然它还不是很完美，但是它让你不用再重复输入。要是没有它，你将要花费大量的时间从 Java 代码转换成 Kotlin。</p>
<h3 id="lateinit-Delegates-notNull-and-lazy"><a href="#lateinit-Delegates-notNull-and-lazy" class="headerlink" title="lateinit, Delegates.notNull and lazy"></a>lateinit, Delegates.notNull and lazy</h3><p>Kotlin 的 <code>null safety</code> 非常好，但是由于在 Android 的 Activity 生命周期的设计，你常常不得不在 <em>onCreate</em> 这样的回调中初始化一个变量，而不是在类的构造函数中。假设你有一个属性需要定义，你肯定想要这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val name: String</div></pre></td></tr></table></figure>
<p>如果你必须在 <code>onCreate</code> 中初始化这个属性，就不能用 <code>val</code> 定义，而必须使用 <code>var</code>。但是这样你必须在定义的时候为该属性提供一个值进行初始化，或者将它定义为可空类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var name: String? = null</div></pre></td></tr></table></figure>
<p>这样的确有效，但是当你每次使用它的时候都要进行空检查。虽然 Korlin 提供了友好的的空断言，但是在实践中即使你知道你的属性不会为空，你也不愿意到处使用 <code>!!</code>。庆幸的是，Kotlin 提供了更好的方式：<a href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties" target="_blank" rel="external"><em>lateinit</em></a> 和 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/not-null.html" target="_blank" rel="external"><em>Delegates.notNull</em></a>。任何一个都能可以让你在不初始化的情况下定义一个非空类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lateinit var name: String</div><div class="line">var age: Int by Delegates.notNull&lt;Int&gt;()</div></pre></td></tr></table></figure>
<p>这两种方式中，当你尝试在初始化之前访问该属性都会抛出异常。除了<code>lateinit</code> 不能用于基础类型的定义，这两种方法没有什么大的差别。</p>
<p>你还有第三种选择就是使用 <code>lazy</code> 委托。如果一个属性能够利用其他属性或方法获得数据进行初始化，那么 <code>lazy</code> 会是一个很好的选择。类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val imm: InputMethodManager by lazy &#123; </div><div class="line">    getSystemService(INPUT_METHOD_SERVICE) as InputMethodManager </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面块里面的代码在第一次读取之前并不会执行，执行的结果会被保存起来以供后面使用，所以后面的代码块只会被执行一次。</p>
<h3 id="Functional-collection-extensions"><a href="#Functional-collection-extensions" class="headerlink" title="Functional collection extensions"></a>Functional collection extensions</h3><p>Kotlin 提供为集合和迭代类提供了大量的函数式 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html#functions" target="_blank" rel="external">扩展方法</a>。像 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/any.html" target="_blank" rel="external"><em>any</em></a>、 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/join-to-string.html" target="_blank" rel="external"><em>joinToString</em></a> 和 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/associate.html" target="_blank" rel="external"><em>associate</em></a> 的方法能够帮助节约大量的时间，不用像 Java 里面一样手工编写 <em>for</em> 循环去实现。</p>
<p>Kotlin 还提供了大量的函数式集合操作的懒加载模式，在这种模式下载每个操作执行之前并不会进行集合的拷贝，但是在我的接受范围内，发现懒加载和即刻加载在性能上并没有什么大的差别。</p>
<h3 id="Named-and-default-function-arguments"><a href="#Named-and-default-function-arguments" class="headerlink" title="Named and default function arguments"></a>Named and default function arguments</h3><p><a href="https://kotlinlang.org/docs/reference/functions.html#named-arguments" target="_blank" rel="external">命名参数</a> 和 <a href="https://kotlinlang.org/docs/reference/functions.html#named-arguments" target="_blank" rel="external">默认参数</a> 是非常基础的，但它们让你不再需要重载方法，并且也替代了 Builder 模式的一种使用场景。</p>
<p>根据具体使用场景，你甚至可以在依赖注入中将生产依赖作为默认参数，然后在测试的时候传入模拟的数据。</p>
<p>例如，你在 <code>presenter</code> 中需要一些全局状态，你可以这样定义构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Presenter(</div><div class="line">        val okhttp: OkHttp = productionOkHttp(),</div><div class="line">        val picasso: Picasso = productionPicassoInstance()</div><div class="line">) &#123;...&#125;</div></pre></td></tr></table></figure>
<p>这样，你就你可以 <code>UI</code> 代码中创建 <code>presenter</code> 实例的时候不传递任何参数，但是在测试的时候可以传递模拟的实例作为参数。完整的依赖注入框架会更加强大，但这是一个一些简单语言构造的很好的例子。</p>
<h2 id="The-Bad"><a href="#The-Bad" class="headerlink" title="The Bad"></a>The Bad</h2><p>尽管 Kotlin 非常棒，但是它并不完美。我列举了一下我不喜欢的部分。</p>
<h3 id="No-namespaces"><a href="#No-namespaces" class="headerlink" title="No namespaces"></a>No namespaces</h3><p>Kotlin 允许你在文件中定义顶级的函数和属性。这是一个非常棒的特性，但是这会带来所有从 Kotlin 引用的顶级声明无法区分的困扰。有时，这让我们在读代码的时候很难快速确定用的是哪一个函数。</p>
<p>例如，你定义这样一个顶级函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun foo() &#123;...&#125;</div></pre></td></tr></table></figure>
<p>你可以通过 <code>foo()</code> 调用。如果你在不同的包里面也存在同样的方法，在调用侧不能明显区分出是调用的哪个方法。你可以通过在前面添加包名的方式去调用，但是如果 Java 约定的包名很深，似乎不太好。</p>
<p>一种近似的解决方案是使用单例的 <code>object</code> 类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">object FooActions &#123;</div><div class="line">    fun foo() &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样你在 Kotlin 中可以通过 <code>FooActions.foo()</code> 调用，但是在 Java 代码中就不是那么友好了。在 Java 中你必须要这样 <code>FooActions.INSTANCE.foo()</code> 这样调用，这看起来并不完美。你可以使用 <code>@JvmStatic</code> 去注解你的方法从而省掉 <code>INSTANCE</code>，这是你能做到的最好结果。这并不是什么大不了的事，但是如果 Kotlin 能够提供命名空间的话，能省不少事。</p>
<h3 id="No-static-modifier"><a href="#No-static-modifier" class="headerlink" title="No static modifier"></a>No static modifier</h3><p>无独有偶，Kotlin 提供为静态函数和属性提供了一个和 Java 不一样的处理方式。并不是说有多烂，只是觉得让代码变得不干净而且没有必要。例如，在 Android 的 <code>View</code> 类中定义的静态属性 <code>View.VISIBLE</code> 和静态函数 <code>View.inflate</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class View &#123;</div><div class="line">    public static final int VISIBLE = 0x00000000;</div><div class="line">    public static final int INVISIBLE = 0x00000004;</div><div class="line">    public static View inflate(Context context, int resource) &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个定义是简单的。然而，在 Kotlin 代码中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class View &#123;</div><div class="line">    companion object &#123;</div><div class="line">        @JvmField </div><div class="line">        val VISIBLE: Int = 0x00000000</div><div class="line">        @JvmField </div><div class="line">        val INVISIBLE: Int = 0x00000004</div><div class="line">        @JvmStatic</div><div class="line">        fun inflate(context: Context, resource: Int) &#123;...&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>尽管 Kotlin 的版本并没有那么恐怖，但是它的复杂程度超过了我对这门语言的预期。如果把注解去掉，那么你在 Java 代码中不得不使用这样可怕的语法去调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// With annotations:</div><div class="line">View.VISIBLE;</div><div class="line">//Without annotations:</div><div class="line">View.Companion.getVISIBLE();</div></pre></td></tr></table></figure>
<p>没有更好的方式去创建静态函数和属性让我感觉很奇怪。我知道 <code>companion objects</code> 是真正的对象并且能够用来实现接口，但是这并不能足够说明能完全替代普通的静态声明。</p>
<h3 id="Automatic-conversion-of-Java-to-Kotlin-1"><a href="#Automatic-conversion-of-Java-to-Kotlin-1" class="headerlink" title="Automatic conversion of Java to Kotlin"></a>Automatic conversion of Java to Kotlin</h3><p>在我的第一篇帖子里这是我列出来的我喜欢 Kotlin 的愿意之一，并且它很好用。但是正由于它在 80% 的时候都运行的很好，它在一些场景的失败实在令人沮丧。</p>
<p>Java 文档经常错位，特别是在段落横跨了好几行的时候。静态域和方法被转换成 <code>companion object</code>，除非你手动添加为他们分别添加 <code>@JvmField</code> 和 <code>@JvmStatic</code> ，你之前 Java 调用代码不在有效而出错。</p>
<p>由于 Kotlin 团队花了大量的时间在转换代码上，我相信这些问题一定会被修复的，因此我对这些问题保持乐观。</p>
<h3 id="Required-property-accessor-syntax"><a href="#Required-property-accessor-syntax" class="headerlink" title="Required property accessor syntax"></a>Required property accessor syntax</h3><p>Kotlin 提供一个很棒的语法糖叫做「属性访问语法」，它让你可以像访问 Kotlin 属性一样访问 <code>JavaBeans</code> 类型的 <code>getters</code> 和 <code>setters</code> 方法。例如，你可以这样 <code>activity.context</code> 调用 <code>Activity.getContext()</code>，而不用写整个方法名。如果你在 Kotlin 使用传统的方式调用，lint 会给你一个警告告诉你使用「属性调用语法」。</p>
<p>这是一个很好的特性，但是有时候我的方法名以 <code>get</code> 开始，但是并不想使用「属性调用语法」。一个很常见的例子就是 Java 的原子类。如果你有一个变量 <code>val i = AtomicInteger()</code>，你可能想通过 <code>i.getAndIncrement()</code> 调用。但是 Kotlin 会想让你用 <code>i.andIncrement</code> 这种方式调用。这明显是画蛇添足。</p>
<p>你可以在每个调用的地方加上 <code>@Suppress(“UsePropertyAccessSyntax”)</code>，但很丑。如果你可以为这个函数添加一个注解告诉 linter 不要把它当做一个属性会更好。</p>
<h3 id="Method-count"><a href="#Method-count" class="headerlink" title="Method count"></a>Method count</h3><p>用 Kotlin 写代码肯定会减少你项目中的代码行数。但是它也会提高你的代码在编译以后的方法数。有很多原因导致这一点，但是其中一个主要原因就是 Kotlin 属性的实现方式。</p>
<p>和 Java 不一样，Kotlin 没有提供单独定义域的方式。你必须使用 <code>val</code> 或者 <code>var</code> 来声明变量。这样有一个好处，就是你可以随意为一个属性添加 <code>get</code> 或 <code>set</code> 方法而不会破坏其他地方对该属性引用的代码。这个特性省去了像 Java 一样定义 <code>getters</code> 和 <code>setters</code> 方法。</p>
<p>尽管如此，这个特性需要一定的成本。每一个公开的 <code>val</code> 变量都会导致 Kotlin 生成一个「支持域」和一个能被 Java 调用的 <code>getter</code> 方法。每一个公开的 <code>var</code> 变量都会生成 <code>getter</code> 和 <code>setter</code> 方法。庆幸的是，私有属性的 <code>getters</code> 和 <code>setters</code> 会生成域而不是生成方法。如果你之前的 Java 代码中定义了大量的公开域（这在定义常量的时候很常见），你会惊奇的发现方法大幅上升。</p>
<p>如果你的 Android 应用快接近方法数限制了，我建议你为不需要自定义 <code>getter</code> 方法的常量加上 <code>@JvmField</code> 注解。这样会阻止  <code>getters</code> 方法的生成，从而减少你的方法数。「更新：Kirill Rakhman 在评论中指出，你可以使用 <code>const</code> 修饰符替代 </p>
<p>不过其实没有那么糟。就像我在 <a href="https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6" target="_blank" rel="external">converting an app to 100% Kotlin</a> 文章里讨论过的，Kotlin 的标准库非常小，并且能够替代 Java 的许多常用库，这些库通常都更大，现在你再也不需要他们了。多亏了 Kotlin 的标准库，在从 Java 全部转换到 Kotlin 以后方法数反而减少了。只要你控制不会出现大范围的方法数提升，就不会有什么问题。</p>
<h2 id="The-Ugly"><a href="#The-Ugly" class="headerlink" title="The Ugly"></a>The Ugly</h2><p>最后，Kotlin 有两个设计我不是很认同，而且我不期望这个在未来会有什么改变。</p>
<h3 id="SAM-conversion-and-Unit-returning-lambdas"><a href="#SAM-conversion-and-Unit-returning-lambdas" class="headerlink" title="SAM conversion and Unit returning lambdas"></a>SAM conversion and Unit returning lambdas</h3><p>这真是一个莫名其妙的设计。</p>
<p>可以嵌入 lambda 表达式是 Kotlin 最好的特性之一。如果有一个 Java 函数，它只有一个 SAM 接口（只有一个抽象方法的接口）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void registerCallback(View.OnClickListener r)</div></pre></td></tr></table></figure>
<p>无论是 Java 还是 Kotlin，你都可以传递一个普通的 lambda 表达式去调用它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Java</div><div class="line">registerCallback(() -&gt; &#123; /** do stuff */ &#125;)</div><div class="line">//Kotlin</div><div class="line">registerCallback &#123; /** do stuff */ &#125;</div></pre></td></tr></table></figure>
<p>这的确很棒。但当你尝试去用 Kotlin 去定义类似的方法是莫名的困难。从 Java 测调用没有什么不同，但是当从 Kotlin 调用时需要明确指定类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun registerCallback(r: View.OnClickListener)</div><div class="line">// Kotlin. Note that parenthesis are required now.</div><div class="line">registerCallback(View.OnClickListener &#123; /** do stuff */ &#125;)</div></pre></td></tr></table></figure>
<p>不得不说这很烦人，特别是当你从 Java 代码转换到 Kotlin 从而导致 Kotlin 代码不能再正常运行的时候。</p>
<p>常见的方式是用函数类型定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun registerCallback(r: () -&gt; Unit)</div></pre></td></tr></table></figure>
<p> 这样用 Kotlin 调用起来会很方便，但是由于所有的 Kotlin 函数都需要一个返回值，这导致用 Java 调用该函数的时候变得很糟。你不得不显式地从 Java 表达式返回 <code>Unit</code>，这导致 lambda 表达式不可用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> registerCallback(() -&gt; &#123;</div><div class="line">    /** do stuff */</div><div class="line">    return Unit.INSTANCE;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如果你在用 Kotlin 写库的话，根本找不到一个好的方式去实现一个高阶函数同时让 Java 和 Kotlin 都能方便的调用。在我的 <a href="https://github.com/ajalt/flexadapter" target="_blank" rel="external">FlexAdapter</a> 库里面，我尝试为为每个方法重载 <code>SAM interface</code> 或者 Kotlin 函数类型的参数。这样无论用这两种的哪种语言调用都很方便，但是库的 API 变得不简洁。</p>
<p>希望 Kotlin 的设计者们能够改变他们的想法在将来允许 <code>SAM</code> 转化成 Kotlin 的函数定义，但是我并不抱什么希望。</p>
<h3 id="Closed-by-default"><a href="#Closed-by-default" class="headerlink" title="Closed by default"></a>Closed by default</h3><p>到目前为止我说的所有关于 Kotlin 的缺点基本都是小的语法细节上的不简洁，并不是什么大事。但是，有一个设计在将来有可能导致巨大的痛苦：所有的类和方法默认都是封闭的。这种做法是被 <code>Effective Java</code> 里所推崇的，理论上听起来也很有道理，但对于任何一个需要使用一个有缺陷的第三方库的人来说都是一个坏的选择。</p>
<blockquote>
<p>把所有的叶类都设置成静态的。毕竟你在完成这样一个项目——没有人能够通过扩展你的类的方式来完善你的工作成果。或许是由于安全原因——毕竟，<code>java.lang.String</code> 是 <code>final</code> 不就是由于这个原因吗？如果你项目的其他的成员向你抱怨，就告诉他们这样能提高执行效率——<a href="http://www.mindprod.com/jgloss/unmaindesign.html" target="_blank" rel="external"><em>Roedy Green, How to Write Unmaintainable Code</em></a></p>
</blockquote>
<p>Kotlin 的文档里面的确有文章尝试去抵制这一决定，所以我把他们说的三个理由列出来。</p>
<h3 id="“Best-practices-say-that-you-should-not-allow-these-hacks-anyway”"><a href="#“Best-practices-say-that-you-should-not-allow-these-hacks-anyway”" class="headerlink" title="“Best practices say that you should not allow these hacks anyway”"></a>“Best practices say that you should not allow these hacks anyway”</h3><p>关于对继承封闭的论据基本是围绕「Fragile Base Class Problem」展开，它认为如果允许在你的库的基础上继承出子类，他们可能改变代码运行的方式从而导致一些 bug。然而这只是一种可能性，会导致库运行异常从而导致 bug 的方式实在太多了。如果你重写一个类的功能，很明显你应该为破坏代码的运行负责。</p>
<p>我之所以用「很明显」是因为重写一个库的功能是很明确的该有使用方自己负责。我已经辅导计算机科学学生很多年了，他们会范所有你能想象到的错误，但是他们从不会因为重载一个方法导致的破坏感到奇怪。实在有太多不经意的方式会导致对依赖库使用的破坏，例如你传递的参数类型是对的但单位却传错了，或者你忘了调用一个必须调用的方法。</p>
<p>我欣赏那种减少代码被破坏可能性的编码方式，把类设置成不可变的的确能达到效果。但可以确定的是所有依赖库一定不是完整的或者是存在缺陷的，你又不可避免的要使用这些依赖库。为了修改一个封闭类，人们常常会使用一些 hack 的方法，这经常会仅仅是重写一两个类或者方法带来的 bug 更多。如果你不相信我说的话，这里有一个活生生的例子，如果你是一个 Android 开发者的话，你应该印象深刻：</p>
<p>AppCompat 23.2.0 终于把 <a href="https://plus.google.com/+AndroidDevelopers/posts/iTDmFiGrVne" target="_blank" rel="external">VectorDrawables</a> 加到 support 包里了。由于可以帮助减少 APK 的体积和内存的占用，要不是它有一个 bug <a href="https://code.google.com/p/android/issues/detail?id=205236" target="_blank" rel="external">会导致在 Activity 里面导致内存泄露</a><br>，本应该收到广泛欢迎。这个支持包在 <a href="https://plus.google.com/+AndroidDevelopers/posts/iTDmFiGrVne" target="_blank" rel="external">几周后被移除</a>。</p>
<p>内存泄露是怎么导致的呢？为了 <a href="https://medium.com/@chrisbanes/appcompat-v23-2-age-of-the-vectors-91cbafa87c88" target="_blank" rel="external">提高 VectorDrawable 填充性能</a>，这个支持包的作者们需要改进 <code>Context.getDrawable</code> 的实现。但是这个方法是不可变的（final），所以他们不得不为每一个视图创建一份 <code>Resources wrapper</code> 的拷贝来处理 <em>VectorDrawables</em>。且不说这带来了大量的工作，这也导致大量的 <code>wrapped Resources</code> 变得不同步和为了复制产生的大量内存开销。如果那个方法不是不可变的，他们就不会这样胡搞了。</p>
<h3 id="“People-successfully-use-other-languages-C-C-that-have-similar-approach”"><a href="#“People-successfully-use-other-languages-C-C-that-have-similar-approach”" class="headerlink" title="“People successfully use other languages (C++, C#) that have similar approach”"></a>“People successfully use other languages (C++, C#) that have similar approach”</h3><p>人们在 Python 这样的语言可以在任何时候做任何修改。Python 也有像 <code>_asdict</code> 这样「非公有」不会在文档里描述的方法。它也有像 <code>__intern</code> 这样的 <a href="https://zh.wikipedia.org/wiki/Visual_C%2B%2B%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0" target="_blank" rel="external">name mangled</a> 的函数，很难被发现。你可以自由的用 monkey-patch 或者重写任何一个你想重写的方法，Python 并不禁止这样做。</p>
<p>在我五年全职开发 Python 的期间，我从没有想过谁会通过重写方法破坏我的代码。我能想象在大多数情况下，用正确安全的方法去改变一个私有方法比由于 Python 的禁止而不得不重新实现一个同样的功能更加节约时间。</p>
<p>我并不是说要盲目地把每个类的实现都要改一遍，但是没有理由当我想这么做的时候却做不了。在 Python 社区里面有一句俗语 “We’re all consenting adults here”。你想对我的类做任何修改都可以。</p>
<h3 id="“If-people-really-want-to-hack-there-still-are-ways-you-can-always-write-your-hack-in-Java-and-call-it-from-Kotlin-see-Java-Interop-and-Aspect-frameworks-always-work-for-these-purposes”"><a href="#“If-people-really-want-to-hack-there-still-are-ways-you-can-always-write-your-hack-in-Java-and-call-it-from-Kotlin-see-Java-Interop-and-Aspect-frameworks-always-work-for-these-purposes”" class="headerlink" title="“If people really want to hack, there still are ways: you can always write your hack in Java and call it from Kotlin (see Java Interop), and Aspect frameworks always work for these purposes”"></a>“If people really want to hack, there still are ways: you can always write your hack in Java and call it from Kotlin (see Java Interop), and Aspect frameworks always work for these purposes”</h3><p>这真是一个荒诞的论点。即使是用 Java 如果你不用很难令人接受的反射的话，你依然不能重写封闭的 Kotlin 函数，所以这个论调无足轻重。</p>
<p>不能对依赖库进行扩展意味着想要添加任何新的特性和修改 bug 都很难。现实中，大多数库都需要使用一些黑客的手段。这就是现实，而且不会改变。任何库的作者都不能预测所有用户可能碰到的场景。所有的类都是不可变的只能让库的使用者实现库本身没有的功能的时候变得更加困难。相对于 Kotlin 其他语言特性的便利性，这个设计实在是太令人费解了。</p>
<p>如果你在编写一个 Kotlin 的依赖库，请把你所有的公开方法都设置成开放的。这会让你的用户更加方便。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Kotlin 是一门非常棒的语言。它比 Java 简洁多了，它还有一个非常优秀的标准库，有了这个标准库你就可以将大量为了维持 Java 勉强可用下去的库都删掉了。多亏了代码自动转换功能，你可以很方便的把 Java 代码转换成 Koltin 代码，并且这个功能会越来越完善。如果你是一名 Android 开发者，你真应该去试一试。</p>
<p>原文链接：<a href="http://ohmerhe.com/2016/08/27/kotlin_good_bad_bugly/" target="_blank" rel="external">Kotlin：The Good, The Bad, and The Ugly(译)</a></p>
<p>英文原文：<a href="https://medium.com/keepsafe-engineering/kotlin-the-good-the-bad-and-the-ugly-bf5f09b87e6f#.s0t91g9xn" target="_blank" rel="external">Kotlin: The Good, The Bad, and The Ugly</a></p>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>[1]</strong> In the case of a <em>lateinit </em>property,<em>kotlin.UninitializedPropertyAccessException </em>will be thrown, where the<em>Delegates.notNull </em>will throw an <em>IllegalStateException</em>.</li>
<li><strong>[2]</strong> There are some details about <em>lateinit </em>that are worth noting, especially if you plan on accessing a <em>lateinit </em>property from Java code. First is that <em>lateinit</em>cannot be applied to primitive types such as <em>Int </em>or <em>Double</em>. The second is that a <em>lateinit </em>property is backed by a field with the same visibility as the property, and this field is visible from Java. Additionally, that backing field can be freely set to null from Java. If any of those are issues for your use case, <em>Delegates.notNull </em>may be a better choice.</li>
<li><strong>[3]</strong> The lazy <em>Sequence </em>operators can outperform the eager versions by up to 20%, but only once list sizes start growing very large. For lists under a megabyte or so in size, the lazy versions often perform the same or worse than the eager versions.</li>
<li><strong>[4]</strong> This is a bit of a simplification. Kotlin will only generate a backing field if you don’t define a get function, or if the defined get function doesn’t reference the implicit<em> field </em>identifier.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tags: Kotlin, Android&lt;/p&gt;
&lt;p&gt;在我的 &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇文章&lt;/a&gt;, 谈到了关于转换 Java 到 Kotlin 代码和我喜欢的一些库。现在，我想要谈谈关于 Kotlin 这门语言本身的想法，还有它和 Java 交互的方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 一个扩展函数，从此丢掉 ViewHolder</title>
    <link href="http://yoursite.com/2016/08/02/kotlin_one_method_no_viewholder/"/>
    <id>http://yoursite.com/2016/08/02/kotlin_one_method_no_viewholder/</id>
    <published>2016-08-02T15:57:49.000Z</published>
    <updated>2017-05-19T16:03:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>tags: Android, Kotlin</p>
<h2 id="ViewHolder"><a href="#ViewHolder" class="headerlink" title="ViewHolder"></a>ViewHolder</h2><p>作为一名 Android 开发者，对 ViewHolder 应该再熟悉不过了。ViewHolder 一开始并不是 Android 原生提供的（现在已经是 RecycleView 的默认实现了），而是 Google 为了提高 ListView 的使用性能，为开发者提供的一种最佳实践，具体可以参考 <a href="https://developer.android.com/training/improving-layouts/smooth-scrolling.html#ViewHolder" target="_blank" rel="external">ViewHolder</a>。</p>
<a id="more"></a>
<p>Google 提供的 ViewHolder 的标准实现如下，熟悉者可以直接跳到下个部分「ViewHolder变种」继续阅读。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</div><div class="line">  TextView text;</div><div class="line">  TextView timestamp;</div><div class="line">  ImageView icon;</div><div class="line">  ProgressBar progress;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 Item 第一次创建视图的时候，填充 ViewHolder 并且将其保存在视图中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ViewHolder holder = <span class="keyword">new</span> ViewHolder();</div><div class="line">holder.icon = (ImageView) convertView.findViewById(R.id.listitem_image);</div><div class="line">holder.text = (TextView) convertView.findViewById(R.id.listitem_text);</div><div class="line">holder.timestamp = (TextView) convertView.findViewById(R.id.listitem_timestamp);</div><div class="line">holder.progress = (ProgressBar) convertView.findViewById(R.id.progress_spinner);</div><div class="line">convertView.setTag(holder);</div></pre></td></tr></table></figure>
<p>在填充 Item 数据的时候，直接使用 Viewholder 对象的属性，这样可以减少在滚动 ListView 频繁调用 <code>findViewById()</code> 而导致的性能问题。</p>
<h2 id="ViewHolder变种"><a href="#ViewHolder变种" class="headerlink" title="ViewHolder变种"></a>ViewHolder变种</h2><p>Google 提供的 ViewHolder 的确能够提升 ListView 的使用效率，但是 ViewHolder 的实现相对繁琐，需要为每一种 Item 定义一个 ViewHolder，对代码书写和维护都是额外的开销。于是有人针对 ViewHolder 的实现做了一些优化，让 ViewHolder 写起来更方便。网上有很多种写法，我最认可的是下面的这种实现，简单优雅。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class ViewHolder &#123;    </div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)  </div><div class="line">    public static &lt;T extends View&gt; T get(View view, int id) &#123;  </div><div class="line">        SparseArray&lt;View&gt; viewHolder = (SparseArray&lt;View&gt;) view.getTag();  </div><div class="line">        if (viewHolder == null) &#123;  </div><div class="line">            viewHolder = new SparseArray&lt;View&gt;();  </div><div class="line">            view.setTag(viewHolder);  </div><div class="line">        &#125;  </div><div class="line">        View childView = viewHolder.get(id);  </div><div class="line">        if (childView == null) &#123;  </div><div class="line">            childView = view.findViewById(id);  </div><div class="line">            viewHolder.put(id, childView);  </div><div class="line">        &#125;  </div><div class="line">        return (T) childView;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用 <code>SparseArray</code> 映射每个视图 <code>id</code> 和对应的视图，并将其保存在视图中，这样既保证在滚动过程中频繁获取视图的效率，使用起来也极其方便。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ImageView bananaView = ViewHolder.get(convertView, R.id.banana);  </div><div class="line">TextView phoneView = ViewHolder.get(convertView, R.id.phone);  </div><div class="line">BananaPhone bananaPhone = getItem(position);  </div><div class="line">phoneView.setText(bananaPhone.getPhone());</div></pre></td></tr></table></figure>
<h2 id="Kotlin-扩展函数"><a href="#Kotlin-扩展函数" class="headerlink" title="Kotlin 扩展函数"></a>Kotlin 扩展函数</h2><p>这里Kotlin 实现 ViewHolder 的扩展函数和上面的变种使用的同一种思路，但得益于 Kotlin 语言提供的特性，实现和使用起来更加方便流畅，甚至都感觉不到 ViewHolder 这种特殊机制的存在。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : View&gt;</span> View.<span class="title">findViewOften</span><span class="params">(viewId: <span class="type">Int</span>)</span></span>: T &#123;</div><div class="line">    <span class="keyword">var</span> viewHolder: SparseArray&lt;View&gt; = tag <span class="keyword">as</span>? SparseArray&lt;View&gt; ?: SparseArray()</div><div class="line">    tag = viewHolder</div><div class="line">    <span class="keyword">var</span> childView: View? = viewHolder.<span class="keyword">get</span>(viewId)</div><div class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == childView) &#123;</div><div class="line">        childView = findViewById(viewId)</div><div class="line">        viewHolder.put(viewId, childView)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> childView <span class="keyword">as</span> T</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里实现了一个 View 的扩展函数 <code>findViewOften(viewId: Int)</code> 意味着在需要频繁寻找一个视图的子视图的情况下使用，这样我们在 Item 中就可以这样写了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val subTitle: TextView = convertView.findViewOften(R.id.list_item_subtitle)</div><div class="line">subTitle.text = itemData.subTitle</div></pre></td></tr></table></figure>
<p>由于 Kotlin 提供类型推断功能，所以 <code>findViewOften</code> 的返回值不用手动转换或者手动指定泛型类型。</p>
<p>利用 Kotlin 的语言特性，为 View 扩展一个方法，从此再也不用繁琐的定义 Viewholder 了，使用的时候也是如此的顺畅，从此再也不必记得什么 ViewHolder 了。</p>
<p>PS: 该方法在 <a href="https://github.com/KotlinThree/AndroidExtension" target="_blank" rel="external">AndroidExtension</a> 已经提供封装，这个库里面还封装了一些其他方法，也蛮好用的，不过这个库还没有正式发布。</p>
<h2 id="RecycleView-的-ViewHolder"><a href="#RecycleView-的-ViewHolder" class="headerlink" title="RecycleView 的 ViewHolder"></a>RecycleView 的 ViewHolder</h2><p>最后，不得不提一下在 RecycleView 应该怎么办，因为在 RecycleView 的机制里面，在创建 Item 的 View 的时候，必须创建一个 RecyclerView.ViewHolder 并且返回。对于我们上面那么完美的封装， Google 这明显是在帮倒忙，还好这忙虽然帮倒了，不过还不至于无法挽回。</p>
<p>如果大家在使用 RecycleView 还想使用本文提供的方法的话，可以参考我下面的方式实现。提供一个 RecyclerView.ViewHolder 默认实现类，该类提供一个通过 <code>id</code> 获取视图的方法，在创建 Item 的 View 的时候默认都返回这个类的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class MyViewHolder(val convertView: View) : RecyclerView.ViewHolder(convertView) &#123;</div><div class="line">    	fun &lt;T : View&gt; findView(viewId: Int): T &#123;</div><div class="line">        return convertView.findViewOften(viewId)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不想 <code>MyViewHolder</code> 的外部有不需要的依赖，可以将 <code>findViewOften</code> 直接实现在 <code>MyViewHolder</code> 里面。</p>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.android.com/training/improving-layouts/smooth-scrolling.html#ViewHolder" target="_blank" rel="external">ViewHolder</a></li>
<li><a href="http://www.programcreek.com/java-api-examples/android.util.SparseArray" target="_blank" rel="external">Java Code Examples for android.util.SparseArray</a></li>
<li><a href="https://github.com/KotlinThree/AndroidExtension" target="_blank" rel="external">AndroidExtension</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tags: Android, Kotlin&lt;/p&gt;
&lt;h2 id=&quot;ViewHolder&quot;&gt;&lt;a href=&quot;#ViewHolder&quot; class=&quot;headerlink&quot; title=&quot;ViewHolder&quot;&gt;&lt;/a&gt;ViewHolder&lt;/h2&gt;&lt;p&gt;作为一名 Android 开发者，对 ViewHolder 应该再熟悉不过了。ViewHolder 一开始并不是 Android 原生提供的（现在已经是 RecycleView 的默认实现了），而是 Google 为了提高 ListView 的使用性能，为开发者提供的一种最佳实践，具体可以参考 &lt;a href=&quot;https://developer.android.com/training/improving-layouts/smooth-scrolling.html#ViewHolder&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ViewHolder&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>NullPointException 利器 Kotlin 可选型</title>
    <link href="http://yoursite.com/2016/07/14/kotlin-type-option/"/>
    <id>http://yoursite.com/2016/07/14/kotlin-type-option/</id>
    <published>2016-07-14T10:52:57.000Z</published>
    <updated>2017-05-19T15:57:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>tags: Kotlin</p>
<p>NullPointException (简称 NPE ) 被称作 <a href="https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions" target="_blank" rel="external">The Billion Dollar Mistake</a> 一直困扰着Java 和 Android 开发者。Kotlin 的类型系统中提供可选类型用于减少 NPE 问题带来的风险。</p>
<a id="more"></a>
<p>虽然，Kotlin 提供了可选类型用于减少 NPE 问题的风险，但是并没有办法完全消除 NPE 带来的隐患，本问将探讨如何巧妙地使用「可选型」更好的规避 NPE 的发生。</p>
<h2 id="可选型定义"><a href="#可选型定义" class="headerlink" title="可选型定义"></a>可选型定义</h2><h3 id="非空类型"><a href="#非空类型" class="headerlink" title="非空类型"></a>非空类型</h3><p>我们先从可选型的定义开始，当我们在 Kotlin 中定义一个变量时，默认就是非空类型的，当你将一个非空类型置空的时候，编译器会告诉你这不可行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a: String = <span class="string">"abc"</span></div><div class="line">a = <span class="literal">null</span> <span class="comment">// compilation error</span></div></pre></td></tr></table></figure>
<p>因此，如果你后面任何时候使用该变量时，都可以放心的使用而不用担心会发生 NPE。所以要想远离 NPE，首先需要<strong>「尽可能的使用非空类型的定义」</strong>。</p>
<h3 id="可选型（可空类型）"><a href="#可选型（可空类型）" class="headerlink" title="可选型（可空类型）"></a>可选型（可空类型）</h3><p>虽然「非空类型」能够有效避免 NPE 的问题，但是有时候我们总不可避免的需要使用「可选类型」。在定义可选型的时候，我们只要在非空类型的后面添加一个 <code>?</code> 就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b: String? = <span class="string">"abc"</span></div><div class="line">b = <span class="literal">null</span> <span class="comment">// ok</span></div></pre></td></tr></table></figure>
<p>在使用可选型变量的时候，这个变量就有可能为空，所以在使用前我们应该对其进行空判断（在 Java 中我们经常这样做），这样往往带来带来大量的工作，这些空判断代码本身没有什么实际意义，并且让代码的可读性和简洁性带来了巨大的挑战。在网上可以看到许多人针对如何减少 NPE 提出了自己的建议，有的的确很不错，但成本依然很大。除此之外，还有一个最可恶的场景「我们会忘记」。</p>
<p>Kotlin 为了解决这个问题，它并不允许我们直接使用一个可选型的变量去调用方法或者属性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l = b.length <span class="comment">// compilation error</span></div></pre></td></tr></table></figure>
<p>你可以和 Java 中一样，在使用变量之前先进行空判断，然后再去调用。如果使用这种方法，那么空判断是必须的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l = <span class="keyword">if</span> (b != <span class="literal">null</span>) b.length <span class="keyword">else</span> <span class="number">-1</span></div></pre></td></tr></table></figure>
<p><strong>注意： 如果你定义的变量是全局变量，即使你做了空判断，依然不能使用变量去调用方法或者属性。</strong>这个时候你需要考虑使用下面的介绍的方法。</p>
<p>Kotlin 为可选型提供了一个安全调用操作符 <code>?.</code>，使用该操作符可以方便调用可选型的方法或者属性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l = b?.length</div></pre></td></tr></table></figure>
<p>这里 <code>l</code> 得到的返回依然是一个可选型 <code>Int?</code>。</p>
<p>Kotlin 还提供了一个强转的操作符 <code>!!</code>，这个操作符能够强行调用变量的方法或者属性，而不管这个变量是否为空，如果这个时候该变量为空时，那么就会发生 NPE。所以如果不想继续陷入 NPE 的困境无法自拔，请不要该操作符走的太近。</p>
<h2 id="Elvis-操作符"><a href="#Elvis-操作符" class="headerlink" title="Elvis 操作符"></a><code>Elvis</code> 操作符</h2><p>上面有提到一种情况，当 <code>b</code> 为空时，返回它的长度值给一个默认值 -1。要实现这样的逻辑当然可以用 <code>ifelse</code> 的逻辑判断实现，但 Kotlin 提供了一个更优雅的书写方式 <code>?:</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l = b?.length ?: <span class="number">-1</span></div></pre></td></tr></table></figure>
<p><code>b?.length ?: -1</code> 和 <code>if (b != null) b.length else -1</code> 完全等价的。</p>
<p>其实你还可以在 <code>?:</code> 后面添加任何表达式，比如你可以在后面会用 <code>return</code> 和 <code>throw</code>（在 Kotlin 中它们都是表达式）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(node: <span class="type">Node</span>)</span></span>: String? &#123;</div><div class="line">  <span class="keyword">val</span> parent = node.getParent() ?: <span class="keyword">return</span> <span class="literal">null</span></div><div class="line">  <span class="keyword">val</span> name = node.getName() ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"name expected"</span>)</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="let-函数"><a href="#let-函数" class="headerlink" title="let 函数"></a><code>let</code> 函数</h2><p><code>let</code> 是官方 <code>stdlib</code> 提供的标准函数库里面的函数，这个函数巧妙的利用的 Kotlin 语言的特性让 <code>let</code> 接受的表达式参数中的调用方是非空的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> listWithNulls: List&lt;String?&gt; = listOf(<span class="string">"A"</span>, <span class="literal">null</span>)</div><div class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> listWithNulls) &#123;</div><div class="line">    item?.let &#123; println(it) &#125; <span class="comment">// prints A and ignores null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码的只会输出 <code>A</code>，而不会输出 <code>null</code>。</p>
<p><strong>需要注意的是，这个方法调用的时候必须要使用 <code>?.</code> 操作符调用才能生效哦。</strong>如果你的部分代码依赖于一个可选型变量为非空的时候，就可以使用 <code>let</code> 函数。</p>
<p>参考这个函数的实现，下面我尝试提供几个自己定义的方法。</p>
<h2 id="自定义处理"><a href="#自定义处理" class="headerlink" title="自定义处理"></a>自定义处理</h2><p>这里定义的两个方法是参考 <code>Swift</code> 里面的 <code>if let</code> 和 <code>guard</code> 进行的抽象。</p>
<h3 id="orElse-函数"><a href="#orElse-函数" class="headerlink" title="orElse 函数"></a><code>orElse</code> 函数</h3><p><code>orElse</code> 是和 <code>Elvis</code> 函数结合使用的，默认 <code>Elvis</code> 后面只能直接或者执行一个表达式获取返回值或者直接通过 <code>return</code> 或者 <code>throw</code> 结束当前函数的执行。结合 <code>orElse</code> 函数，你能够更加灵活的处理前面的 <code>null</code>。</p>
<ul>
<li>你可以处理一些逻辑以后，再返回一个可用的值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a:String? = <span class="literal">null</span></div><div class="line"><span class="keyword">var</span> b = a ?: orElse &#123;</div><div class="line">	<span class="comment">// 做任何事</span></div><div class="line">   <span class="keyword">return</span><span class="symbol">@orElse</span> <span class="string">"s"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>也可以处理一些逻辑后， 通过<code>return</code> 或者 <code>throw</code> 结束当前函数的执行。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a:String? = <span class="literal">null</span></div><div class="line"><span class="keyword">var</span> b = a ?: orElse &#123;</div><div class="line">	<span class="comment">// 做任何事</span></div><div class="line">   <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="guard-函数"><a href="#guard-函数" class="headerlink" title="guard 函数"></a><code>guard</code> 函数</h3><p><code>Elvis</code> 默认只能对单个变量或表达式是否为空进行处理，当碰到多个变量需要一起判断时，就会束手无策，<code>guard</code> 就是为了解决这个问题。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fun testGuard(a: String?, b: String?, c: String?)&#123;</div><div class="line">	guard(a, b, c) ?: orElse &#123;</div><div class="line">        print("a or b or c is null </div><div class="line">")</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    // 现在 `a`，`b`，`c` 都是不为空</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于没有编译器的支持，所以暂时还不能实现 <a href="https://kotlinlang.org/docs/reference/null-safety.html#checking-for-null-keyword--in-conditions" target="_blank" rel="external">空屏蔽</a>。</p>
<p>这里定义的两个函数的实现，你可以自己尝试去实现一下，就当是个练习（鬼笑）。<a href="https://github.com/KotlinThree/AndroidExtension" target="_blank" rel="external">AndroidExtension</a>有具体的实现代码。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过一系列分析以后，我们已经对怎么使用好 Kotlin 可选型有一定的了解，如果不想 NPE 问题不断困扰，可以参考这里总结的几条。</p>
<ul>
<li>尽可能的使用非空类型的定义</li>
<li>远离 <code>!!</code>，如果非要用，请调用代码在前面「三行之内」进行非空判断</li>
<li>熟练使用 <code>Elvis</code> 操作符</li>
<li>自定义一些常用的函数，让自己的代码更流畅</li>
</ul>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://kotlinlang.org/docs/reference/null-safety.html" target="_blank" rel="external">null-safety</a></li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0056-trailing-closures-in-guard.md" target="_blank" rel="external">trailing-closures-in-guard</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tags: Kotlin&lt;/p&gt;
&lt;p&gt;NullPointException (简称 NPE ) 被称作 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The Billion Dollar Mistake&lt;/a&gt; 一直困扰着Java 和 Android 开发者。Kotlin 的类型系统中提供可选类型用于减少 NPE 问题带来的风险。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 函数式编程三板斧</title>
    <link href="http://yoursite.com/2016/07/05/kotlin_function_three_common_methods/"/>
    <id>http://yoursite.com/2016/07/05/kotlin_function_three_common_methods/</id>
    <published>2016-07-05T14:06:41.000Z</published>
    <updated>2017-05-19T16:03:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>tags: kotlin, 函数式编程, map, filter, reduce</p>
<p>每个函数式语言都提供及几大类基本函数，这些函数在功能上一般都极为相似，但是在名称和调用方法上可能有一些细微的差别。今天就讲讲 <code>Kotlin</code> 中提供的函数式编程三板斧<code>filter</code>、<code>map</code>、<code>reduce</code>。</p>
<a id="more"></a>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>筛选函数将用户给定的布尔逻辑作用于集合，返回由原集合中符合条件的元素组合的一个子集。假设一个逻辑，将数组中是3的倍数的数筛选出来，和 <code>Java</code> 做一个简单的对比。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java 代码</span></div><div class="line"><span class="keyword">int</span>[] all = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</div><div class="line">List&lt;Integer&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a : all) &#123;</div><div class="line">    <span class="keyword">if</span> (a % <span class="number">3</span> == <span class="number">0</span>) &#123;</div><div class="line">        filters.add(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Kotlin 代码</span></div><div class="line"><span class="keyword">val</span> all = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</div><div class="line"><span class="keyword">val</span> filters = all.filter &#123; it % <span class="number">3</span> == <span class="number">0</span> &#125;</div></pre></td></tr></table></figure>
<p>Kotlin 还提供一系列类似的过滤函数：</p>
<ul>
<li><code>filterIndexed</code>, 同 <code>filter</code>，不过在逻辑判断的方法块中可以拿到当前item的index</li>
<li><code>filterNot</code>，与<code>filter</code>相反，只返回不符合条件的元素组合</li>
</ul>
<p>针对 <code>Map</code> 类型数据集合，提供了 <code>filterKeys</code> 和 <code>filterValues</code> 方法，方便只做 key 或者 value 的判断。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>映射函数也是一个高阶函数，将一个集合经过一个传入的变换函数映射成另外一种集合。</p>
<p>假设我们现在需要将一系列的名字的长度保存到另一个数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java 代码</span></div><div class="line">String[] names = &#123;<span class="string">"James"</span>, <span class="string">"Tom"</span>, <span class="string">"Jack"</span>, <span class="string">"Kobe"</span>&#125;;</div><div class="line"><span class="keyword">int</span>[] namesLength = <span class="keyword">new</span> <span class="keyword">int</span>[names.length];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.length ; i ++) &#123;</div><div class="line">    namesLength[i] = names[i].length();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Kotlin 代码</span></div><div class="line"><span class="keyword">val</span> names = arrayOf(<span class="string">"James"</span>, <span class="string">"Tom"</span>, <span class="string">"Jack"</span>, <span class="string">"Kobe"</span>);</div><div class="line"><span class="keyword">val</span> namesLength = names.map &#123; it.length &#125;</div></pre></td></tr></table></figure>
<p>映射函数是将一个集合映射成另外一种集合，所以当你需要见一个 HaspMap 映射成一个 List 的时候，会非常方便。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> params = mapOf(<span class="string">"limit"</span> to <span class="string">"10"</span>, <span class="string">"offset"</span> to <span class="string">"20"</span>, <span class="string">"order"</span> to <span class="string">"asc"</span>)</div><div class="line"><span class="keyword">val</span> s = params.map &#123; <span class="string">"<span class="subst">$&#123;it.key&#125;</span>=<span class="subst">$&#123;it.value&#125;</span>"</span> &#125;.joinToString(<span class="string">"&amp;"</span>)</div><div class="line"><span class="comment">// s = limit=10&amp;offset=20&amp;order=asc</span></div></pre></td></tr></table></figure>
<p>同 <code>filter</code> 相似，Kotlin 也提供的 <code>mapIndexed</code> 的类似方法方便使用，针对 <code>Map</code> 类型的集合也有 <code>mapKeys</code> 和 <code>mapValues</code> 的封装。</p>
<h2 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h2><p>归纳函数将一个数据集合的所有元素通过传入的操作函数实现数据集合的积累叠加效果。</p>
<p>假设我们需要将一首藏头诗的每句诗的第一句拿出来拼成一句话。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java 代码</span></div><div class="line">String[] texts = &#123;<span class="string">"芦花丛中一扁舟"</span>, <span class="string">"俊杰俄从此地游"</span>, <span class="string">"义士若能知此理"</span>, <span class="string">"反躬难逃可无忧"</span>&#125;;</div><div class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; texts.length ; i ++) &#123;</div><div class="line">    sb.append(texts[i].substring(<span class="number">0</span>, <span class="number">1</span>));</div><div class="line">&#125;</div><div class="line">String result = sb.toString();</div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Kotlin 代码</span></div><div class="line"><span class="keyword">val</span> texts = arrayOf(<span class="string">"芦花丛中一扁舟"</span>, <span class="string">"俊杰俄从此地游"</span>, <span class="string">"义士若能知此理"</span>, <span class="string">"反躬难逃可无忧"</span>)</div><div class="line"><span class="keyword">val</span> result = texts.map &#123; it.substring(<span class="number">0</span>,<span class="number">1</span>) &#125;.reduce &#123; r, s -&gt; <span class="string">"<span class="subst">$r</span><span class="subst">$s</span>"</span>&#125;</div></pre></td></tr></table></figure>
<p>最后得到的结果是「卢俊义反」。</p>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程的精髓在于函数本身。在函数式编程中函数是第一等公民，与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p>
<p>函数式编程好的实践在于对运算过程的高度抽象和没有”副作用”（既保持函数的独立性），函数式编程三板斧是函数式编程的典型范式，在编程中被大量使用，即使人们不关注函数式编程，在使用函数式编程语言的时候，也会不自觉的使用这些函数。</p>
<p>函数式编程是一种思维方式，函数式编程鼓励放弃对状态的维持（是命令式编程的基础），将所有的操作都交给运行时去执行。当然为了保证程序运行的效率，这需要提供一些辅助性的手段（缓存、缓求值等）。</p>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://book.douban.com/subject/26587213/" target="_blank" rel="external">函数式编程思维</a></li>
<li><a href="http://baike.baidu.com/view/1711147.htm" target="_blank" rel="external">函数式编程</a></li>
<li><a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="external">kotlin doc</a></li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/" target="_blank" rel="external">kotlin api doc</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tags: kotlin, 函数式编程, map, filter, reduce&lt;/p&gt;
&lt;p&gt;每个函数式语言都提供及几大类基本函数，这些函数在功能上一般都极为相似，但是在名称和调用方法上可能有一些细微的差别。今天就讲讲 &lt;code&gt;Kotlin&lt;/code&gt; 中提供的函数式编程三板斧&lt;code&gt;filter&lt;/code&gt;、&lt;code&gt;map&lt;/code&gt;、&lt;code&gt;reduce&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="函数式编程" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 实现配置化网络请求</title>
    <link href="http://yoursite.com/2016/06/13/kotlin_config_http_kolley/"/>
    <id>http://yoursite.com/2016/06/13/kotlin_config_http_kolley/</id>
    <published>2016-06-13T12:23:05.000Z</published>
    <updated>2017-05-19T15:57:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin官方提供一个DSL的典型应用场景，<a href="https://github.com/Kotlin/anko" target="_blank" rel="external">Anko</a>致力直接用Kotlin配置页面布局和视图的属性。将布局文件代码化能够带来许多如类型安全、解析效率、代码重用等好处，而<code>Anko</code>让代码布局和XML一样简洁清晰。</p>
<a id="more"></a>
<p>受到<code>Anko</code>的启发，让我萌生了把<code>Android</code>中网络请求纷繁复杂配置信息也封装成配置化方式，实现如下方式的网络请求。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Http.<span class="keyword">get</span> &#123;</div><div class="line">    url = <span class="string">"http://api.openweathermap.org/data/2.5/weather"</span></div><div class="line">    headers &#123;</div><div class="line">        <span class="string">"Content-Type"</span> - <span class="string">'application/json'</span></div><div class="line">        <span class="string">"pragma-token"</span> - <span class="string">'33162acxxxxxx5032ad21e0e79ff70d'</span></div><div class="line">    &#125;</div><div class="line">    params &#123;</div><div class="line">        <span class="string">"q"</span> - <span class="string">"shanghai"</span></div><div class="line">        <span class="string">"appid"</span> - <span class="string">"d7a98cf22463b1c0c3df4adfe5abbc77"</span></div><div class="line">    &#125;</div><div class="line">    onSuccess &#123; bytes -&gt;</div><div class="line">        <span class="comment">// handle data</span></div><div class="line">    &#125;</div><div class="line">    onFail &#123; error -&gt;</div><div class="line">        <span class="comment">// handle error</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>目前该框架已经完成，后面还会继续完善，项目地址<a href="https://github.com/ohmerhe/Kolley" target="_blank" rel="external">Kolley</a></p>
<p>奔着这个目标，我把之前自己简单封装的Volley库翻出来，用Kotlin重新封装一下。经过分析总体过程大概如下：</p>
<ul>
<li>基础代码转Kotlin</li>
<li>重定义原子Request</li>
<li>Request构造配置化</li>
<li>提供RESTful方法</li>
</ul>
<h2 id="基础代码转Kotlin"><a href="#基础代码转Kotlin" class="headerlink" title="基础代码转Kotlin"></a>基础代码转Kotlin</h2><p>之前的框架是参考<a href="https://github.com/loopj/android-async-http" target="_blank" rel="external">android-async-http</a>做的封装，用<code>okhttp</code>作为网络请求引擎，图片请求缓存模块使用的<code>jakewharton</code>提供的<code>disklrucache</code>，这两块都可以复用，先将这部分代码直接转成<code>Kotlin</code>实现。</p>
<p>这不需要花太多的功夫，将java代码复制过来以后，直接使用Android Studio的快速转换功能，转换后可能会有一些语法上的错误，稍微处理一下就可以了，得到类似的内容。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OkHttpStack</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(client: OkHttpClient = OkHttpClient()) : HurlStack() &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mFactory: OkUrlFactory</div><div class="line">    init &#123;</div><div class="line">        mFactory = OkUrlFactory(client)</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Throws(IOException::class)</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createConnection</span><span class="params">(url: <span class="type">URL</span>)</span></span>: HttpURLConnection &#123;</div><div class="line">        <span class="keyword">return</span> mFactory.<span class="keyword">open</span>(url)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重定义原子Request"><a href="#重定义原子Request" class="headerlink" title="重定义原子Request"></a>重定义原子Request</h2><p>需要在Volley提供的<code>Request</code>基础上继承一个<code>BaseRequest</code>预处理一些信息，如params。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByteRequest</span></span>(method: <span class="built_in">Int</span>, url: String, errorListener: Response.ErrorListener? = Response.ErrorListener &#123;&#125;)</div><div class="line">: BaseRequest&lt;ByteArray&gt;(method, url, errorListener) &#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseNetworkResponse</span><span class="params">(response: <span class="type">NetworkResponse</span>?)</span></span>: Response&lt;ByteArray&gt;? &#123;</div><div class="line">        <span class="keyword">return</span> Response.success(response?.<span class="keyword">data</span>, HttpHeaderParser.parseCacheHeaders(response))</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseRequest</span>&lt;<span class="type">D</span>&gt;</span>(method: <span class="built_in">Int</span>, url: String, errorListener: Response.ErrorListener? = Response.ErrorListener &#123;&#125;)</div><div class="line">: Request&lt;D&gt;(method, url, errorListener) &#123;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> DEFAULT_CHARSET = <span class="string">"UTF-8"</span></div><div class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _listener: Response.Listener&lt;D&gt;? = <span class="literal">null</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> _params: MutableMap&lt;String, String&gt; = HashMap() <span class="comment">// used for a POST or PUT request.</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns a Map of parameters to be used for a POST or PUT request.</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getParams</span><span class="params">()</span></span>: MutableMap&lt;String, String&gt; &#123;</div><div class="line">        <span class="keyword">return</span> _params</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">deliverResponse</span><span class="params">(response: <span class="type">D</span>?)</span></span> &#123;</div><div class="line">        _listener?.onResponse(response)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</div><div class="line">            Log.d(<span class="keyword">this</span>.javaClass.simpleName, msg)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Request构造配置化"><a href="#Request构造配置化" class="headerlink" title="Request构造配置化"></a>Request构造配置化</h2><p>上一步封装的<code>Request</code>必须在构造器中提供一些参数，并且像<code>Listener</code>这样的参数不能直接传递表达式，为配置化调用的封装提供了一定的困难。需要重新封装一个<code>Request</code>构造器，再在最后交给执行队列的时候创建真正的<code>Request</code>传递给它，这样让所有网络请求需要的配置信息都可以很方便的构造。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseRequestWapper</span></span>() &#123;</div><div class="line">    <span class="keyword">internal</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> _request: ByteRequest</div><div class="line">    <span class="keyword">var</span> url: String = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> method: <span class="built_in">Int</span> = Request.Method.GET</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _start: (() -&gt; <span class="built_in">Unit</span>) = &#123;&#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _success: (ByteArray) -&gt; <span class="built_in">Unit</span> = &#123;&#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _fail: (VolleyError) -&gt; <span class="built_in">Unit</span> = &#123;&#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _finish: (() -&gt; <span class="built_in">Unit</span>) = &#123;&#125;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> _params: MutableMap&lt;String, String&gt; = HashMap() <span class="comment">// used for a POST or PUT request.</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> _headers: MutableMap&lt;String, String&gt; = HashMap()</div><div class="line">    <span class="keyword">var</span> tag: Any? = <span class="literal">null</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">(onStart: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        _start = onStart</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(onError: (<span class="type">VolleyError</span>)</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        _fail = onError</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(onSuccess: (<span class="type">ByteArray</span>)</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        _success = onSuccess</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onFinish</span><span class="params">(onFinish: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        _finish = onFinish</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">params</span><span class="params">(makeParam: <span class="type">RequestPairs</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        <span class="keyword">val</span> requestPair = RequestPairs()</div><div class="line">        requestPair.makeParam()</div><div class="line">        _params.putAll(requestPair.pairs)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">headers</span><span class="params">(makeHeader: <span class="type">RequestPairs</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        <span class="keyword">val</span> requestPair = RequestPairs()</div><div class="line">        requestPair.makeHeader()</div><div class="line">        _headers.putAll(requestPair.pairs)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">excute</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">var</span> url = url</div><div class="line">        <span class="keyword">if</span> (Request.Method.GET == method) &#123;</div><div class="line">            url = getGetUrl(url, _params) &#123; it.toQueryString() &#125;</div><div class="line">        &#125;</div><div class="line">        _request = ByteRequest(method, url, Response.ErrorListener &#123;</div><div class="line">            _fail(it)</div><div class="line">            _finish()</div><div class="line">        &#125;)</div><div class="line">        _request._listener = Response.Listener &#123;</div><div class="line">            _success(it)</div><div class="line">            _finish()</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (tag != <span class="literal">null</span>) &#123;</div><div class="line">            _request.tag = tag</div><div class="line">        &#125;</div><div class="line">        Http.getRequestQueue().add(_request)</div><div class="line">        _start()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getGetUrl</span><span class="params">(url: <span class="type">String</span>, params: <span class="type">MutableMap</span>&lt;<span class="type">String</span>, String&gt;, toQueryString: (<span class="type">map</span>: <span class="type">Map</span>&lt;<span class="type">String</span>, String&gt;)</span></span> -&gt;</div><div class="line">    String): String &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (params == <span class="literal">null</span> || params.isEmpty()) url <span class="keyword">else</span> <span class="string">"<span class="subst">$url</span>?<span class="subst">$&#123;toQueryString(params)&#125;</span>"</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> Map<span class="type">&lt;K, V&gt;</span>.<span class="title">toQueryString</span><span class="params">()</span></span>: String = <span class="keyword">this</span>.map &#123; <span class="string">"<span class="subst">$&#123;it.key&#125;</span>=<span class="subst">$&#123;it.value&#125;</span>"</span> &#125;.joinToString(<span class="string">"&amp;"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码中将网络请求需要的所有信息全部包装了一层，这样在调用的时候就可以很方便的逐个设置每个参数（当然会有一些默认值），最后在<code>excute()</code>方法中全部设置给真正的<code>Request</code>。这个封装保证了下面的调用方式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">url = <span class="string">"http://api.openweathermap.org/data/2.5/weather"</span></div><div class="line">params &#123;</div><div class="line">    <span class="string">"q"</span> - <span class="string">"shanghai"</span></div><div class="line">    <span class="string">"appid"</span> - <span class="string">"d7a98cf22463b1c0c3df4adfe5abbc77"</span></div><div class="line">&#125;</div><div class="line">onSuccess &#123; bytes -&gt;</div><div class="line">    <span class="comment">// handle data</span></div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>PS：上面<code>params</code>是的书写方式，使用了<code>Kotlin</code>的操作符重载功能，具体实现可以下载<a href="https://github.com/ohmerhe/Kolley" target="_blank" rel="external">源码</a>看下。</p>
<h2 id="提供RESTful方法"><a href="#提供RESTful方法" class="headerlink" title="提供RESTful方法"></a>提供RESTful方法</h2><p>实现到上一步，已经准备的差不多了，接下来还需要最后一步，提供RESTful请求方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">object</span> Http &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mRequestQueue: RequestQueue? = <span class="literal">null</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</div><div class="line">        <span class="comment">// Set up the network to use OKHttpURLConnection as the HTTP client.</span></div><div class="line">        <span class="comment">// getApplicationContext() is key, it keeps you from leaking the</span></div><div class="line">        <span class="comment">// Activity or BroadcastReceiver if someone passes one in.</span></div><div class="line">        mRequestQueue = Volley.newRequestQueue(context.applicationContext, OkHttpStack(OkHttpClient()))</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getRequestQueue</span><span class="params">()</span></span>: RequestQueue &#123;</div><div class="line">        <span class="keyword">return</span> mRequestQueue!!</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">val</span> request: (<span class="built_in">Int</span>, BaseRequestWapper.() -&gt; <span class="built_in">Unit</span>) -&gt; Request&lt;ByteArray&gt; = &#123; method, request -&gt;</div><div class="line">        <span class="keyword">val</span> baseRequest = BaseRequestWapper()</div><div class="line">        baseRequest.method = method</div><div class="line">        baseRequest.request()</div><div class="line">        baseRequest.excute()</div><div class="line">        baseRequest._request</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">val</span> post = request.partially1(Request.Method.POST)</div><div class="line">    <span class="keyword">val</span> put = request.partially1(Request.Method.PUT)</div><div class="line">    <span class="keyword">val</span> delete = request.partially1(Request.Method.DELETE)</div><div class="line">    <span class="keyword">val</span> head = request.partially1(Request.Method.HEAD)</div><div class="line">    <span class="keyword">val</span> options = request.partially1(Request.Method.OPTIONS)</div><div class="line">    <span class="keyword">val</span> trace = request.partially1(Request.Method.TRACE)</div><div class="line">    <span class="keyword">val</span> patch = request.partially1(Request.Method.PATCH)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的<code>request: (Int, BaseRequestWapper.() -&gt; Unit) -&gt; Request&lt;ByteArray&gt;</code>方法为网络请求提供了入口、保证了配置化代码都可以在<code>{}</code>中调用、完成了真正网络请求添加到执行队列。用户可以通过<code>http.requset(method){}</code>方式发起各种请求。</p>
<p><code>val get = request.partially1(Request.Method.GET)</code>等提供了RESTful方法的封装，实现<code>Http.get{}</code>的方便调用。</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>关于图片请求模块的实现，其实也是异曲同工，虽然更加复杂一点，但是具体思路是一样的。有兴趣的可以下载<a href="https://github.com/ohmerhe/Kolley" target="_blank" rel="external">源码</a>查看实现，也欢迎提交代码。</p>
<p>图片请求的方式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Image.display &#123;</div><div class="line">    url = <span class="string">"http://7xpox6.com1.z0.glb.clouddn.com/android_bg.jpg"</span></div><div class="line">    imageView = mImageView</div><div class="line">    options &#123;</div><div class="line">        <span class="comment">// these values are all default value , you do not need specific them if you do not want to custom</span></div><div class="line">        imageResOnLoading = R.drawable.default_image</div><div class="line">        imageResOnLoading = R.drawable.default_image</div><div class="line">        imageResOnFail = R.drawable.default_image</div><div class="line">        decodeConfig = Bitmap.Config.RGB_565</div><div class="line">        scaleType = ImageView.ScaleType.CENTER_CROP</div><div class="line">        maxWidth = ImageDisplayOption.DETAULT_IMAGE_WIDTH_MAX</div><div class="line">        maxHeight = ImageDisplayOption.DETAULT_IMAGE_HEIGHT_MAX</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Image.load &#123;</div><div class="line">    url = <span class="string">"http://7xpox6.com1.z0.glb.clouddn.com/android_bg.jpg"</span></div><div class="line">    options &#123;</div><div class="line">        scaleType = ImageView.ScaleType.CENTER_CROP</div><div class="line">        maxWidth = ImageDisplayOption.DETAULT_IMAGE_WIDTH_MAX</div><div class="line">        maxHeight = ImageDisplayOption.DETAULT_IMAGE_HEIGHT_MAX</div><div class="line">    &#125;</div><div class="line">    onSuccess &#123; bitmap -&gt;</div><div class="line">        _imageView2?.setImageBitmap(bitmap)</div><div class="line">    &#125;</div><div class="line">    onFail &#123; error -&gt;</div><div class="line">        log(error.toString())</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/Kotlin/anko" target="_blank" rel="external">Anko</a></li>
<li><a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="external">Kotlin Refrence</a></li>
<li><a href="https://developer.android.com/training/volley/index.html" target="_blank" rel="external">Volley</a></li>
<li><a href="http://square.github.io/okhttp" target="_blank" rel="external">OKHttp</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin官方提供一个DSL的典型应用场景，&lt;a href=&quot;https://github.com/Kotlin/anko&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Anko&lt;/a&gt;致力直接用Kotlin配置页面布局和视图的属性。将布局文件代码化能够带来许多如类型安全、解析效率、代码重用等好处，而&lt;code&gt;Anko&lt;/code&gt;让代码布局和XML一样简洁清晰。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="网络请求" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>kotlin中的语法糖</title>
    <link href="http://yoursite.com/2016/01/14/kotlin_syntactic_sugar/"/>
    <id>http://yoursite.com/2016/01/14/kotlin_syntactic_sugar/</id>
    <published>2016-01-14T05:49:44.000Z</published>
    <updated>2017-05-19T15:57:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun sum(a: Int, b: Int) = a + b</div><div class="line">	</div><div class="line">fun max(a: Int, b: Int) = if (a &gt; b) a else b</div></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// range in</div><div class="line">for (x in 1..100) </div><div class="line">	print(x)</div><div class="line">	</div><div class="line">for ((k, v) in map) &#123; </div><div class="line">	println(&quot;$k -&gt; $v&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">val list = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</div><div class="line"></div><div class="line">val a = array(1, 2, 3)</div><div class="line"></div><div class="line">val map = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2, &quot;c&quot; to 3)</div><div class="line"></div><div class="line">fun transform(color: String): Int = when (color) &#123;</div><div class="line">	&quot;Red&quot; -&gt; 0</div><div class="line">	&quot;Green&quot; -&gt; 1</div><div class="line">	&quot;Blue&quot; -&gt; 2</div><div class="line">	else -&gt; throw IllegalArgumentException(&quot;Invalid color param value&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Null安全, user为null也不会报NullPointException</div><div class="line">val name = user?.name ?: &quot;&quot;</div><div class="line"></div><div class="line">// user.name不为null返回user.name，否者返回&quot;unknow&quot;</div><div class="line">val name = user.name ?? &quot;unknow&quot;</div><div class="line">	</div><div class="line">// 字符串模板</div><div class="line">print(&quot;my name is $name or $&#123;user.name&#125;&quot;)</div></pre></td></tr></table></figure>
<h3 id="lanmda表达式"><a href="#lanmda表达式" class="headerlink" title="lanmda表达式"></a>lanmda表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">names</div><div class="line">.filter &#123; it.startsWith(&quot;A&quot;) &#125; </div><div class="line">.sortedBy &#123; it &#125;</div><div class="line">.map &#123; it.toUpperCase() &#125; </div><div class="line">.forEach &#123; print(it) &#125;</div></pre></td></tr></table></figure>
<!--more-->
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">object Singlton &#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">	companion object &#123;</div><div class="line">		fun sayHi()&#123; println(&quot;&quot;) &#125;</div><div class="line">	&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyClass.sayHi()</div></pre></td></tr></table></figure>
<h3 id="方法扩展-Extension-Functions"><a href="#方法扩展-Extension-Functions" class="headerlink" title="方法扩展(Extension Functions)"></a>方法扩展(Extension Functions)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fun &lt;T&gt; MutableList&lt;T&gt;.swap(index1: Int, index2: Int) &#123;</div><div class="line">	val tmp = this[index1] // &apos;this&apos; corresponds to the list </div><div class="line">	this[index1] = this[index2]</div><div class="line">	this[index2] = tmp</div><div class="line">&#125;</div><div class="line"></div><div class="line">val l = mutableListOf(1, 2, 3)</div><div class="line">l.swap(0, 2) // &apos;this&apos; inside &apos;swap()&apos; will hold the value of &apos;l&apos;</div></pre></td></tr></table></figure>
<h3 id="属性扩展"><a href="#属性扩展" class="headerlink" title="属性扩展"></a>属性扩展</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val &lt;T&gt; List&lt;T&gt;.lastIndex: Int </div><div class="line">	get() = size - 1</div></pre></td></tr></table></figure>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">View.setOnClickListener&#123; println(&apos;hello&apos;) &#125;</div><div class="line"></div><div class="line">ps： 这种写法仅限于只有一个重载方法的情况，多方法只能用下面形式</div><div class="line"></div><div class="line">window.addMouseListener(object : MouseAdapter() &#123; </div><div class="line">	override fun mouseClicked(e: MouseEvent) &#123;</div><div class="line">	// ...</div><div class="line">	&#125;</div><div class="line">	override fun mouseEntered(e: MouseEvent) &#123;</div><div class="line">	 	// ...</div><div class="line">	&#125;	</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="观察属性变化自动通知Observable"><a href="#观察属性变化自动通知Observable" class="headerlink" title="观察属性变化自动通知Observable"></a>观察属性变化自动通知Observable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class User &#123;</div><div class="line">	var name: String by Delegates.observable(&quot;&lt;no name&gt;&quot;) &#123;</div><div class="line">		prop, old, new -&gt; println(&quot;$old -&gt; $new&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">	val user = User()</div><div class="line">	user.name = &quot;first&quot;</div><div class="line">	user.name = &quot;second&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;no name&gt; -&gt; first</div><div class="line">first -&gt; second</div></pre></td></tr></table></figure>
<h3 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h3><p>java代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class Artist &#123;</div><div class="line">    private long id;</div><div class="line">    private String name;</div><div class="line">    private String url;</div><div class="line">    private String mbid;</div><div class="line"> </div><div class="line">    public long getId() &#123;</div><div class="line">        return id;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void setId(long id) &#123;</div><div class="line">        this.id = id;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public String getUrl() &#123;</div><div class="line">        return url;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void setUrl(String url) &#123;</div><div class="line">        this.url = url;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public String getMbid() &#123;</div><div class="line">        return mbid;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void setMbid(String mbid) &#123;</div><div class="line">        this.mbid = mbid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等同于下面kotlin代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data class Artist(var id: Long, var name: String, var url: String, var mbid: String)</div></pre></td></tr></table></figure>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本&quot;&gt;&lt;a href=&quot;#基本&quot; class=&quot;headerlink&quot; title=&quot;基本&quot;&gt;&lt;/a&gt;基本&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;fun sum(a: Int, b: Int) = a + b&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fun max(a: Int, b: Int) = if (a &amp;gt; b) a else b&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
  </entry>
  
</feed>
