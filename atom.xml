<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KotlinThree&#39;s Blog</title>
  <subtitle>Kotliner 上海分会</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-19T16:02:53.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>KotlinThree</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift vs. Kotlin 之变量定义</title>
    <link href="http://yoursite.com/2017/05/18/swiftvskotlin_variables/"/>
    <id>http://yoursite.com/2017/05/18/swiftvskotlin_variables/</id>
    <published>2017-05-18T04:59:58.000Z</published>
    <updated>2017-05-19T16:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>tags: Kotlin, Swift</p>
<p>Kotlin 君和 Swift 君在一个团队一起开发已经很久了，由于平台的差异性，他们经常会进行一些技术上的交流（PK），「Kotlin vs. Swift」课程就是他们在互相切磋是的语录。</p>
<a id="more"></a>
<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><h4 id="Kotlin："><a href="#Kotlin：" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>你看下我们 Kotlin 定义变量太酷了，比我们之前用 Java 方便太多了，你们 Swift 声明变量方便吗？</p>
<h4 id="Swift："><a href="#Swift：" class="headerlink" title="Swift："></a>Swift：</h4><p>哦，你们是怎么样的？</p>
<h4 id="Kotlin：-1"><a href="#Kotlin：-1" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>我们可以直接这样定义一个变量 <code>val b = 2</code>，Kotlin 可以自行推断变量的类型，要是 Java 就不行了，必须要给每个变量定义类型。</p>
<h4 id="Swift：-1"><a href="#Swift：-1" class="headerlink" title="Swift："></a>Swift：</h4><p>我们这里也有类型推断的功能，我们声明一个变量直接 <code>let count = 10</code> 就可以了，和你们差不多。</p>
<h4 id="Kotlin：-2"><a href="#Kotlin：-2" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>咦，你们用 <code>let</code> 声明变量，和我们不太一样。</p>
<h4 id="Swift：-2"><a href="#Swift：-2" class="headerlink" title="Swift："></a>Swift：</h4><p>是的，我们用 <code>let</code> 声明常量，用 <code>var</code> 声明变量，而且我们常量还分为储值变量和计算变量。</p>
<h4 id="Kotlin：-3"><a href="#Kotlin：-3" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>储值变量和计算变量？是个什么概念，我们这里没有。</p>
<h4 id="Swift：-3"><a href="#Swift：-3" class="headerlink" title="Swift："></a>Swift：</h4><p>像 <code>var count = 10</code> 这样的定义就是储值变量。像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var &lt;variable name&gt;: &lt;type&gt; &#123;</div><div class="line">    get &#123;</div><div class="line">        &lt;statements&gt;</div><div class="line">    &#125;</div><div class="line">    set(&lt;setter name&gt;) &#123;</div><div class="line">        &lt;statements&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样定义为变量自定义了 getter 和 setter 方法，这样每次获取变量值得时候都要经过一些的计算才能得到变量的值，所以叫计算变量。</p>
<h4 id="Kotlin：-4"><a href="#Kotlin：-4" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>这个和我们定义 getter 和 setter 方法一样吗。我们完整的变量定义是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</div><div class="line">    [&lt;getter&gt;]</div><div class="line">    [&lt;setter&gt;]</div></pre></td></tr></table></figure>
<p>其中 initializer、getter 和 setter 是可以省略的，但是我们没有计算变量这个概念。</p>
<h4 id="Swift：-4"><a href="#Swift：-4" class="headerlink" title="Swift："></a>Swift：</h4><p>恩，我们定义变量的语法是差不多的，除了 <code>let</code> 和 <code>val</code> 的差别。</p>
<h4 id="Kotlin：-5"><a href="#Kotlin：-5" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>哎，你们的计算变量能不能给自己赋值啊？如果可以赋值的话，和储值变量有什么差别呢？</p>
<p>我们 getter 和 setter 方法里面有个「支持域」的概念，可以通过「支持域」直接给变量赋值，所以重写 getter 和 setter 方法也只是实现不一样，本身没有质的差别。</p>
<h4 id="Swift：-5"><a href="#Swift：-5" class="headerlink" title="Swift："></a>Swift：</h4><p>我们不行，在 getter 和 setter 只能通过另外一个储值变量来保存计算的结果。</p>
<h4 id="Kotlin：-6"><a href="#Kotlin：-6" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>这点还是有差异的，因为你们 getter 和 setter 不能给当前变量赋值，只能进行计算的工作，所以你们才有计算变量的概念。</p>
<h4 id="Swift：-6"><a href="#Swift：-6" class="headerlink" title="Swift："></a>Swift：</h4><p>应该是这样的。</p>
<h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h2><h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>Kotlin 定义变量的完整语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</div><div class="line">    [&lt;getter&gt;]</div><div class="line">    [&lt;setter&gt;]</div></pre></td></tr></table></figure>
<p>其中 initializer、getter 和 setter 是并不是必须的。在属性类型可以通过 initializer 推断的情况下，属性类型也可以不声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val a: Int = 1  // 直接声明</div><div class="line">val b = 2   // `Int` 类型是推断出来的</div><div class="line">val c: Int  // 在没有初始化赋值的化，需要定义类型</div></pre></td></tr></table></figure>
<p>Kotlin 制定定义只读变量(read-only variable，又叫常量)和变量(mutable variable)，分别用 <code>val</code> 和 <code>var</code> 关键字修饰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val a: Int = 1 // 不可再次赋值</div><div class="line">var b: Int = 1 // 可再次赋值</div></pre></td></tr></table></figure>
<h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><p>Swift 声明常量，用 let 关键字，常量的值在初始化后不能被再次修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let &lt;constant name&gt;[: &lt;type&gt;] = &lt;expression&gt;</div></pre></td></tr></table></figure>
<p>Swift 声明储值变量，用 var 关键字，变量的值可以被任意修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var &lt;variable name&gt;[: &lt;type&gt;] = &lt;expression&gt;</div></pre></td></tr></table></figure>
<p>Swift 声明计算变量，用 var 关键字，同时需要指定 set 和 get 的方式，仅指定 get 则为只读计算变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var &lt;variable name&gt;: &lt;type&gt; &#123;</div><div class="line">    get &#123;</div><div class="line">        &lt;statements&gt;</div><div class="line">    &#125;</div><div class="line">    set(&lt;setter name&gt;) &#123;</div><div class="line">        &lt;statements&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Swift 支持类型推断，在有初始值的情况下，可以省去类型声明，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let count: Int = 10 // 常量</div><div class="line">var message: String = &quot;Hello&quot; // 变量</div></pre></td></tr></table></figure>
<p>可以简写为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let count = 10 // Int 类型</div><div class="line">var message = &quot;Hello&quot; // String 类型</div></pre></td></tr></table></figure>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tags: Kotlin, Swift&lt;/p&gt;
&lt;p&gt;Kotlin 君和 Swift 君在一个团队一起开发已经很久了，由于平台的差异性，他们经常会进行一些技术上的交流（PK），「Kotlin vs. Swift」课程就是他们在互相切磋是的语录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Primer·第五章·函数与闭包</title>
    <link href="http://yoursite.com/2017/04/09/2017-04-09-01/"/>
    <id>http://yoursite.com/2017/04/09/2017-04-09-01/</id>
    <published>2017-04-09T05:48:44.000Z</published>
    <updated>2017-05-19T15:56:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>题外话：全书的目录以及主要内容已经公开，可在我公众号【<a href="http://mp.weixin.qq.com/s/3W6ciZYM1o_J5VqIFyNIpQ" target="_blank" rel="external">技术实验室</a>】的历史推送文章查看</p>
<p>第一部分——快速上手<br><a href="http://shanghai.kotliner.cn/2017/02/03/2017-02-03-01/" target="_blank" rel="external">第一章·启程</a><br><a href="http://shanghai.kotliner.cn/2017/02/04/2017-02-04-01/" target="_blank" rel="external">第二章·基本语法</a><br><a href="http://shanghai.kotliner.cn/2017/02/07/2017-02-07-01/" target="_blank" rel="external">第三章·Kotlin 与 Java 混编</a><br>第二部分——开始学习 Kotlin<br><a href="http://shanghai.kotliner.cn/2017/02/12/2017-02-12-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(上)</a><br><a href="http://shanghai.kotliner.cn/2017/02/26/2017-02-26-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(下)</a><br><a href="http://shanghai.kotliner.cn/2017/04/09/2017-04-09-01/" target="_blank" rel="external">第五章·函数与闭包</a> </p>
</blockquote>
<p>函数与闭包的特性可以算是 Kotlin 语言最大的特性了。  </p>
<h3 id="5-1-函数"><a href="#5-1-函数" class="headerlink" title="5.1 函数"></a>5.1 函数</h3><p>即使 Kotlin 是一门面向对象的编程语言，它也是有函数的概念的——而不像 Java 那样，仅仅有“方法”。<br>回顾一下前面第二章讲述的函数声明语法：</p>
<a id="more"></a>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">say</span><span class="params">(str: <span class="type">String</span>)</span></span>: String &#123;</div><div class="line">	<span class="keyword">return</span> str</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数使用关键字 <code>fun</code> 声明，如下代码创建了一个名为 say() 的函数，它接受一个 String 类型的参数，并返回一个 String 类型的值。</p>
<h4 id="5-1-1-Unit"><a href="#5-1-1-Unit" class="headerlink" title="5.1.1 Unit"></a>5.1.1 Unit</h4><p>如果一个函数是空函数，比如 Android 开发中的 TextWatch 接口，通常只会用到一个方法，但必须把所有方法都重写一遍，就可以通过这种方式来简写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">editText.addTextChangedListener(<span class="keyword">object</span> : TextWatcher &#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterTextChanged</span><span class="params">(s: <span class="type">Editable</span>?)</span></span> = <span class="built_in">Unit</span></div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeTextChanged</span><span class="params">(s: <span class="type">CharSequence</span>?, start: <span class="type">Int</span>, count: <span class="type">Int</span>, after: <span class="type">Int</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTextChanged</span><span class="params">(s: <span class="type">CharSequence</span>?, start: <span class="type">Int</span>, before: <span class="type">Int</span>, count: <span class="type">Int</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Unit 表示的是一个值的类型。 这种类型对应于Java中的 <code>void</code> 类型。</p>
<h4 id="5-1-2-Nothing"><a href="#5-1-2-Nothing" class="headerlink" title="5.1.2 Nothing"></a>5.1.2 Nothing</h4><p>如果一个函数不会返回（也就是说只要调用这个函数，那么在它返回之前程序肯定出错了，比如一定会抛出异常的函数），理论上你可以随便给他一个返回值，通常我们会声明为返回 Nothing 类型。我们看到 Nothing 的注释：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Nothing has no instances. You can use Nothing to represent "a value that never exists": for example,</div><div class="line"> * if a function has the return type of Nothing, it means that it never returns (always throws an exception).</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Nothing</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>()</div></pre></td></tr></table></figure>
<p>没有任何实例。 您可以使用 Nothing 来表示“永远不存在的值”.</p>
<h3 id="5-2-复杂的特性"><a href="#5-2-复杂的特性" class="headerlink" title="5.2 复杂的特性"></a>5.2 复杂的特性</h3><h4 id="5-2-1-嵌套函数"><a href="#5-2-1-嵌套函数" class="headerlink" title="5.2.1 嵌套函数"></a>5.2.1 嵌套函数</h4><p>Kotlin 的函数有一些非常有意思的特性，比如函数中再声明函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">function</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> valuesInTheOuterScope = <span class="string">"Kotlin is awesome!"</span></div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">theFunctionInside</span><span class="params">(int: <span class="type">Int</span> = <span class="number">10</span>)</span></span> &#123;</div><div class="line">    println(valuesInTheOuterScope)</div><div class="line">    <span class="keyword">if</span> (int &gt;= <span class="number">5</span>) theFunctionInside(int - <span class="number">1</span>)</div><div class="line">  &#125;</div><div class="line">  theFunctionInside()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与内部类有些类似，内部函数可以直接访问外部函数的局部变量、常量，这种写法通常使用在 <code>会在某些条件下触发递归的方法内</code>，在一般情况下是不推荐使用嵌套函数的。 </p>
<h4 id="5-2-2-运算符重载"><a href="#5-2-2-运算符重载" class="headerlink" title="5.2.2 运算符重载"></a>5.2.2 运算符重载</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span> step <span class="number">20</span>) &#123;</div><div class="line">    print(<span class="string">"<span class="subst">$i</span> "</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段函数将会输出 <code>1 21 41 61 81</code> </p>
<p>这段神奇的循环是怎么执行的？  </p>
<p>in关键字，在编译以后，会被翻译为一个迭代器方法，其源码可以在 <code>Progressions</code> 类中查看到</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: IntIterator = IntProgressionIterator(first, last, step)</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * An iterator over a progression of values of type `Int`.</div><div class="line"> */</div><div class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">IntProgressionIterator</span></span>(first: <span class="built_in">Int</span>, last: <span class="built_in">Int</span>, <span class="keyword">val</span> step: <span class="built_in">Int</span>) : IntIterator() &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> next = first</div><div class="line">    <span class="keyword">private</span> <span class="keyword">val</span> finalElement = last</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> hasNext: <span class="built_in">Boolean</span> = <span class="keyword">if</span> (step &gt; <span class="number">0</span>) first &lt;= last <span class="keyword">else</span> first &gt;= last</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = hasNext</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">nextInt</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</div><div class="line">        <span class="keyword">val</span> value = next</div><div class="line">        <span class="keyword">if</span> (value == finalElement) &#123;</div><div class="line">            hasNext = <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            next += step</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> value</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>in 关键字之后，还有两个点的 <code>..</code> ，他表示一个封闭区间，其内部实现原理是通过运算符重载来完成的。首先看到他的函数定义，你可以在  <code>Int</code> 类的源码中找到：  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/** Creates a range from this value to the specified [other] value. */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">rangeTo</span><span class="params">(other: <span class="type">Int</span>)</span></span>: IntRange</div></pre></td></tr></table></figure>
<p>运算符重载需要使用关键字<code>operator</code>修饰，其余定义与函数相同。<br>通过源码看到，上面的代码实际<code>..</code>的原理实际上就是对一个 Int 值，调用他的 <code>rangeTo</code>方法，传入一个 Int 参数，并返回一个区间对象。<br>带入到上面的代码，实际上就是把<code>..</code>看做是方法名，调用 1 的<code>rangeTo</code>方法，传入 100 作为参数，会返回一个区间对象。 然后再用迭代器 <code>in</code> 便利区间中的每一个值。<br>所以上面那种写法改写为下面这样，依旧是能正常运行的。  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>rangeTo(<span class="number">100</span>) step <span class="number">20</span>) &#123;</div><div class="line">    print(<span class="string">"<span class="subst">$i</span> "</span>)</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">&gt; 说道运算符给大家讲个笑话，在 C/C++/Java 中，其实有一个大家经常使用但是没有人知道的运算符，叫`趋近于`写法为 `--&gt;`，例如下面的代码：  </div><div class="line">&gt; int i = <span class="number">10</span>;  </div><div class="line">&gt; <span class="keyword">while</span>(i --&gt; <span class="number">0</span>)&#123;  </div><div class="line">&gt;     printf(<span class="string">"%d"</span>, i);  </div><div class="line">&gt; &#125;   </div><div class="line">&gt; 这个代码运行完后将会依次打印 <span class="number">10</span> 到 <span class="number">0</span> 数字。不信你试试</div><div class="line"></div><div class="line"></div><div class="line">#### <span class="number">5.2</span><span class="number">.3</span> 中缀表达式</div><div class="line"></div><div class="line">运算符的数量毕竟是有限的，有时并不一定有合适的。例如上面代码中的步长这个意义，就没有合适的运算符可以标识。  </div><div class="line">这时候我们可以用一个单词或字母来当运算符用(其本质还是函数调用)，叫做中缀表达式，**所谓中缀表达式就是不需要点和括号的方法调用**。  </div><div class="line">你可以在 Reangs 中看到`step`源码声明：  </div><div class="line"></div><div class="line">```kotlin</div><div class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> IntProgression.<span class="title">step</span><span class="params">(step: <span class="type">Int</span>)</span></span>: IntProgression &#123;</div><div class="line">    checkStepIsPositive(step &gt; <span class="number">0</span>, step)</div><div class="line">    <span class="keyword">return</span> IntProgression.fromClosedRange(first, last, <span class="keyword">if</span> (<span class="keyword">this</span>.step &gt; <span class="number">0</span>) step <span class="keyword">else</span> -step)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>中缀表达式需要用<code>infix</code>修饰，从源码看到，在 SDK 中定义了一个叫 step 的方法，最终返回一个<code>IntProgression</code>对象，这个对象最终会被作用到 in，也就是迭代器的第三个参数step上。  </p>
<h3 id="5-2-闭包"><a href="#5-2-闭包" class="headerlink" title="5.2 闭包"></a>5.2 闭包</h3><p>其实在 Kotlin 中与其说一等公民是函数，不如说一等公民是闭包。  </p>
<p>例如在 Kotlin 中，你可以写出这种怪异的代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    test</div><div class="line">&#125;</div><div class="line"><span class="keyword">val</span> test = <span class="keyword">if</span> (<span class="number">5</span> &gt; <span class="number">3</span>) &#123;</div><div class="line">    print(<span class="string">"yes"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    print(<span class="string">"no"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，我们都知道这段代码永远都只会输出yes。<br>这里只是为了演示，if 语句仍旧是一个闭包。而事实上，上文包括前文讲到的所有：函数、Lambda、if语句、for、when，都可以称之为闭包，但通常情况下，我们所说的闭包是 Lambda 表达式。  </p>
<h4 id="5-2-1-自执行闭包"><a href="#5-2-1-自执行闭包" class="headerlink" title="5.2.1 自执行闭包"></a>5.2.1 自执行闭包</h4><p>自执行闭包就是在定义闭包的同时直接执行闭包，一般用于初始化上下文环境。<br>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt;</div><div class="line">    println(<span class="string">"<span class="subst">$&#123;x + y&#125;</span>"</span>)</div><div class="line">&#125;(<span class="number">1</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure>
<h3 id="5-3-Lambda"><a href="#5-3-Lambda" class="headerlink" title="5.3 Lambda"></a>5.3 Lambda</h3><h4 id="5-3-1-Lambda-表达式"><a href="#5-3-1-Lambda-表达式" class="headerlink" title="5.3.1 Lambda 表达式"></a>5.3.1 Lambda 表达式</h4><p>Lambda 表达式俗称匿名函数，熟悉Java的大家应该也明白这是个什么概念。Kotlin 的 Lambda表达式更“纯粹”一点， 因为它是真正把Lambda抽象为了一种类型，而 Java 8 的 Lambda 只是单方法匿名接口实现的语法糖罢了。  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> printMsg = &#123; msg: String -&gt; </div><div class="line">	println(msg) </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  printMsg.invoke(<span class="string">"hello"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是 Lambda 表达式最简单的实例。<br>首先声明了一个名为<code>printMsg</code>的 Lambda，它接受一个 String 类型的值作为参数，然后在 main 函数中调用它。如果还想省略，你还可以在调用时直接省略invoke，像函数一样使用。  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  printMsg(<span class="string">"hello"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Lambda 表达式还有非常多的语法糖，比如  </p>
<ul>
<li>当参数只有一个的时候，声明中可以不用显示声明参数，在使用参数时可以用 it 来替代那个唯一的参数。  </li>
<li>当有多个用不到的参数时，可以用下划线来替代参数名(1.1以后的特性)，但是如果已经用下划线来省略参数时，是不能使用 it 来替代当前参数的。  </li>
<li>Lambda 最后一条语句的执行结果表示这个 Lambda 的返回值。</li>
</ul>
<p>需要注意的是：闭包是不能有变长参数的<br>例如前面讲过变长参数的函数，但是闭包的参数数量是必须固定的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printLog</span><span class="params">(<span class="keyword">vararg</span> str: <span class="type">String</span>)</span></span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-3-2-高阶函数"><a href="#5-3-2-高阶函数" class="headerlink" title="5.3.2 高阶函数"></a>5.3.2 高阶函数</h4><p>Lambda 表达式最大的特点是可以作为参数传递。当定义一个闭包作为参数的函数，称这个函数为高阶函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    log(<span class="string">"world"</span>, printMsg)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> printMsg = &#123; str: String -&gt;</div><div class="line">    println(str)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> log = &#123; str: String, printLog: (String) -&gt; <span class="built_in">Unit</span> -&gt;</div><div class="line">    printLog(str)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子中，log 是一个接受一个 String 和一个以 String 为参数并返回 Unit 的 Lambda 表达式为参数的 Lambda 表达式。<br>读起来有点绕口，其实就是 log 有两个参数，一个str:String，一个printLog: (String) -&gt; Unit。</p>
<h4 id="5-3-3-内联函数"><a href="#5-3-3-内联函数" class="headerlink" title="5.3.3 内联函数"></a>5.3.3 内联函数</h4><p>在使用高阶函数时，一定要知道内联函数这个东西。它可以大幅提升高阶函数的性能。<br>官方文档的描述是这样的：使用 高阶函数 在运行时会带来一些不利: 每个函数都是一个对象, 而且它还要捕获一个闭包, 也就是, 在函<br>数体内部访问的那些外层变量. 内存占用(函数对象和类都会占用内存) 以及虚方法调用都会带来运行时的消耗.</p>
<p>但是也不是说所有的函数都要内联，因为一旦添加了<code>inline</code>修饰，在编译阶段，编译器将会把函数拆分，插入到调用出。如果一个 inline 函数是很大的，那他会大幅增加调用它的那个函数的体积。  </p>
<h3 id="5-4-小结"><a href="#5-4-小结" class="headerlink" title="5.4 小结"></a>5.4 小结</h3><p>闭包应该算是 Kotlin 最核心特性之一了。<br>使用好闭包可以让代码量大大减少，例如 Kotlin 最著名的开源库：<code>Anko</code>，使用 Anko 去动态代码布局，比使用 Java 代码配合 xml 要更加简洁。   </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?, persistentState: <span class="type">PersistableBundle</span>?)</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState, persistentState)</div><div class="line">        MyActivityUI().setContentView(<span class="keyword">this</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivityUI</span> : <span class="type">AnkoComponent</span>&lt;<span class="type">MyActivity</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createView</span><span class="params">(ui: <span class="type">AnkoContext</span>&lt;<span class="type">MyActivity</span>&gt;)</span></span> = ui.apply &#123;</div><div class="line">        verticalLayout &#123;</div><div class="line">            editText()</div><div class="line">            button(<span class="string">"Say Hello"</span>) &#123;</div><div class="line">                onClick &#123; ctx.toast(<span class="string">"Hello!"</span>) &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;.view</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，充分运用了闭包的灵活性，省略了很多的临时变量和参数声明。<br>然而，也正是因为闭包的灵活性，造成如果泛滥的话，可能会写出可读性非常差的代码(这里就不举反例了， js 的 lambda 滥用的结果就能想象了)</p>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
]]></content>
    
    <summary type="html">
    
      久违了，Kotlin 的闭包。函数与闭包的特性可以算是 Kotlin 语言最大的特性了，所以写了很久。    
    
    </summary>
    
      <category term="code" scheme="http://yoursite.com/categories/code/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Primer·第四章·Kotlin 的类特性(下)</title>
    <link href="http://yoursite.com/2017/02/26/2017-02-26-01/"/>
    <id>http://yoursite.com/2017/02/26/2017-02-26-01/</id>
    <published>2017-02-26T03:48:44.000Z</published>
    <updated>2017-05-19T15:56:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>题外话：全书的目录以及主要内容已经公开，可在我公众号【<a href="http://mp.weixin.qq.com/s/3W6ciZYM1o_J5VqIFyNIpQ" target="_blank" rel="external">技术实验室</a>】的历史推送文章查看</p>
<p>第一部分——快速上手<br><a href="http://shanghai.kotliner.cn/2017/02/03/2017-02-03-01/" target="_blank" rel="external">第一章·启程</a><br><a href="http://shanghai.kotliner.cn/2017/02/04/2017-02-04-01/" target="_blank" rel="external">第二章·基本语法</a><br><a href="http://shanghai.kotliner.cn/2017/02/07/2017-02-07-01/" target="_blank" rel="external">第三章·Kotlin 与 Java 混编</a><br>第二部分——开始学习 Kotlin<br><a href="http://shanghai.kotliner.cn/2017/02/12/2017-02-12-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(上)</a><br><a href="http://shanghai.kotliner.cn/2017/02/26/2017-02-26-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(下)</a><br><a href="http://shanghai.kotliner.cn/2017/04/09/2017-04-09-01/" target="_blank" rel="external">第五章·函数与闭包</a>   </p>
</blockquote>
<p>前面三章的内容是写给希望快速了解 Kotlin 语言的大忙人的。<br>而从本章开始，才会真正讲述 Kotlin 语言的神奇之处。   </p>
<h3 id="4-5-类的扩展"><a href="#4-5-类的扩展" class="headerlink" title="4.5 类的扩展"></a>4.5 类的扩展</h3><a id="more"></a> 
<p>在 Java 开发的时候，经常会写一大堆的 Utils 类，甚至经常写一些common包，比如著名的 <code>apache-commons</code> 系列、<code>Guava</code>等等。<br>如果每个类在想要用这些工具类的时候，他们自己就已经具备了这些工具方法多好，<code>Kotlin</code> 的类扩展方法就是这个作用。 </p>
<h4 id="4-5-1-扩展方法"><a href="#4-5-1-扩展方法" class="headerlink" title="4.5.1 扩展方法"></a>4.5.1 扩展方法</h4><p>在之前的文章中我就讲过扩展方法了，这里就不再多赘述，只回顾一下扩展方法的格式： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun Activity.toast(message: CharSequence, duration: Int = Toast.LENGTH_SHORT) &#123;</div><div class="line">    Toast.makeText(this, message, duration).show()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先是一个 <code>fun</code> 关键字，紧接着是要扩展哪个类的类名，点方法名，然后是方法的声明和返回值以及方法体。  </p>
<h4 id="4-5-2-小心有坑"><a href="#4-5-2-小心有坑" class="headerlink" title="4.5.2 小心有坑"></a>4.5.2 小心有坑</h4><p>需要注意的是扩展方法是静态解析的，而并不是真正给类添加了这个方法。<br>举个例子：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">open class Animal&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">class Dog : Animal()</div><div class="line"></div><div class="line">object Main &#123;</div><div class="line">    fun Animal.bark() = &quot;animal&quot;</div><div class="line"></div><div class="line">    fun Dog.bark() = &quot;dog&quot;</div><div class="line"></div><div class="line">    fun Animal.printBark(anim: Animal)&#123;</div><div class="line">        println(anim.bark())</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @JvmStatic fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">        Animal().printBark(Dog())</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终的输出是 <code>animal</code>，而不是 <code>dog</code>。<br>因为扩展方法是静态解析的，在添加扩展方法的时候类型为 <code>Animal</code>，那么即便运行时传入了子类对象，也依旧会执行参数中声明时类型的方法。    </p>
<h4 id="4-6-1-强转与智能转换"><a href="#4-6-1-强转与智能转换" class="headerlink" title="4.6.1 强转与智能转换"></a>4.6.1 强转与智能转换</h4><p>在 <code>Kotlin</code> 中，用 is 来判断一个对象是否是某个类的实例，用 as 来做强转。  </p>
<p>Kotlin 有一个很好的特性，叫 <code>智能转换(smart cast)</code>，在我之前的文章中也提到过。就是当已经确定一个对象的类型后，可以自动识别为这个类的对象，而不用再手动强转。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">	var animal: Animal? = null</div><div class="line">    if (animal is Dog) &#123;</div><div class="line">    	//在这里你必须手动强转为Dog的对象</div><div class="line">       animal.bark()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-6-2-总有例外"><a href="#4-6-2-总有例外" class="headerlink" title="4.6.2 总有例外"></a>4.6.2 总有例外</h4><p>如果智能转换的对象是一个全局变量，这个变量可能在别的地方被改变赋值，所以你必须手动判断与转换它的类型。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">open class Animal &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Dog : Animal() &#123;</div><div class="line">    fun bark() &#123;</div><div class="line">        println(&quot;animal&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var animal: Animal? = null</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    if (animal is Dog) &#123;</div><div class="line">    	//在这里你必须手动强转为Dog的对象</div><div class="line">       (animal as Dog).bark()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">### 4.7 伴生对象  </div><div class="line"></div><div class="line">在上一篇 **Kotlin 与 Java 互转** 中 我们提到这样一段工具类代码</div></pre></td></tr></table></figure>
<p>class StringUtils {<br>    companion object {<br>       fun isEmpty(str: String): Boolean {<br>            return “” == str<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">由于 `Kotlin` 没有静态方法。在大多数情况下，官方建议是简单地使用 包级 函数。如果你需要写一个可以无需用一个类的实例来调用、但需要访问类内部的函数(例如,工厂方法或单利),你可以把它写成一个用 `companion` 修饰的对象内的方法。我们称 `companion` 修饰的对象为伴生对象。    </div><div class="line"></div><div class="line">将上面的代码编译后查看，实际上是编译器生成了一个 `public` 的内部对象。</div></pre></td></tr></table></figure></p>
<p>public final class StringUtils public constructor() {<br>    public companion object {<br>        public final fun isEmpty(str: kotlin.String): kotlin.Boolean {<br>        /<em> compiled code </em>/<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 4.8 单例类设计</div><div class="line"></div><div class="line">伴生对象更多的用途是用来创建一个单例类。如果只是简单的写，直接用伴生对象返回一个 `val` 修饰的外部类对象就可以了，但是更多的时候我们希望在类被调用的时候才去初始化他的对象。以下代码将线程安全问题交给虚拟机在静态内部类加载时处理，是一种推荐的写法：</div></pre></td></tr></table></figure></p>
<p>class Single private constructor() {<br>    companion object {<br>        fun get():Single{<br>            return Holder.instance<br>        }<br>    }</p>
<pre><code>private object Holder {
    val instance = Single()
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 4.9 动态代理</div><div class="line"></div><div class="line">写多继承还是要根据场景来，正好今天跟朋友聊到他们项目重构的问题，我当时就说了一句：果然还是 `Kotlin` 好，原生支持动态代理。  </div><div class="line"></div><div class="line">朋友的一个 Android 项目，所有网络请求包括回调和参数全部封装在了一个 BaseActivity 中，然后随着项目越来越大，这一些网络请求方法想要抽出来，但又害怕牵连到线上的改动，我就推荐他用个动态代理来做，但是 Java 的动态代理又得要反射，又得要额外多写很多的代码方法，又是一个大改动。  </div><div class="line"></div><div class="line">反之看 `Kotlin` 的动态代理：</div></pre></td></tr></table></figure></p>
<p>interface Animal{<br>    fun bark()<br>}</p>
<p>class Dog :Animal {<br>    override fun bark() {<br>        println(“Wang Wang”)<br>    }<br>}</p>
<p>class Cat(animal: Animal) : Animal by animal {<br>}</p>
<p>fun main(args: Array<string>) {<br>   Cat(Dog()).bark()<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这样，我们就很成功的让一只猫的叫声用狗去代理掉了，于是上面的 `main` 方法执行完后就变成了 Wang Wang。  </div><div class="line"></div><div class="line">### 4.10 伪多继承 </div><div class="line"></div><div class="line">Kotlin 的动态代理更多的是用在一种需要多继承的场景。  </div><div class="line">例如，还是之前我举的我朋友那个项目的例子，他们的问题在于，每个 `BaseActivity` 的子类，都会要请求不同的网络，可能A需要获取用户信息，B需要获取活动列表，C既需要活动列表也需要获取用户信息，D却只需要获取图片列表。  </div><div class="line"></div><div class="line">这样一个场景，使用一个代理类实现所有需要获取信息的接口方法。然后让不同的子类去实现所需的接口，请求统一交给代理类完成。这样不仅维护网络请求信息方便，而且每个类不会有额外多出来的方法防止新人接触项目的时候调用错请求方法。  </div><div class="line"></div><div class="line">还是用猫狗来举例：</div></pre></td></tr></table></figure></string></p>
<p>interface Animal{<br>    fun bark()<br>}</p>
<p>interface Food{<br>    fun eat()<br>}</p>
<p>class Delegate : Animal, Food {<br>    override fun eat() {<br>        println(“mouse”)<br>    }</p>
<pre><code>override fun bark() {
    println(&quot;Miao&quot;)
}
</code></pre><p>}</p>
<p>class Cat(animal: Animal, food: Food) : Animal by animal, Food by food {<br>}</p>
<p>@JvmStatic fun main(args: Array<string>) {<br>    val delegate: Delegate = Delegate()<br>    Cat(delegate, delegate).bark()<br>}<br>```</string></p>
<p>Kotlin 的类就介绍这么多，下一章我们讲：<strong>闭包</strong> </p>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
]]></content>
    
    <summary type="html">
    
      Kotlin 中有很多非常好的特性，扩展方法、伴生对象、原生支持动态代理、伪多继承    
    
    </summary>
    
      <category term="code" scheme="http://yoursite.com/categories/code/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Primer·第四章·Kotlin 的类特性(上)</title>
    <link href="http://yoursite.com/2017/02/12/2017-02-12-01/"/>
    <id>http://yoursite.com/2017/02/12/2017-02-12-01/</id>
    <published>2017-02-12T05:48:44.000Z</published>
    <updated>2017-05-19T15:56:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>题外话：全书的目录以及主要内容已经公开，可在我公众号【<a href="http://mp.weixin.qq.com/s/3W6ciZYM1o_J5VqIFyNIpQ" target="_blank" rel="external">技术实验室</a>】的历史推送文章查看</p>
<p>第一部分——快速上手<br><a href="http://shanghai.kotliner.cn/2017/02/03/2017-02-03-01/" target="_blank" rel="external">第一章·启程</a><br><a href="http://shanghai.kotliner.cn/2017/02/04/2017-02-04-01/" target="_blank" rel="external">第二章·基本语法</a><br><a href="http://shanghai.kotliner.cn/2017/02/07/2017-02-07-01/" target="_blank" rel="external">第三章·Kotlin 与 Java 混编</a><br>第二部分——开始学习 Kotlin<br><a href="http://shanghai.kotliner.cn/2017/02/12/2017-02-12-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(上)</a><br><a href="http://shanghai.kotliner.cn/2017/02/26/2017-02-26-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(下)</a><br><a href="http://shanghai.kotliner.cn/2017/04/09/2017-04-09-01/" target="_blank" rel="external">第五章·函数与闭包</a>   </p>
</blockquote>
<p>前面三章的内容是写给希望快速了解 Kotlin 语言的大忙人的。<br>而从本章开始，才会真正讲述 Kotlin 语言的神奇之处。   </p>
<p>与 Java 相同，Kotlin 声明类的关键字是 <code>class</code>。类声明由类名、类头和类体构成。<br>其中 <code>类头</code> 和 <code>类体</code> 都是可选的; 如果一个类没有类体，那么花括号也是可以省略的。</p>
<h3 id="4-1-构造函数"><a href="#4-1-构造函数" class="headerlink" title="4.1 构造函数"></a>4.1 构造函数</h3><a id="more"></a>
<p>Kotlin 的构造函数可以写在类头中，跟在类名后面，如果有注解还需要加上关键字 <code>constructor</code>。这种写法声明的构造函数，我们称之为主构造函数。例如下面我们为 <code>Person</code> 创建带一个 <code>String</code> 类型参数的构造函数。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Person(private val name: String) &#123;</div><div class="line">    fun sayHello() &#123;</div><div class="line">        println(&quot;hello $name&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在构造函数中声明的参数，它们默认属于类的公有字段，可以直接使用，如果你不希望别的类访问到这个变量，可以用 <code>private</code> 修饰。<br>在主构造函数中不能有任何代码实现，如果有额外的代码需要在构造方法中执行，你需要放到 <code>init</code> 代码块中执行。同时，在本示例中由于需要更改 name 参数的值，我们将 val 改为 var,表明 name 参数是一个可改变的参数。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Person(private var name: String) &#123;</div><div class="line">	</div><div class="line">    init &#123;</div><div class="line">        name = &quot;Zhang Tao&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    internal fun sayHello() &#123;</div><div class="line">        println(&quot;hello $name&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个非抽象类没有声明任何(主或次)构造函数，它会有一个生成的不带参数的主构造函数。构造函数的可见性是 public。如果你不希望你的类 有一个公有构造函数,你需要声明一个带有非默认可见性的空的主构造函数。<br>另外，在 JVM 上,如果主构造函数的所有的参数都有默认值，编译器会生成一个额外的无参构造函数,它将使用默认值。   </p>
<h3 id="4-2-次级构造函数"><a href="#4-2-次级构造函数" class="headerlink" title="4.2 次级构造函数"></a>4.2 次级构造函数</h3><p>一个类当然会有多个构造函数的可能，只有主构造函数可以写在类头中，其他的次级构造函数(Secondary Constructors)就需要写在类体中了。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Person(private var name: String) &#123;</div><div class="line"></div><div class="line">    private var description: String? = null</div><div class="line">    </div><div class="line">    init &#123;</div><div class="line">        name = &quot;Zhang Tao&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    constructor(name: String, description: String) : this(name) &#123;</div><div class="line">        this.description = description</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    internal fun sayHello() &#123;</div><div class="line">        println(&quot;hello $name&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们让次级构造函数调用了主构造函数，完成 name 的赋值。由于次级构造函数不能直接将参数转换为字段，所以需要手动声明一个 description 字段，并为 description 字段赋值。  </p>
<h3 id="4-3-修饰符"><a href="#4-3-修饰符" class="headerlink" title="4.3 修饰符"></a>4.3 修饰符</h3><p>点开 IDEA，工程目录中的 out 列表，看到我们写完的 <code>Person</code> 被编译为 class 文件后的样子。    </p>
<p><img src="http://cdn.kymjs.com/kotlin/4-3-1.png" alt="Kotlin"></p>
<h4 id="4-3-1-open-修饰符"><a href="#4-3-1-open-修饰符" class="headerlink" title="4.3.1 open 修饰符"></a>4.3.1 open 修饰符</h4><p>Kotlin 默认会为每个变量和方法添加 final 修饰符。这么做的目的是为了程序运行的性能，其实在 Java 程序中，你也应该尽可能为每个类添加final 修饰符( 见 Effective Java 第四章 17 条)。<br>为每个类加了 <code>final</code> 也就是说，在 Kotlin 中默认每个类都是不可被继承的。如果你确定这个类是会被继承的，那么你需要给这个类添加 <code>open</code> 修饰符。  </p>
<h4 id="4-3-2-internal-修饰符"><a href="#4-3-2-internal-修饰符" class="headerlink" title="4.3.2 internal 修饰符"></a>4.3.2 internal 修饰符</h4><p>写过 Java 的同学一定知道，Java 有三种访问修饰符，public/private/protected，还有一个默认的包级别访问权限没有修饰符。<br>在 Kotlin 中，默认的访问权限是 public。而多增加了一种访问修饰符叫 <code>internal</code>。它是模块级别的访问权限。<br>何为模块(module)，我们称被一起编译的一系列 Kotlin 文件为一个模块。在 IDEA 中可以很明确的看到一个 <code>module</code> 就是一个模块，当跨 <code>module</code> 的时候就无法访问另一个 <code>module</code> 的 <code>internal</code> 变量或方法。 </p>
<h3 id="4-4-一些特殊的类"><a href="#4-4-一些特殊的类" class="headerlink" title="4.4 一些特殊的类"></a>4.4 一些特殊的类</h3><h4 id="4-4-1-枚举类"><a href="#4-4-1-枚举类" class="headerlink" title="4.4.1 枚举类"></a>4.4.1 枚举类</h4><p>在 Kotlin 中，每个枚举常量都是一个对象。枚举常量用逗号分隔。<br>例如我们写一个枚举类 Programer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">enum class Programer &#123;</div><div class="line">    JAVA, KOTLIN, C, CPP, ANDROID;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当它被编译成 class 后，将转为如下代码实际就是一个私有了构造函数的 <code>kotlin.Enum</code> 继承类。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final enum class Programer </div><div class="line">private constructor() : kotlin.Enum&lt;Programer&gt; &#123;</div><div class="line">    JAVA, KOTLIN, C, CPP, ANDROID;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着我们再来看 <code>kotlin.Enum</code> 这个类(节选)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public abstract class Enum&lt;E : Enum&lt;E&gt;&gt;</div><div class="line">(name: String, ordinal: Int): Comparable&lt;E&gt; &#123;</div><div class="line">    companion object &#123;&#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Returns the name of this enum constant,</div><div class="line">     *  exactly as declared in its enum declaration.</div><div class="line">     */</div><div class="line">    public final val name: String</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Returns the ordinal of this enumeration </div><div class="line">     * constant (its position in its enum </div><div class="line">     * declaration, where the initial constant</div><div class="line">     * is assigned an ordinal of zero).</div><div class="line">     */</div><div class="line">    public final val ordinal: Int</div><div class="line"></div><div class="line">    public override final fun compareTo(other: E): Int</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>发现，其实在 Kotlin 中，枚举的本质是一个实现了 <code>Comparable</code> 的 class，其排序就是按照字段在枚举类中定义的顺序来的。  </p>
<h4 id="4-4-2-sealed-密封类"><a href="#4-4-2-sealed-密封类" class="headerlink" title="4.4.2 sealed 密封类"></a>4.4.2 sealed 密封类</h4><p>sealed 修饰的类称为密封类，用来表示受限的类层次结构。例如当一个值为有限集中的 类型、而不能有任何其他类型时。在某种意义上,他们是枚举类的扩展:枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例,而密封类的一个子类可以有可包含状态的多个实例。  </p>
<h4 id="4-4-3-data-数据类"><a href="#4-4-3-data-数据类" class="headerlink" title="4.4.3 data 数据类"></a>4.4.3 data 数据类</h4><p>data 修饰的类称之为数据类。它通常用在我们写的一些 POJO 类上。<br>当 data 修饰后，会自动将所有成员用 <code>operator</code> 声明，即为这些成员生成类似 Java 的 getter/setter 方法。   </p>
<p>本章就先介绍到这，下一章我们讲继承与组合，伪多继承与接口等内容。</p>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
]]></content>
    
    <summary type="html">
    
      前面三章的内容是写给希望快速了解 Kotlin 语言的大忙人的。   而从本章开始，才会真正讲述 Kotlin 语言的神奇之处。    
    
    </summary>
    
      <category term="code" scheme="http://yoursite.com/categories/code/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Primer·第三章·Kotlin 与 Java 混编</title>
    <link href="http://yoursite.com/2017/02/07/2017-02-07-01/"/>
    <id>http://yoursite.com/2017/02/07/2017-02-07-01/</id>
    <published>2017-02-07T07:34:14.000Z</published>
    <updated>2017-05-19T15:56:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>题外话：全书的目录以及主要内容已经公开，可在我公众号【<a href="http://mp.weixin.qq.com/s/3W6ciZYM1o_J5VqIFyNIpQ" target="_blank" rel="external">技术实验室</a>】的历史推送文章查看</p>
<p>第一部分——快速上手<br><a href="http://shanghai.kotliner.cn/2017/02/03/2017-02-03-01/" target="_blank" rel="external">第一章·启程</a><br><a href="http://shanghai.kotliner.cn/2017/02/04/2017-02-04-01/" target="_blank" rel="external">第二章·基本语法</a><br><a href="http://shanghai.kotliner.cn/2017/02/07/2017-02-07-01/" target="_blank" rel="external">第三章·Kotlin 与 Java 混编</a><br>第二部分——开始学习 Kotlin<br><a href="http://shanghai.kotliner.cn/2017/02/12/2017-02-12-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(上)</a><br><a href="http://shanghai.kotliner.cn/2017/02/26/2017-02-26-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(下)</a><br><a href="http://shanghai.kotliner.cn/2017/04/09/2017-04-09-01/" target="_blank" rel="external">第五章·函数与闭包</a>   </p>
</blockquote>
<p>虽然 Kotlin 的开发很方便，但当你与他人协作时，总会碰到 Java 与 Kotlin 代码共存的代码项目。<br>本章就教你如何优雅的实现 Kotlin 与 Java 混合编程。   </p>
<h3 id="3-1-直接转换"><a href="#3-1-直接转换" class="headerlink" title="3.1 直接转换"></a>3.1 直接转换</h3><h4 id="3-1-1-将-Java-转换为-Kotlin"><a href="#3-1-1-将-Java-转换为-Kotlin" class="headerlink" title="3.1.1 将 Java 转换为 Kotlin"></a>3.1.1 将 Java 转换为 Kotlin</h4><a id="more"></a>
<p>如果你之前使用 Java 语言而没有 Kotlin 开发经验，不用担心，Intellij IDEA 会帮你一键转换，将 Java 代码转换成 Kotlin 代码(但是反过来就不行了)。<br>在 Mac 上，系统默认的快捷键为 <code>control+shift+command+K</code> ，这个组合键实在有点反人类，建议你自定义一个你觉得舒服的快捷键。<br>快捷键可以通过你的编译器 <em>keymap</em> 中修改：<code>command+,</code> -&gt; 搜索<code>keymap</code> -&gt; 右侧搜索<code>kotlin</code>，可以查看到<code>Convert Java File to Kotlin File</code>项。  </p>
<p><img src="http://cdn.kymjs.com/kotlin/3-1-1.png" alt="图3-1-1">  </p>
<h4 id="3-1-2-注意-Class-调用"><a href="#3-1-2-注意-Class-调用" class="headerlink" title="3.1.2 注意 Class 调用"></a>3.1.2 注意 Class 调用</h4><p>在 Java 或 Android 开发中，经常会直接调用一个类的 Class 文件。但是当你用上文介绍的转换方法去转换 <code>XXX.class</code>  这样的代码时，是无法直接转换的(也许未来会修复这个问题，但目前你扔需要手动修改)。在 M13 之前，Java 中的 <code>XXX.class</code> 对应 Kotlin 代码中的 <code>JavaClass&lt;XXX&gt;</code>，而 M13 之后写法已被改为 <code>XXX::class.java</code>。    </p>
<h4 id="3-1-3-Android-proguard-的坑"><a href="#3-1-3-Android-proguard-的坑" class="headerlink" title="3.1.3 Android proguard 的坑"></a>3.1.3 Android proguard 的坑</h4><p>注：我们团队遇到过这样的一个坑，在 Android 开发的时候，如下代码会在混淆以后，发生异常   </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = some?.s?.d ?: <span class="string">""</span></div><div class="line">```  </div><div class="line">这段代码在正常debug模式编译运行完全正常，但是一旦执行混淆，就会发生所在函数被移除的现象。  </div><div class="line">但是如果改写为以下写法就能正常运行：  </div><div class="line"></div><div class="line">```kotlin</div><div class="line"><span class="keyword">var</span> str = some?.s?.d ?: String()</div></pre></td></tr></table></figure>
<p>猜想应该是 proguard 不知道如何处理这段代码，无法识别出最后两个引号是一个 <code>String</code>，最后直接将整个函数移除掉了。   </p>
<p>同样的代码还有：  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> list = some?.<span class="keyword">data</span>?.list:mutableListof()</div></pre></td></tr></table></figure>
<p>但是如下代码即使混淆后也是可以完全正常执行的  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = some?.s ?: <span class="string">""</span>  </div><div class="line"><span class="keyword">var</span> s = some.d ?: <span class="string">""</span></div><div class="line"><span class="keyword">var</span> list = some?.<span class="keyword">data</span>?.list:klist  </div><div class="line"><span class="keyword">var</span> <span class="keyword">data</span> = some?.<span class="keyword">data</span> ?: <span class="keyword">return</span></div></pre></td></tr></table></figure>
<h4 id="3-1-4-开发-Android-library-的建议"><a href="#3-1-4-开发-Android-library-的建议" class="headerlink" title="3.1.4 开发 Android library 的建议"></a>3.1.4 开发 Android library 的建议</h4><p>如果你是开发 Android library 程序，建议你不要使用 Kotlin 代码。因为作为 library，如果使用它的工程是纯 Java 完成的，引入后会额外增大 200k 左右大小，同时它有可能会造成某些情况下编译异常。    </p>
<h3 id="3-2-在-Kotlin-中调用-Java-代码"><a href="#3-2-在-Kotlin-中调用-Java-代码" class="headerlink" title="3.2 在 Kotlin 中调用 Java 代码"></a>3.2 在 Kotlin 中调用 Java 代码</h3><h4 id="3-2-1-返回-void-的方法"><a href="#3-2-1-返回-void-的方法" class="headerlink" title="3.2.1 返回 void 的方法"></a>3.2.1 返回 void 的方法</h4><p>如果一个 Java 方法返回 void，对应的在 Kotlin 代码中它将返回 Unit。关于 Unit，本书将在 第五章 <code>函数</code> 部分着重讲解。<br>现在你只需要知道在Java 中返回为 void 的函数，在 Kotlin 中可以省略这个返回类型。   </p>
<h4 id="3-2-2-与-Kotlin-关键字冲突的处理"><a href="#3-2-2-与-Kotlin-关键字冲突的处理" class="headerlink" title="3.2.2 与 Kotlin 关键字冲突的处理"></a>3.2.2 与 Kotlin 关键字冲突的处理</h4><p>Java 有 static 关键字，在 Kotlin 中没有这个关键字，你需要使用 <code>@JvmStatic</code> 替代这个关键字。<br>同样，在 Kotlin 中也有很多的关键字是 Java 中是没有的。例如 <code>in</code>,<code>is</code>,<code>data</code>等。如果 Java 中使用了这些关键字，需要加上反引号(`)转义来避免冲突。例如   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// Java 代码中有个方法叫 is()</div><div class="line">public void is()&#123;</div><div class="line">	//...</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 转换为 Kotlin 代码需要加反引号转义</div><div class="line">fun `is`() &#123;</div><div class="line">   //...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-3-在-Java-中调用-Kotlin-代码"><a href="#3-3-在-Java-中调用-Kotlin-代码" class="headerlink" title="3.3 在 Java 中调用 Kotlin 代码"></a>3.3 在 Java 中调用 Kotlin 代码</h3><h4 id="3-3-1-static-方法"><a href="#3-3-1-static-方法" class="headerlink" title="3.3.1 static 方法"></a>3.3.1 static 方法</h4><p>上文已经提到过，在 Kotlin 中没有 <code>static</code>关键字,那么如果在 Java 代码中想要通过类名调用一个 Kotlin 类的方法，你需要给这个方法加入<code>@JvmStatic</code>注解。否则你必须通过对象调用这个方法。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">StringUtils.isEmpty(&quot;hello&quot;);  </div><div class="line">StringUtils.INSTANCE.isEmpty2(&quot;hello&quot;);</div><div class="line"></div><div class="line">object StringUtils &#123;</div><div class="line">    @JvmStatic fun isEmpty(str: String): Boolean &#123;</div><div class="line">        return &quot;&quot; == str</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fun isEmpty2(str: String): Boolean &#123;</div><div class="line">        return &quot;&quot; == str</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">如果你阅读 Kotlin 代码，应该经常看到这样一种写法。</div></pre></td></tr></table></figure>
<p>class StringUtils {<br>    companion object {<br>       fun isEmpty(str: String): Boolean {<br>            return “” == str<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">```companion object</div></pre></td></tr></table></figure></p>
<p>表示外部类的一个伴生对象，你可以把他理解为外部类自动创建了一个对象作为自己的<code>field</code>。<br>与上面的类似，Java 在调用时，可以这样写：<code>StringUtils.Companion. isEmpty();</code><br>关于伴生对象，我们将在下一章 <code>类与对象</code> 详细讲解。  </p>
<h4 id="3-3-2-包级别函数"><a href="#3-3-2-包级别函数" class="headerlink" title="3.3.2 包级别函数"></a>3.3.2 包级别函数</h4><p>与 Java 不同，Kotlin 允许函数独立存在，而不必依赖于某个类，这类函数我们称之为<strong>包级别函数</strong>(Package-Level Functions)。<br>为了兼容 Java，Kotlin 默认会将所有的包级别函数放在一个自动生成的叫 <code>ExampleKt</code> 的类中， 在 Java 中想要调用包级别函数时，需要通过这个类来调用。<br>当然，也是可以自定义的，你只需要通过注解 <code>@file:JvmName(&quot;Example&quot;)</code> 即可将当前文件中的所有包级别函数放到一个自动生成的名为 Example 的类中。   </p>
<h4 id="3-3-3-空安全性"><a href="#3-3-3-空安全性" class="headerlink" title="3.3.3 空安全性"></a>3.3.3 空安全性</h4><p>在 Java 中，如果你调用的 kotlin 方法参数声明了非空类型，如果你在 Java 代码中传入一个空值，将在运行时抛出 <code>NullPointerException</code>。其内部原因在于 Kotlin 为每个非空类型加了断言，如果传入空值则会立刻抛出异常。<br>同样，如果你使用 null 对象去调用一个 kotlin 方法，将会立刻抛出<code>NullPointerException</code>（就算是调用普通 java 方法也是一样会抛出 NullPointerException ）   </p>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
]]></content>
    
    <summary type="html">
    
      前三章的内容是为方便想在短时间内马上用上Kotlin的人，例如作为一个刚入职的新人，公司的代码已经是用Kotlin编写了，你应该如何更快的融入与适应。   
    
    </summary>
    
      <category term="code" scheme="http://yoursite.com/categories/code/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Primer·第二章·基本语法</title>
    <link href="http://yoursite.com/2017/02/04/2017-02-04-01/"/>
    <id>http://yoursite.com/2017/02/04/2017-02-04-01/</id>
    <published>2017-02-04T07:44:44.000Z</published>
    <updated>2017-05-19T15:56:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>题外话：全书的目录以及主要内容已经公开，可在我公众号【<a href="http://mp.weixin.qq.com/s/3W6ciZYM1o_J5VqIFyNIpQ" target="_blank" rel="external">技术实验室</a>】的历史推送文章查看</p>
<p>第一部分——快速上手<br><a href="http://shanghai.kotliner.cn/2017/02/03/2017-02-03-01/" target="_blank" rel="external">第一章·启程</a><br><a href="http://shanghai.kotliner.cn/2017/02/04/2017-02-04-01/" target="_blank" rel="external">第二章·基本语法</a><br><a href="http://shanghai.kotliner.cn/2017/02/07/2017-02-07-01/" target="_blank" rel="external">第三章·Kotlin 与 Java 混编</a><br>第二部分——开始学习 Kotlin<br><a href="http://shanghai.kotliner.cn/2017/02/12/2017-02-12-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(上)</a><br><a href="http://shanghai.kotliner.cn/2017/02/26/2017-02-26-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(下)</a><br><a href="http://shanghai.kotliner.cn/2017/04/09/2017-04-09-01/" target="_blank" rel="external">第五章·函数与闭包</a>  </p>
</blockquote>
<p>Kotlin 程序是什么样子的？如果浏览过本书，你会看到许多例子。很有可能你觉得 Kotlin 语言有点古怪，充满了 <code>var field: String</code> 这样的语法。然而读完本章后，你将不再对这些语法感到陌生，甚至很可能喜欢上它们。  </p>
<h3 id="2-1-变量"><a href="#2-1-变量" class="headerlink" title="2.1 变量"></a>2.1 变量</h3><a id="more"></a>
<p>让我们来看一个很简单的程序。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> quantity = <span class="number">5</span></div><div class="line">    <span class="keyword">val</span> price: <span class="built_in">Double</span> = <span class="number">20.3</span></div><div class="line">    <span class="keyword">val</span> name: String = <span class="string">"大米"</span></div><div class="line"></div><div class="line">    println(<span class="string">"单价:<span class="subst">$price</span>"</span>)</div><div class="line">    println(<span class="string">"数量:<span class="subst">$quantity</span>"</span>)</div><div class="line">    println(<span class="string">"产品:<span class="subst">$name</span> 总计:<span class="subst">$&#123;quantity * price&#125;</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码中，首先创建了一个名为 <code>quantity</code> 的变量用以表示产品的数量，并初始化为 5。<br>一个值为 20.3 的常量 <code>price</code>，用来表示产品的单价。<br>一个表示产品名字的字符串常量 <code>name</code>。  </p>
<p>通过这段代码我们可以看到，Kotlin 语言声明一个变量使用关键字 <code>var</code>，声明一个常量使用 <code>val</code>，声明时 Kotlin 语言是可以自动推测出字段类型的，例如上面代码中的 <code>var quantity = 5</code> 会被认为是 <code>Int</code> 类型，但如果你希望它是一个 <code>Double</code> 类型，则需要显示声明类型，例如 <code>var quantity: Double = 5</code>。</p>
<h3 id="2-2-语句"><a href="#2-2-语句" class="headerlink" title="2.2 语句"></a>2.2 语句</h3><h4 id="2-2-1-in关键字的使用"><a href="#2-2-1-in关键字的使用" class="headerlink" title="2.2.1 in关键字的使用"></a>2.2.1 in关键字的使用</h4><p>判断一个对象是否在某一个区间内，可以使用in关键字  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果存在于区间(1,Y-1)，则打印OK</span></div><div class="line"><span class="keyword">if</span> (x <span class="keyword">in</span> <span class="number">1.</span>.y<span class="number">-1</span>) </div><div class="line">  print(<span class="string">"OK"</span>)</div><div class="line"></div><div class="line"><span class="comment">//如果x不存在于array中，则输出Out</span></div><div class="line"><span class="keyword">if</span> (x !<span class="keyword">in</span> <span class="number">0.</span>.array.lastIndex) </div><div class="line">  print(<span class="string">"Out"</span>)</div><div class="line"></div><div class="line"><span class="comment">//打印1到5</span></div><div class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) </div><div class="line">  print(x)</div><div class="line"></div><div class="line"><span class="comment">//遍历集合(类似于Java中的for(String name : names))</span></div><div class="line"><span class="keyword">for</span> (name <span class="keyword">in</span> names)</div><div class="line">  println(name)</div><div class="line"></div><div class="line"><span class="comment">//如果names集合中包含text对象则打印yes</span></div><div class="line"><span class="keyword">if</span> (text <span class="keyword">in</span> names)</div><div class="line">  print(<span class="string">"yes"</span>)</div></pre></td></tr></table></figure>
<h4 id="2-2-2-when表达式"><a href="#2-2-2-when表达式" class="headerlink" title="2.2.2 when表达式"></a>2.2.2 when表达式</h4><p>类似于 Java 中的 switch，但是 Kotlin 更加智能，可以自动判断参数的类型并转换为响应的匹配值。 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cases</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123; </div><div class="line">  <span class="keyword">when</span> (obj) &#123;</div><div class="line">    <span class="number">1</span>       -&gt; print(<span class="string">"第一项"</span>)</div><div class="line">    <span class="string">"hello"</span> -&gt; print(<span class="string">"这个是字符串hello"</span>)</div><div class="line">    <span class="keyword">is</span> <span class="built_in">Long</span> -&gt; print(<span class="string">"这是一个Long类型数据"</span>)</div><div class="line">    !<span class="keyword">is</span> String -&gt; print(<span class="string">"这不是String类型的数据"</span>)</div><div class="line">    <span class="keyword">else</span>    -&gt; print(<span class="string">"else类似于Java中的default"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-2-3-智能类型推测"><a href="#2-2-3-智能类型推测" class="headerlink" title="2.2.3 智能类型推测"></a>2.2.3 智能类型推测</h4><p>判断一个对象是否为一个类的实例，可以使用is关键字<br>与 Java 中的<figure class="highlight plain"><figcaption><span>Kotlin 中如果已经确定了一个对象的类型，可以在接下来的代码块中直接作为这个确定类型使用。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```kotlin</div><div class="line">fun getStringLength(obj: Any): Int? &#123;</div><div class="line">  if (obj is String) &#123;</div><div class="line">    // 做过类型判断以后，obj会被系统自动转换为String类型</div><div class="line">    return obj.length </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //同时还可以使用!is，来取反</div><div class="line">  if (obj !is String)&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 代码块外部的obj仍然是Any类型的引用</div><div class="line">  return null</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-2-4-空值检测"><a href="#2-2-4-空值检测" class="headerlink" title="2.2.4 空值检测"></a>2.2.4 空值检测</h4><p>Kotlin 是空指针安全的，也就意味着你不会再看到那恼人的空指针异常。<br>例如这句代码 <code>println(files?.size)</code>，只会在 <code>files</code>不为空时执行。<br>以及，你可以这样写  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//当data不为空的时候，执行语句块</span></div><div class="line"><span class="keyword">data</span>?.let&#123;</div><div class="line">	<span class="comment">//... </span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//相反的，以下代码当data为空时才会执行</span></div><div class="line"><span class="keyword">data</span>?:let&#123;</div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-3-函数"><a href="#2-3-函数" class="headerlink" title="2.3 函数"></a>2.3 函数</h3><h4 id="2-3-1-函数的声明"><a href="#2-3-1-函数的声明" class="headerlink" title="2.3.1 函数的声明"></a>2.3.1 函数的声明</h4><p>函数使用关键字 <code>fun</code> 声明，如下代码创建了一个名为 <code>say()</code> 的函数，它接受一个 <code>String</code> 类型的参数，并返回一个 <code>String</code> 类型的值  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">say</span><span class="params">(str: <span class="type">String</span>)</span></span>: String &#123;</div><div class="line">	<span class="keyword">return</span> str</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时，在 Kotlin 中，如果像这种简单的函数，可以简写为 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">say</span><span class="params">(str: <span class="type">String</span>)</span></span>: String = str</div></pre></td></tr></table></figure>
<p>如果是返回<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```kotlin</div><div class="line">fun getIntValue(value: Int) = value</div></pre></td></tr></table></figure></p>
<h4 id="2-3-2-函数的默认参数"><a href="#2-3-2-函数的默认参数" class="headerlink" title="2.3.2 函数的默认参数"></a>2.3.2 函数的默认参数</h4><p>你也可以使用默认参数来实现重载类似的功能  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">say</span><span class="params">(str: <span class="type">String</span> = <span class="string">"hello"</span>)</span></span>: String = str</div></pre></td></tr></table></figure>
<p>这时候你可以调用<figure class="highlight plain"><figcaption><span>```"hello"```，也可以自己传入参数```say("world")```来得到传入参数值。   </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">有时参数非常多的时候，也可以使用多行参数的写法，它们是相同的  </div><div class="line"></div><div class="line">```kotlin</div><div class="line">fun say(firstName: String = &quot;Tao&quot;,</div><div class="line">		lastName: String = &quot;Zhang&quot;)&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-3-3-变参函数"><a href="#2-3-3-变参函数" class="headerlink" title="2.3.3 变参函数"></a>2.3.3 变参函数</h4><p>同 Java 的变长参数一样，Kotlin 也支持变长参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在Java中，我们这么表示一个变长函数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasEmpty</span><span class="params">(String... strArray)</span></span>&#123;</div><div class="line">	<span class="keyword">for</span> (String str : strArray)&#123;</div><div class="line">		<span class="keyword">if</span> (<span class="string">""</span>.equals(str) || str == <span class="keyword">null</span>)</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//在Kotlin中，使用关键字vararg来表示</span></div><div class="line"><span class="function">fun <span class="title">hasEmpty</span><span class="params">(vararg strArray: String?)</span>: Boolean</span>&#123;</div><div class="line">	<span class="keyword">for</span> (str in strArray)&#123;</div><div class="line">		<span class="keyword">if</span> (<span class="string">""</span>.equals(str) || str == <span class="keyword">null</span>)</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>	</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-3-4-扩展函数"><a href="#2-3-4-扩展函数" class="headerlink" title="2.3.4 扩展函数"></a>2.3.4 扩展函数</h4><p>你可以给父类添加一个方法，这个方法将可以在所有子类中使用<br>例如，在 Android 开发中，我们常常使用这样的扩展函数：  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> Activity.<span class="title">toast</span><span class="params">(message: <span class="type">CharSequence</span>, duration: <span class="type">Int</span> = Toast.LENGTH_SHORT)</span></span> &#123;</div><div class="line">    Toast.makeText(<span class="keyword">this</span>, message, duration).show()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这样，我们就可以在每一个 <code>Activity</code> 中直接使用toast()函数了。   </p>
<h4 id="2-3-5-将函数作为参数"><a href="#2-3-5-将函数作为参数" class="headerlink" title="2.3.5 将函数作为参数"></a>2.3.5 将函数作为参数</h4><p> Kotlin 中，可以将一个函数作为参数传递给另一个函数  </p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">fun</span> lock<span class="type">&lt;T&gt;</span><span class="params">(lock: <span class="type">Lock</span>, body: ()</span></span> -&gt; T ) : T &#123;</div><div class="line">	    lock.lock()</div><div class="line">	    <span class="keyword">try</span> &#123;</div><div class="line">	        <span class="keyword">return</span> body()</div><div class="line">	    &#125;</div><div class="line">	    <span class="keyword">finally</span> &#123;</div><div class="line">	        lock.unlock()</div><div class="line">	    &#125;</div><div class="line">&#125;</div><div class="line"> ``` </div><div class="line">上面的代码中，我们传入了一个无参的 body() 作为 lock() 的参数，</div><div class="line"></div><div class="line">### <span class="number">2.4</span> 小结  </div><div class="line"></div><div class="line">最后，我们用一段代码来总结本章内容，你能看懂吗？  </div><div class="line"></div><div class="line">```kotlin</div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">val</span> firstName: String = <span class="string">"Tao"</span></div><div class="line">    <span class="keyword">val</span> lastName: String? = <span class="string">"Zhang"</span></div><div class="line"></div><div class="line">    println(<span class="string">"my name is <span class="subst">$&#123;getName(firstName, lastName)&#125;</span>"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasEmpty</span><span class="params">(<span class="keyword">vararg</span> strArray: <span class="type">String</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</div><div class="line">    <span class="keyword">for</span> (str <span class="keyword">in</span> strArray) &#123;</div><div class="line">        str ?: <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">(firstName: <span class="type">String</span>?, lastName: <span class="type">String</span>? = <span class="string">"unknow"</span>)</span></span>: String &#123;</div><div class="line">    <span class="keyword">if</span> (hasEmpty(firstName, lastName)) &#123;</div><div class="line">        lastName?.let &#123; <span class="keyword">return</span><span class="symbol">@getName</span> <span class="string">"<span class="subst">$&#123;checkName(firstName)&#125;</span> <span class="subst">$lastName</span>"</span> &#125;</div><div class="line">        firstName?.let &#123; <span class="keyword">return</span><span class="symbol">@getName</span> <span class="string">"<span class="subst">$firstName</span> <span class="subst">$&#123;checkName(lastName)&#125;</span>"</span> &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">"<span class="subst">$firstName</span> <span class="subst">$lastName</span>"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkName</span><span class="params">(name: <span class="type">String</span>?)</span></span>: String = name ?: <span class="string">"unknow"</span></div></pre></td></tr></table></figure>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt="">  </p>
]]></content>
    
    <summary type="html">
    
      前三章的内容是为方便想在短时间内马上用上Kotlin的人，例如作为一个刚入职的新人，公司的代码已经是用Kotlin编写了，你应该如何更快的融入与适应。  
    
    </summary>
    
      <category term="code" scheme="http://yoursite.com/categories/code/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Primer·第一章·启程</title>
    <link href="http://yoursite.com/2017/02/03/2017-02-03-01/"/>
    <id>http://yoursite.com/2017/02/03/2017-02-03-01/</id>
    <published>2017-02-03T09:34:14.000Z</published>
    <updated>2017-05-19T15:55:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>题外话：全书的目录以及主要内容已经公开，可在我公众号【<a href="http://mp.weixin.qq.com/s/3W6ciZYM1o_J5VqIFyNIpQ" target="_blank" rel="external">技术实验室</a>】的历史推送文章查看</p>
<p>第一部分——快速上手<br><a href="http://shanghai.kotliner.cn/2017/02/03/2017-02-03-01/" target="_blank" rel="external">第一章·启程</a><br><a href="http://shanghai.kotliner.cn/2017/02/04/2017-02-04-01/" target="_blank" rel="external">第二章·基本语法</a><br><a href="http://shanghai.kotliner.cn/2017/02/07/2017-02-07-01/" target="_blank" rel="external">第三章·Kotlin 与 Java 混编</a><br>第二部分——开始学习 Kotlin<br><a href="http://shanghai.kotliner.cn/2017/02/12/2017-02-12-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(上)</a><br><a href="http://shanghai.kotliner.cn/2017/02/26/2017-02-26-01/" target="_blank" rel="external">第四章·Kotlin 的类特性(下)</a><br><a href="http://shanghai.kotliner.cn/2017/04/09/2017-04-09-01/" target="_blank" rel="external">第五章·函数与闭包</a>     </p>
</blockquote>
<p>欢迎阅读本书！Kotlin 语言是一种新的静态类型编程语言，可运行于 JVM 环境同时也能用来开发 Android 应用。本章为学习和使用这一新兴的语言做准备，并讨论在一些常见开发环境中运行 Kotlin 程序的方法。  </p>
<h3 id="1-1-Kotlin语言介绍"><a href="#1-1-Kotlin语言介绍" class="headerlink" title="1.1 Kotlin语言介绍"></a>1.1 Kotlin语言介绍</h3><p>Kotlin 是 JetBrains 在 2010 年推出的基于 JVM 的新编程语言。开发者称，设计它的目的是避免 Java 语言编程中的一些难题。比如：在 Kotlin 中类型系统控制了空指针引用，可以有效避免 Java 中常见的NullPointException。<br>作为一个跨平台的语言，Kotlin 可以工作于任何 Java 的工作环境：服务器端的应用，移动应用（Android版），桌面应用程序。 </p>
<a id="more"></a> 
<h3 id="1-2-Kotlin的优势"><a href="#1-2-Kotlin的优势" class="headerlink" title="1.2 Kotlin的优势"></a>1.2 Kotlin的优势</h3><p>相比于 Java，Kotlin 有着更好的语法结构，安全性和开发工具支持。<br>Kotlin 中没有基础类型，数组是定长的，泛型是安全的，即便运行时也是安全的。此外，该语言支持闭包，还可通过内联进行优化。不过，它不支持检查异常（Checked Exceptions），许多语言设计者认为这是它的瑕疵。不论如何，重要的是 Java 和 Kotlin 之间的互操作性：Kotlin 可以调用 Java，反之亦可。</p>
<h3 id="1-3-准备工作"><a href="#1-3-准备工作" class="headerlink" title="1.3 准备工作"></a>1.3 准备工作</h3><p>Intellij IDEA 是 JetBrains 提供的继承开发环境，可以用来开发 Kotlin 应用程序。<br>如果你是一名 Android 开发者，你也可以使用 Android Studio 来开发 Kotlin 程序。如你所知，Android Studio 其实就是 Intellij IDEA 的插件扩展，Intellij IDEA 是由 JetBrains 所开发，而 Kotlin 同样是由 JetBrains 创造的，其中的兼容性自然不用多说。<br>在安装好 Intellij IDEA 后，还需要安装 Kotlin 插件。<br><strong>说明</strong>：从 Intellij 15 开始，已经自带了 Kotlin 插件，无需再次下载，而 Android Studio 却没有。不过还是建议你运行一下下面的步骤，检查一下插件是否为最新版。</p>
<p>首先启动你的 IDE，按下快捷键 Ctrl+, (Mac 下为 command+,) 打开Preference 界面。<br>点击左侧 Plugin 栏，打开插件界面。<br>点击 Browse repositories（如图1-3-1）。   </p>
<p><img src="http://cdn.kymjs.com/kotlin/1-3-1.png" alt="图1-3-1：kotlin安装">    </p>
<p>在弹出的窗口上方，搜索 “Kotlin”，选中 Kotlin 和 Kotlin Extension For Android。<br>点击右侧的 Install。<br>安装完成后按钮会变成 Restart，再次点击重启 IDE。<br>刚刚安装的这两个插件分别为 Kotlin 语言支持包，和我们稍后会用到的Android 开发的扩展包。   </p>
<p><strong>一点小技巧</strong>：也许由于网络环境原因，会造成下载失败。可以根据弹出窗口中提示的(或直接在 JetBrains 插件市场搜索)下载链接，使用国内网盘的离线下载功能，下载到网盘后再从网盘下载到本地。  </p>
<h3 id="1-4-Hello-Kotlin"><a href="#1-4-Hello-Kotlin" class="headerlink" title="1.4 Hello Kotlin"></a>1.4 Hello Kotlin</h3><h4 id="1-4-1-第一个Kotlin程序"><a href="#1-4-1-第一个Kotlin程序" class="headerlink" title="1.4.1 第一个Kotlin程序"></a>1.4.1 第一个Kotlin程序</h4><p>首先我们打开 Intellij 选中 Create a new project 选项后可以看到如下界面。<br>在 Additional Libraries and Frameworks 选项框中，如果你已经成功安装 Kotlin 插件，可以直接勾选 Kotlin(Java) 选项。<br>再点击下方的 Create 按钮，在弹出的 Create Kotlin Java Runtime Library 选项框中，我们选择 Use library from plugin 并确定(如图1-4-1)。  </p>
<p><img src="http://cdn.kymjs.com/kotlin/1-4-1.png" alt="图1-4-1">  </p>
<p>点击 Next，填写工程名和路径，这里我们创建一个名为 Hello 的工程，并点击 Finish 完成创建(如图1-4-2)。  </p>
<p><img src="http://cdn.kymjs.com/kotlin/1-4-2.png" alt="图1-4-2">  </p>
<p>首次创建工程需要等待一段时间，编译器这个时候正在帮助我们下载一些必要的依赖项。<br>工程构建完成后，右键工程目录的 src 图标，选择 New -&gt; Kotlin File，这里我们新建一个名为 Hello 的 Kotlin 源码文件(如图1-4-3)。  </p>
<p> <img src="http://cdn.kymjs.com/kotlin/1-4-3.png" alt="图1-4-3">  </p>
<p>看一下左侧的工程目录，src 文件夹中存放的是源码，可以在这里新建包或类；Hello.iml 文件声明了一些项目所需的环境依赖，我们不用关心。<br>于是，终于可以开始激动人心的编码了。  </p>
<p> <img src="http://cdn.kymjs.com/kotlin/1-4-4.png" alt="图1-4-4">  </p>
<p>Kotlin 程序非常简单，简单到只需要三行代码，相比起 Java 连包名都不是必须的。  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    print(<span class="string">"hello kotlin!"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>按下 Ctrl+R 快捷键，或者右上角绿色三角形，运行写好的程序(如图1-4-5)  </p>
<p> <img src="http://cdn.kymjs.com/kotlin/1-4-5.png" alt="图1-4-5">  </p>
<p>同 Java 语言一样，Kotlin 程序主入口也是 main() 函数。但是作为函数是一等公民的语言，它不需要像 Java 那样必须声明一个类。<br>在 Kotlin 中，函数的声明用 <code>fun</code> 表示，变量也与 Java 不同，是变量名在前，变量类型在后，中间用冒号隔开。<br>同时你也一定发现了，Kotlin 程序非常简洁，连分号也不需要写，当然如果你是刚从 Java 过渡来的，改不掉或不想改掉这个习惯，写上了也不会有错，因为它是可选的。<br>同时，我们还可以发现，在左侧的工程目录多了一个红色名为 out 的目录，它是用来存放 .class 文件的。</p>
<h4 id="1-4-2-面向对象的Kotlin程序"><a href="#1-4-2-面向对象的Kotlin程序" class="headerlink" title="1.4.2 面向对象的Kotlin程序"></a>1.4.2 面向对象的Kotlin程序</h4><p>下面我们将 Hello 程序改一改，为它加入一些面向对象的特性。<br>我们创建一个包，并在包下新建名为 <code>Person</code> 的类。  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.kymjs.kotlin.helloobj</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">()</span></span> &#123;</div><div class="line">        println(name)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再回到<figure class="highlight plain"><figcaption><span>main() 函数</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```kotlin</div><div class="line">import com.kymjs.kotlin.helloobj.Person</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    println(&quot;hello kotlin!&quot;)</div><div class="line">    Person(&quot;Zhang Tao&quot;).printName()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再次按下 Ctrl+R 快捷键，或者右上角绿色三角形，运行写好的程序(如图1-4-6)  </p>
<p> <img src="http://cdn.kymjs.com/kotlin/1-4-6.png" alt="图1-4-6">  </p>
<p>细心查看代码，Kotlin 创建对象的时候并不需要<code>new</code>关键字，而是像调用普通方法一样直接调用构造方法就可以了。<br>同时，由于两个文件不在同一个包下，需要导入 <code>Person</code> 类所在的包才能找到，当然，编译器已经帮我们解决了繁杂的导包过程。  </p>
<h3 id="1-5-编码风格"><a href="#1-5-编码风格" class="headerlink" title="1.5 编码风格"></a>1.5 编码风格</h3><p>有关编码风格的一点建议，同 Java 类似，使用驼峰命名法，类名首字母大写，每个单词的首字母大写；方法和属性变量首字母小写；采用四个空格缩进。<br>值得一提的是，官方文档中建议在 Kotlin 语言中不要给属性前面加前缀，例如通常我们习惯加上一个小写 <code>m</code> 或者下划线等。<br>冒号，在分隔两个类型的时候，应该在左右都有空格，在实例和类型之间，应该紧靠实例变量，例如：  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span>&lt;<span class="type">out T : Any</span>&gt; : <span class="type">Bar &#123;</span></span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(a: <span class="type">Int</span>)</span></span>: T</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Lambdas表达式，如果是简单的只用一行就可以表示的 lambda，应当遵循在大括号的两侧、箭头的两侧、参数的两侧都使用空格隔开，例如：  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list.filter &#123; it &gt; <span class="number">10</span> &#125;.map &#123; element -&gt; element * <span class="number">2</span> &#125;</div></pre></td></tr></table></figure>
<h3 id="1-6-小结"><a href="#1-6-小结" class="headerlink" title="1.6 小结"></a>1.6 小结</h3><p>在本章中，你已经编写了两个 Kotlin 程序，相信你也已经对 Kotlin 产生了兴趣。希望你也能像我一样，沉醉于使用 Kotlin 开发。<br>继续学习下一章的内容吧，我们将进入 Kotlin 的语法世界。</p>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt="">  </p>
]]></content>
    
    <summary type="html">
    
      其实最初是准备写一本电子书然后免费开放给大家的，可惜啊可惜毅力不够，坚持不下来，所以还是当成博客来写，写好了再出电子书吧。 
    
    </summary>
    
      <category term="code" scheme="http://yoursite.com/categories/code/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin：The Good, The Bad, and The Ugly(译)</title>
    <link href="http://yoursite.com/2016/08/27/kotlin_good_bad_bugly/"/>
    <id>http://yoursite.com/2016/08/27/kotlin_good_bad_bugly/</id>
    <published>2016-08-27T08:59:00.000Z</published>
    <updated>2017-05-19T16:03:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>tags: Kotlin, Android</p>
<p>在我的 <a href="https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6" target="_blank" rel="external">上一篇文章</a>, 谈到了关于转换 Java 到 Kotlin 代码和我喜欢的一些库。现在，我想要谈谈关于 Kotlin 这门语言本身的想法，还有它和 Java 交互的方式。</p>
<a id="more"></a>
<h2 id="The-Good"><a href="#The-Good" class="headerlink" title="The Good"></a>The Good</h2><p>Kotlin 有许多让人喜欢的理由。像 <code>null safety</code>、<code>property access</code> 和 <code>unchecked exceptions</code> 类似这些明显的特性在 <a href="https://blog.jetbrains.com/kotlin/2016/01/kotlin-digest-2015/" target="_blank" rel="external">publications</a> 都有描述，我就不重复了。我只讲一些我真正喜欢但很少被提到的特性。</p>
<h3 id="Automatic-conversion-of-Java-to-Kotlin"><a href="#Automatic-conversion-of-Java-to-Kotlin" class="headerlink" title="Automatic conversion of Java to Kotlin"></a>Automatic conversion of Java to Kotlin</h3><p>JetBrains 在 IntelliJ 中集成了 <code>Java to Kotlin converter</code> 为我们节约了大量的时间。虽然它还不是很完美，但是它让你不用再重复输入。要是没有它，你将要花费大量的时间从 Java 代码转换成 Kotlin。</p>
<h3 id="lateinit-Delegates-notNull-and-lazy"><a href="#lateinit-Delegates-notNull-and-lazy" class="headerlink" title="lateinit, Delegates.notNull and lazy"></a>lateinit, Delegates.notNull and lazy</h3><p>Kotlin 的 <code>null safety</code> 非常好，但是由于在 Android 的 Activity 生命周期的设计，你常常不得不在 <em>onCreate</em> 这样的回调中初始化一个变量，而不是在类的构造函数中。假设你有一个属性需要定义，你肯定想要这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val name: String</div></pre></td></tr></table></figure>
<p>如果你必须在 <code>onCreate</code> 中初始化这个属性，就不能用 <code>val</code> 定义，而必须使用 <code>var</code>。但是这样你必须在定义的时候为该属性提供一个值进行初始化，或者将它定义为可空类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var name: String? = null</div></pre></td></tr></table></figure>
<p>这样的确有效，但是当你每次使用它的时候都要进行空检查。虽然 Korlin 提供了友好的的空断言，但是在实践中即使你知道你的属性不会为空，你也不愿意到处使用 <code>!!</code>。庆幸的是，Kotlin 提供了更好的方式：<a href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties" target="_blank" rel="external"><em>lateinit</em></a> 和 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/not-null.html" target="_blank" rel="external"><em>Delegates.notNull</em></a>。任何一个都能可以让你在不初始化的情况下定义一个非空类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lateinit var name: String</div><div class="line">var age: Int by Delegates.notNull&lt;Int&gt;()</div></pre></td></tr></table></figure>
<p>这两种方式中，当你尝试在初始化之前访问该属性都会抛出异常。除了<code>lateinit</code> 不能用于基础类型的定义，这两种方法没有什么大的差别。</p>
<p>你还有第三种选择就是使用 <code>lazy</code> 委托。如果一个属性能够利用其他属性或方法获得数据进行初始化，那么 <code>lazy</code> 会是一个很好的选择。类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val imm: InputMethodManager by lazy &#123; </div><div class="line">    getSystemService(INPUT_METHOD_SERVICE) as InputMethodManager </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面块里面的代码在第一次读取之前并不会执行，执行的结果会被保存起来以供后面使用，所以后面的代码块只会被执行一次。</p>
<h3 id="Functional-collection-extensions"><a href="#Functional-collection-extensions" class="headerlink" title="Functional collection extensions"></a>Functional collection extensions</h3><p>Kotlin 提供为集合和迭代类提供了大量的函数式 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html#functions" target="_blank" rel="external">扩展方法</a>。像 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/any.html" target="_blank" rel="external"><em>any</em></a>、 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/join-to-string.html" target="_blank" rel="external"><em>joinToString</em></a> 和 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/associate.html" target="_blank" rel="external"><em>associate</em></a> 的方法能够帮助节约大量的时间，不用像 Java 里面一样手工编写 <em>for</em> 循环去实现。</p>
<p>Kotlin 还提供了大量的函数式集合操作的懒加载模式，在这种模式下载每个操作执行之前并不会进行集合的拷贝，但是在我的接受范围内，发现懒加载和即刻加载在性能上并没有什么大的差别。</p>
<h3 id="Named-and-default-function-arguments"><a href="#Named-and-default-function-arguments" class="headerlink" title="Named and default function arguments"></a>Named and default function arguments</h3><p><a href="https://kotlinlang.org/docs/reference/functions.html#named-arguments" target="_blank" rel="external">命名参数</a> 和 <a href="https://kotlinlang.org/docs/reference/functions.html#named-arguments" target="_blank" rel="external">默认参数</a> 是非常基础的，但它们让你不再需要重载方法，并且也替代了 Builder 模式的一种使用场景。</p>
<p>根据具体使用场景，你甚至可以在依赖注入中将生产依赖作为默认参数，然后在测试的时候传入模拟的数据。</p>
<p>例如，你在 <code>presenter</code> 中需要一些全局状态，你可以这样定义构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Presenter(</div><div class="line">        val okhttp: OkHttp = productionOkHttp(),</div><div class="line">        val picasso: Picasso = productionPicassoInstance()</div><div class="line">) &#123;...&#125;</div></pre></td></tr></table></figure>
<p>这样，你就你可以 <code>UI</code> 代码中创建 <code>presenter</code> 实例的时候不传递任何参数，但是在测试的时候可以传递模拟的实例作为参数。完整的依赖注入框架会更加强大，但这是一个一些简单语言构造的很好的例子。</p>
<h2 id="The-Bad"><a href="#The-Bad" class="headerlink" title="The Bad"></a>The Bad</h2><p>尽管 Kotlin 非常棒，但是它并不完美。我列举了一下我不喜欢的部分。</p>
<h3 id="No-namespaces"><a href="#No-namespaces" class="headerlink" title="No namespaces"></a>No namespaces</h3><p>Kotlin 允许你在文件中定义顶级的函数和属性。这是一个非常棒的特性，但是这会带来所有从 Kotlin 引用的顶级声明无法区分的困扰。有时，这让我们在读代码的时候很难快速确定用的是哪一个函数。</p>
<p>例如，你定义这样一个顶级函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun foo() &#123;...&#125;</div></pre></td></tr></table></figure>
<p>你可以通过 <code>foo()</code> 调用。如果你在不同的包里面也存在同样的方法，在调用侧不能明显区分出是调用的哪个方法。你可以通过在前面添加包名的方式去调用，但是如果 Java 约定的包名很深，似乎不太好。</p>
<p>一种近似的解决方案是使用单例的 <code>object</code> 类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">object FooActions &#123;</div><div class="line">    fun foo() &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样你在 Kotlin 中可以通过 <code>FooActions.foo()</code> 调用，但是在 Java 代码中就不是那么友好了。在 Java 中你必须要这样 <code>FooActions.INSTANCE.foo()</code> 这样调用，这看起来并不完美。你可以使用 <code>@JvmStatic</code> 去注解你的方法从而省掉 <code>INSTANCE</code>，这是你能做到的最好结果。这并不是什么大不了的事，但是如果 Kotlin 能够提供命名空间的话，能省不少事。</p>
<h3 id="No-static-modifier"><a href="#No-static-modifier" class="headerlink" title="No static modifier"></a>No static modifier</h3><p>无独有偶，Kotlin 提供为静态函数和属性提供了一个和 Java 不一样的处理方式。并不是说有多烂，只是觉得让代码变得不干净而且没有必要。例如，在 Android 的 <code>View</code> 类中定义的静态属性 <code>View.VISIBLE</code> 和静态函数 <code>View.inflate</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class View &#123;</div><div class="line">    public static final int VISIBLE = 0x00000000;</div><div class="line">    public static final int INVISIBLE = 0x00000004;</div><div class="line">    public static View inflate(Context context, int resource) &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个定义是简单的。然而，在 Kotlin 代码中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class View &#123;</div><div class="line">    companion object &#123;</div><div class="line">        @JvmField </div><div class="line">        val VISIBLE: Int = 0x00000000</div><div class="line">        @JvmField </div><div class="line">        val INVISIBLE: Int = 0x00000004</div><div class="line">        @JvmStatic</div><div class="line">        fun inflate(context: Context, resource: Int) &#123;...&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>尽管 Kotlin 的版本并没有那么恐怖，但是它的复杂程度超过了我对这门语言的预期。如果把注解去掉，那么你在 Java 代码中不得不使用这样可怕的语法去调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// With annotations:</div><div class="line">View.VISIBLE;</div><div class="line">//Without annotations:</div><div class="line">View.Companion.getVISIBLE();</div></pre></td></tr></table></figure>
<p>没有更好的方式去创建静态函数和属性让我感觉很奇怪。我知道 <code>companion objects</code> 是真正的对象并且能够用来实现接口，但是这并不能足够说明能完全替代普通的静态声明。</p>
<h3 id="Automatic-conversion-of-Java-to-Kotlin-1"><a href="#Automatic-conversion-of-Java-to-Kotlin-1" class="headerlink" title="Automatic conversion of Java to Kotlin"></a>Automatic conversion of Java to Kotlin</h3><p>在我的第一篇帖子里这是我列出来的我喜欢 Kotlin 的愿意之一，并且它很好用。但是正由于它在 80% 的时候都运行的很好，它在一些场景的失败实在令人沮丧。</p>
<p>Java 文档经常错位，特别是在段落横跨了好几行的时候。静态域和方法被转换成 <code>companion object</code>，除非你手动添加为他们分别添加 <code>@JvmField</code> 和 <code>@JvmStatic</code> ，你之前 Java 调用代码不在有效而出错。</p>
<p>由于 Kotlin 团队花了大量的时间在转换代码上，我相信这些问题一定会被修复的，因此我对这些问题保持乐观。</p>
<h3 id="Required-property-accessor-syntax"><a href="#Required-property-accessor-syntax" class="headerlink" title="Required property accessor syntax"></a>Required property accessor syntax</h3><p>Kotlin 提供一个很棒的语法糖叫做「属性访问语法」，它让你可以像访问 Kotlin 属性一样访问 <code>JavaBeans</code> 类型的 <code>getters</code> 和 <code>setters</code> 方法。例如，你可以这样 <code>activity.context</code> 调用 <code>Activity.getContext()</code>，而不用写整个方法名。如果你在 Kotlin 使用传统的方式调用，lint 会给你一个警告告诉你使用「属性调用语法」。</p>
<p>这是一个很好的特性，但是有时候我的方法名以 <code>get</code> 开始，但是并不想使用「属性调用语法」。一个很常见的例子就是 Java 的原子类。如果你有一个变量 <code>val i = AtomicInteger()</code>，你可能想通过 <code>i.getAndIncrement()</code> 调用。但是 Kotlin 会想让你用 <code>i.andIncrement</code> 这种方式调用。这明显是画蛇添足。</p>
<p>你可以在每个调用的地方加上 <code>@Suppress(“UsePropertyAccessSyntax”)</code>，但很丑。如果你可以为这个函数添加一个注解告诉 linter 不要把它当做一个属性会更好。</p>
<h3 id="Method-count"><a href="#Method-count" class="headerlink" title="Method count"></a>Method count</h3><p>用 Kotlin 写代码肯定会减少你项目中的代码行数。但是它也会提高你的代码在编译以后的方法数。有很多原因导致这一点，但是其中一个主要原因就是 Kotlin 属性的实现方式。</p>
<p>和 Java 不一样，Kotlin 没有提供单独定义域的方式。你必须使用 <code>val</code> 或者 <code>var</code> 来声明变量。这样有一个好处，就是你可以随意为一个属性添加 <code>get</code> 或 <code>set</code> 方法而不会破坏其他地方对该属性引用的代码。这个特性省去了像 Java 一样定义 <code>getters</code> 和 <code>setters</code> 方法。</p>
<p>尽管如此，这个特性需要一定的成本。每一个公开的 <code>val</code> 变量都会导致 Kotlin 生成一个「支持域」和一个能被 Java 调用的 <code>getter</code> 方法。每一个公开的 <code>var</code> 变量都会生成 <code>getter</code> 和 <code>setter</code> 方法。庆幸的是，私有属性的 <code>getters</code> 和 <code>setters</code> 会生成域而不是生成方法。如果你之前的 Java 代码中定义了大量的公开域（这在定义常量的时候很常见），你会惊奇的发现方法大幅上升。</p>
<p>如果你的 Android 应用快接近方法数限制了，我建议你为不需要自定义 <code>getter</code> 方法的常量加上 <code>@JvmField</code> 注解。这样会阻止  <code>getters</code> 方法的生成，从而减少你的方法数。「更新：Kirill Rakhman 在评论中指出，你可以使用 <code>const</code> 修饰符替代 </p>
<p>不过其实没有那么糟。就像我在 <a href="https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6" target="_blank" rel="external">converting an app to 100% Kotlin</a> 文章里讨论过的，Kotlin 的标准库非常小，并且能够替代 Java 的许多常用库，这些库通常都更大，现在你再也不需要他们了。多亏了 Kotlin 的标准库，在从 Java 全部转换到 Kotlin 以后方法数反而减少了。只要你控制不会出现大范围的方法数提升，就不会有什么问题。</p>
<h2 id="The-Ugly"><a href="#The-Ugly" class="headerlink" title="The Ugly"></a>The Ugly</h2><p>最后，Kotlin 有两个设计我不是很认同，而且我不期望这个在未来会有什么改变。</p>
<h3 id="SAM-conversion-and-Unit-returning-lambdas"><a href="#SAM-conversion-and-Unit-returning-lambdas" class="headerlink" title="SAM conversion and Unit returning lambdas"></a>SAM conversion and Unit returning lambdas</h3><p>这真是一个莫名其妙的设计。</p>
<p>可以嵌入 lambda 表达式是 Kotlin 最好的特性之一。如果有一个 Java 函数，它只有一个 SAM 接口（只有一个抽象方法的接口）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void registerCallback(View.OnClickListener r)</div></pre></td></tr></table></figure>
<p>无论是 Java 还是 Kotlin，你都可以传递一个普通的 lambda 表达式去调用它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Java</div><div class="line">registerCallback(() -&gt; &#123; /** do stuff */ &#125;)</div><div class="line">//Kotlin</div><div class="line">registerCallback &#123; /** do stuff */ &#125;</div></pre></td></tr></table></figure>
<p>这的确很棒。但当你尝试去用 Kotlin 去定义类似的方法是莫名的困难。从 Java 测调用没有什么不同，但是当从 Kotlin 调用时需要明确指定类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun registerCallback(r: View.OnClickListener)</div><div class="line">// Kotlin. Note that parenthesis are required now.</div><div class="line">registerCallback(View.OnClickListener &#123; /** do stuff */ &#125;)</div></pre></td></tr></table></figure>
<p>不得不说这很烦人，特别是当你从 Java 代码转换到 Kotlin 从而导致 Kotlin 代码不能再正常运行的时候。</p>
<p>常见的方式是用函数类型定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun registerCallback(r: () -&gt; Unit)</div></pre></td></tr></table></figure>
<p> 这样用 Kotlin 调用起来会很方便，但是由于所有的 Kotlin 函数都需要一个返回值，这导致用 Java 调用该函数的时候变得很糟。你不得不显式地从 Java 表达式返回 <code>Unit</code>，这导致 lambda 表达式不可用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> registerCallback(() -&gt; &#123;</div><div class="line">    /** do stuff */</div><div class="line">    return Unit.INSTANCE;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如果你在用 Kotlin 写库的话，根本找不到一个好的方式去实现一个高阶函数同时让 Java 和 Kotlin 都能方便的调用。在我的 <a href="https://github.com/ajalt/flexadapter" target="_blank" rel="external">FlexAdapter</a> 库里面，我尝试为为每个方法重载 <code>SAM interface</code> 或者 Kotlin 函数类型的参数。这样无论用这两种的哪种语言调用都很方便，但是库的 API 变得不简洁。</p>
<p>希望 Kotlin 的设计者们能够改变他们的想法在将来允许 <code>SAM</code> 转化成 Kotlin 的函数定义，但是我并不抱什么希望。</p>
<h3 id="Closed-by-default"><a href="#Closed-by-default" class="headerlink" title="Closed by default"></a>Closed by default</h3><p>到目前为止我说的所有关于 Kotlin 的缺点基本都是小的语法细节上的不简洁，并不是什么大事。但是，有一个设计在将来有可能导致巨大的痛苦：所有的类和方法默认都是封闭的。这种做法是被 <code>Effective Java</code> 里所推崇的，理论上听起来也很有道理，但对于任何一个需要使用一个有缺陷的第三方库的人来说都是一个坏的选择。</p>
<blockquote>
<p>把所有的叶类都设置成静态的。毕竟你在完成这样一个项目——没有人能够通过扩展你的类的方式来完善你的工作成果。或许是由于安全原因——毕竟，<code>java.lang.String</code> 是 <code>final</code> 不就是由于这个原因吗？如果你项目的其他的成员向你抱怨，就告诉他们这样能提高执行效率——<a href="http://www.mindprod.com/jgloss/unmaindesign.html" target="_blank" rel="external"><em>Roedy Green, How to Write Unmaintainable Code</em></a></p>
</blockquote>
<p>Kotlin 的文档里面的确有文章尝试去抵制这一决定，所以我把他们说的三个理由列出来。</p>
<h3 id="“Best-practices-say-that-you-should-not-allow-these-hacks-anyway”"><a href="#“Best-practices-say-that-you-should-not-allow-these-hacks-anyway”" class="headerlink" title="“Best practices say that you should not allow these hacks anyway”"></a>“Best practices say that you should not allow these hacks anyway”</h3><p>关于对继承封闭的论据基本是围绕「Fragile Base Class Problem」展开，它认为如果允许在你的库的基础上继承出子类，他们可能改变代码运行的方式从而导致一些 bug。然而这只是一种可能性，会导致库运行异常从而导致 bug 的方式实在太多了。如果你重写一个类的功能，很明显你应该为破坏代码的运行负责。</p>
<p>我之所以用「很明显」是因为重写一个库的功能是很明确的该有使用方自己负责。我已经辅导计算机科学学生很多年了，他们会范所有你能想象到的错误，但是他们从不会因为重载一个方法导致的破坏感到奇怪。实在有太多不经意的方式会导致对依赖库使用的破坏，例如你传递的参数类型是对的但单位却传错了，或者你忘了调用一个必须调用的方法。</p>
<p>我欣赏那种减少代码被破坏可能性的编码方式，把类设置成不可变的的确能达到效果。但可以确定的是所有依赖库一定不是完整的或者是存在缺陷的，你又不可避免的要使用这些依赖库。为了修改一个封闭类，人们常常会使用一些 hack 的方法，这经常会仅仅是重写一两个类或者方法带来的 bug 更多。如果你不相信我说的话，这里有一个活生生的例子，如果你是一个 Android 开发者的话，你应该印象深刻：</p>
<p>AppCompat 23.2.0 终于把 <a href="https://plus.google.com/+AndroidDevelopers/posts/iTDmFiGrVne" target="_blank" rel="external">VectorDrawables</a> 加到 support 包里了。由于可以帮助减少 APK 的体积和内存的占用，要不是它有一个 bug <a href="https://code.google.com/p/android/issues/detail?id=205236" target="_blank" rel="external">会导致在 Activity 里面导致内存泄露</a><br>，本应该收到广泛欢迎。这个支持包在 <a href="https://plus.google.com/+AndroidDevelopers/posts/iTDmFiGrVne" target="_blank" rel="external">几周后被移除</a>。</p>
<p>内存泄露是怎么导致的呢？为了 <a href="https://medium.com/@chrisbanes/appcompat-v23-2-age-of-the-vectors-91cbafa87c88" target="_blank" rel="external">提高 VectorDrawable 填充性能</a>，这个支持包的作者们需要改进 <code>Context.getDrawable</code> 的实现。但是这个方法是不可变的（final），所以他们不得不为每一个视图创建一份 <code>Resources wrapper</code> 的拷贝来处理 <em>VectorDrawables</em>。且不说这带来了大量的工作，这也导致大量的 <code>wrapped Resources</code> 变得不同步和为了复制产生的大量内存开销。如果那个方法不是不可变的，他们就不会这样胡搞了。</p>
<h3 id="“People-successfully-use-other-languages-C-C-that-have-similar-approach”"><a href="#“People-successfully-use-other-languages-C-C-that-have-similar-approach”" class="headerlink" title="“People successfully use other languages (C++, C#) that have similar approach”"></a>“People successfully use other languages (C++, C#) that have similar approach”</h3><p>人们在 Python 这样的语言可以在任何时候做任何修改。Python 也有像 <code>_asdict</code> 这样「非公有」不会在文档里描述的方法。它也有像 <code>__intern</code> 这样的 <a href="https://zh.wikipedia.org/wiki/Visual_C%2B%2B%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0" target="_blank" rel="external">name mangled</a> 的函数，很难被发现。你可以自由的用 monkey-patch 或者重写任何一个你想重写的方法，Python 并不禁止这样做。</p>
<p>在我五年全职开发 Python 的期间，我从没有想过谁会通过重写方法破坏我的代码。我能想象在大多数情况下，用正确安全的方法去改变一个私有方法比由于 Python 的禁止而不得不重新实现一个同样的功能更加节约时间。</p>
<p>我并不是说要盲目地把每个类的实现都要改一遍，但是没有理由当我想这么做的时候却做不了。在 Python 社区里面有一句俗语 “We’re all consenting adults here”。你想对我的类做任何修改都可以。</p>
<h3 id="“If-people-really-want-to-hack-there-still-are-ways-you-can-always-write-your-hack-in-Java-and-call-it-from-Kotlin-see-Java-Interop-and-Aspect-frameworks-always-work-for-these-purposes”"><a href="#“If-people-really-want-to-hack-there-still-are-ways-you-can-always-write-your-hack-in-Java-and-call-it-from-Kotlin-see-Java-Interop-and-Aspect-frameworks-always-work-for-these-purposes”" class="headerlink" title="“If people really want to hack, there still are ways: you can always write your hack in Java and call it from Kotlin (see Java Interop), and Aspect frameworks always work for these purposes”"></a>“If people really want to hack, there still are ways: you can always write your hack in Java and call it from Kotlin (see Java Interop), and Aspect frameworks always work for these purposes”</h3><p>这真是一个荒诞的论点。即使是用 Java 如果你不用很难令人接受的反射的话，你依然不能重写封闭的 Kotlin 函数，所以这个论调无足轻重。</p>
<p>不能对依赖库进行扩展意味着想要添加任何新的特性和修改 bug 都很难。现实中，大多数库都需要使用一些黑客的手段。这就是现实，而且不会改变。任何库的作者都不能预测所有用户可能碰到的场景。所有的类都是不可变的只能让库的使用者实现库本身没有的功能的时候变得更加困难。相对于 Kotlin 其他语言特性的便利性，这个设计实在是太令人费解了。</p>
<p>如果你在编写一个 Kotlin 的依赖库，请把你所有的公开方法都设置成开放的。这会让你的用户更加方便。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Kotlin 是一门非常棒的语言。它比 Java 简洁多了，它还有一个非常优秀的标准库，有了这个标准库你就可以将大量为了维持 Java 勉强可用下去的库都删掉了。多亏了代码自动转换功能，你可以很方便的把 Java 代码转换成 Koltin 代码，并且这个功能会越来越完善。如果你是一名 Android 开发者，你真应该去试一试。</p>
<p>原文链接：<a href="http://ohmerhe.com/2016/08/27/kotlin_good_bad_bugly/" target="_blank" rel="external">Kotlin：The Good, The Bad, and The Ugly(译)</a></p>
<p>英文原文：<a href="https://medium.com/keepsafe-engineering/kotlin-the-good-the-bad-and-the-ugly-bf5f09b87e6f#.s0t91g9xn" target="_blank" rel="external">Kotlin: The Good, The Bad, and The Ugly</a></p>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>[1]</strong> In the case of a <em>lateinit </em>property,<em>kotlin.UninitializedPropertyAccessException </em>will be thrown, where the<em>Delegates.notNull </em>will throw an <em>IllegalStateException</em>.</li>
<li><strong>[2]</strong> There are some details about <em>lateinit </em>that are worth noting, especially if you plan on accessing a <em>lateinit </em>property from Java code. First is that <em>lateinit</em>cannot be applied to primitive types such as <em>Int </em>or <em>Double</em>. The second is that a <em>lateinit </em>property is backed by a field with the same visibility as the property, and this field is visible from Java. Additionally, that backing field can be freely set to null from Java. If any of those are issues for your use case, <em>Delegates.notNull </em>may be a better choice.</li>
<li><strong>[3]</strong> The lazy <em>Sequence </em>operators can outperform the eager versions by up to 20%, but only once list sizes start growing very large. For lists under a megabyte or so in size, the lazy versions often perform the same or worse than the eager versions.</li>
<li><strong>[4]</strong> This is a bit of a simplification. Kotlin will only generate a backing field if you don’t define a get function, or if the defined get function doesn’t reference the implicit<em> field </em>identifier.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tags: Kotlin, Android&lt;/p&gt;
&lt;p&gt;在我的 &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇文章&lt;/a&gt;, 谈到了关于转换 Java 到 Kotlin 代码和我喜欢的一些库。现在，我想要谈谈关于 Kotlin 这门语言本身的想法，还有它和 Java 交互的方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 一个扩展函数，从此丢掉 ViewHolder</title>
    <link href="http://yoursite.com/2016/08/02/kotlin_one_method_no_viewholder/"/>
    <id>http://yoursite.com/2016/08/02/kotlin_one_method_no_viewholder/</id>
    <published>2016-08-02T15:57:49.000Z</published>
    <updated>2017-05-19T16:03:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>tags: Android, Kotlin</p>
<h2 id="ViewHolder"><a href="#ViewHolder" class="headerlink" title="ViewHolder"></a>ViewHolder</h2><p>作为一名 Android 开发者，对 ViewHolder 应该再熟悉不过了。ViewHolder 一开始并不是 Android 原生提供的（现在已经是 RecycleView 的默认实现了），而是 Google 为了提高 ListView 的使用性能，为开发者提供的一种最佳实践，具体可以参考 <a href="https://developer.android.com/training/improving-layouts/smooth-scrolling.html#ViewHolder" target="_blank" rel="external">ViewHolder</a>。</p>
<a id="more"></a>
<p>Google 提供的 ViewHolder 的标准实现如下，熟悉者可以直接跳到下个部分「ViewHolder变种」继续阅读。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</div><div class="line">  TextView text;</div><div class="line">  TextView timestamp;</div><div class="line">  ImageView icon;</div><div class="line">  ProgressBar progress;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 Item 第一次创建视图的时候，填充 ViewHolder 并且将其保存在视图中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ViewHolder holder = <span class="keyword">new</span> ViewHolder();</div><div class="line">holder.icon = (ImageView) convertView.findViewById(R.id.listitem_image);</div><div class="line">holder.text = (TextView) convertView.findViewById(R.id.listitem_text);</div><div class="line">holder.timestamp = (TextView) convertView.findViewById(R.id.listitem_timestamp);</div><div class="line">holder.progress = (ProgressBar) convertView.findViewById(R.id.progress_spinner);</div><div class="line">convertView.setTag(holder);</div></pre></td></tr></table></figure>
<p>在填充 Item 数据的时候，直接使用 Viewholder 对象的属性，这样可以减少在滚动 ListView 频繁调用 <code>findViewById()</code> 而导致的性能问题。</p>
<h2 id="ViewHolder变种"><a href="#ViewHolder变种" class="headerlink" title="ViewHolder变种"></a>ViewHolder变种</h2><p>Google 提供的 ViewHolder 的确能够提升 ListView 的使用效率，但是 ViewHolder 的实现相对繁琐，需要为每一种 Item 定义一个 ViewHolder，对代码书写和维护都是额外的开销。于是有人针对 ViewHolder 的实现做了一些优化，让 ViewHolder 写起来更方便。网上有很多种写法，我最认可的是下面的这种实现，简单优雅。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class ViewHolder &#123;    </div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)  </div><div class="line">    public static &lt;T extends View&gt; T get(View view, int id) &#123;  </div><div class="line">        SparseArray&lt;View&gt; viewHolder = (SparseArray&lt;View&gt;) view.getTag();  </div><div class="line">        if (viewHolder == null) &#123;  </div><div class="line">            viewHolder = new SparseArray&lt;View&gt;();  </div><div class="line">            view.setTag(viewHolder);  </div><div class="line">        &#125;  </div><div class="line">        View childView = viewHolder.get(id);  </div><div class="line">        if (childView == null) &#123;  </div><div class="line">            childView = view.findViewById(id);  </div><div class="line">            viewHolder.put(id, childView);  </div><div class="line">        &#125;  </div><div class="line">        return (T) childView;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用 <code>SparseArray</code> 映射每个视图 <code>id</code> 和对应的视图，并将其保存在视图中，这样既保证在滚动过程中频繁获取视图的效率，使用起来也极其方便。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ImageView bananaView = ViewHolder.get(convertView, R.id.banana);  </div><div class="line">TextView phoneView = ViewHolder.get(convertView, R.id.phone);  </div><div class="line">BananaPhone bananaPhone = getItem(position);  </div><div class="line">phoneView.setText(bananaPhone.getPhone());</div></pre></td></tr></table></figure>
<h2 id="Kotlin-扩展函数"><a href="#Kotlin-扩展函数" class="headerlink" title="Kotlin 扩展函数"></a>Kotlin 扩展函数</h2><p>这里Kotlin 实现 ViewHolder 的扩展函数和上面的变种使用的同一种思路，但得益于 Kotlin 语言提供的特性，实现和使用起来更加方便流畅，甚至都感觉不到 ViewHolder 这种特殊机制的存在。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : View&gt;</span> View.<span class="title">findViewOften</span><span class="params">(viewId: <span class="type">Int</span>)</span></span>: T &#123;</div><div class="line">    <span class="keyword">var</span> viewHolder: SparseArray&lt;View&gt; = tag <span class="keyword">as</span>? SparseArray&lt;View&gt; ?: SparseArray()</div><div class="line">    tag = viewHolder</div><div class="line">    <span class="keyword">var</span> childView: View? = viewHolder.<span class="keyword">get</span>(viewId)</div><div class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == childView) &#123;</div><div class="line">        childView = findViewById(viewId)</div><div class="line">        viewHolder.put(viewId, childView)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> childView <span class="keyword">as</span> T</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里实现了一个 View 的扩展函数 <code>findViewOften(viewId: Int)</code> 意味着在需要频繁寻找一个视图的子视图的情况下使用，这样我们在 Item 中就可以这样写了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val subTitle: TextView = convertView.findViewOften(R.id.list_item_subtitle)</div><div class="line">subTitle.text = itemData.subTitle</div></pre></td></tr></table></figure>
<p>由于 Kotlin 提供类型推断功能，所以 <code>findViewOften</code> 的返回值不用手动转换或者手动指定泛型类型。</p>
<p>利用 Kotlin 的语言特性，为 View 扩展一个方法，从此再也不用繁琐的定义 Viewholder 了，使用的时候也是如此的顺畅，从此再也不必记得什么 ViewHolder 了。</p>
<p>PS: 该方法在 <a href="https://github.com/KotlinThree/AndroidExtension" target="_blank" rel="external">AndroidExtension</a> 已经提供封装，这个库里面还封装了一些其他方法，也蛮好用的，不过这个库还没有正式发布。</p>
<h2 id="RecycleView-的-ViewHolder"><a href="#RecycleView-的-ViewHolder" class="headerlink" title="RecycleView 的 ViewHolder"></a>RecycleView 的 ViewHolder</h2><p>最后，不得不提一下在 RecycleView 应该怎么办，因为在 RecycleView 的机制里面，在创建 Item 的 View 的时候，必须创建一个 RecyclerView.ViewHolder 并且返回。对于我们上面那么完美的封装， Google 这明显是在帮倒忙，还好这忙虽然帮倒了，不过还不至于无法挽回。</p>
<p>如果大家在使用 RecycleView 还想使用本文提供的方法的话，可以参考我下面的方式实现。提供一个 RecyclerView.ViewHolder 默认实现类，该类提供一个通过 <code>id</code> 获取视图的方法，在创建 Item 的 View 的时候默认都返回这个类的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class MyViewHolder(val convertView: View) : RecyclerView.ViewHolder(convertView) &#123;</div><div class="line">    	fun &lt;T : View&gt; findView(viewId: Int): T &#123;</div><div class="line">        return convertView.findViewOften(viewId)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不想 <code>MyViewHolder</code> 的外部有不需要的依赖，可以将 <code>findViewOften</code> 直接实现在 <code>MyViewHolder</code> 里面。</p>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.android.com/training/improving-layouts/smooth-scrolling.html#ViewHolder" target="_blank" rel="external">ViewHolder</a></li>
<li><a href="http://www.programcreek.com/java-api-examples/android.util.SparseArray" target="_blank" rel="external">Java Code Examples for android.util.SparseArray</a></li>
<li><a href="https://github.com/KotlinThree/AndroidExtension" target="_blank" rel="external">AndroidExtension</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tags: Android, Kotlin&lt;/p&gt;
&lt;h2 id=&quot;ViewHolder&quot;&gt;&lt;a href=&quot;#ViewHolder&quot; class=&quot;headerlink&quot; title=&quot;ViewHolder&quot;&gt;&lt;/a&gt;ViewHolder&lt;/h2&gt;&lt;p&gt;作为一名 Android 开发者，对 ViewHolder 应该再熟悉不过了。ViewHolder 一开始并不是 Android 原生提供的（现在已经是 RecycleView 的默认实现了），而是 Google 为了提高 ListView 的使用性能，为开发者提供的一种最佳实践，具体可以参考 &lt;a href=&quot;https://developer.android.com/training/improving-layouts/smooth-scrolling.html#ViewHolder&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ViewHolder&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>NullPointException 利器 Kotlin 可选型</title>
    <link href="http://yoursite.com/2016/07/14/kotlin-type-option/"/>
    <id>http://yoursite.com/2016/07/14/kotlin-type-option/</id>
    <published>2016-07-14T10:52:57.000Z</published>
    <updated>2017-05-19T15:57:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>tags: Kotlin</p>
<p>NullPointException (简称 NPE ) 被称作 <a href="https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions" target="_blank" rel="external">The Billion Dollar Mistake</a> 一直困扰着Java 和 Android 开发者。Kotlin 的类型系统中提供可选类型用于减少 NPE 问题带来的风险。</p>
<a id="more"></a>
<p>虽然，Kotlin 提供了可选类型用于减少 NPE 问题的风险，但是并没有办法完全消除 NPE 带来的隐患，本问将探讨如何巧妙地使用「可选型」更好的规避 NPE 的发生。</p>
<h2 id="可选型定义"><a href="#可选型定义" class="headerlink" title="可选型定义"></a>可选型定义</h2><h3 id="非空类型"><a href="#非空类型" class="headerlink" title="非空类型"></a>非空类型</h3><p>我们先从可选型的定义开始，当我们在 Kotlin 中定义一个变量时，默认就是非空类型的，当你将一个非空类型置空的时候，编译器会告诉你这不可行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a: String = <span class="string">"abc"</span></div><div class="line">a = <span class="literal">null</span> <span class="comment">// compilation error</span></div></pre></td></tr></table></figure>
<p>因此，如果你后面任何时候使用该变量时，都可以放心的使用而不用担心会发生 NPE。所以要想远离 NPE，首先需要<strong>「尽可能的使用非空类型的定义」</strong>。</p>
<h3 id="可选型（可空类型）"><a href="#可选型（可空类型）" class="headerlink" title="可选型（可空类型）"></a>可选型（可空类型）</h3><p>虽然「非空类型」能够有效避免 NPE 的问题，但是有时候我们总不可避免的需要使用「可选类型」。在定义可选型的时候，我们只要在非空类型的后面添加一个 <code>?</code> 就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b: String? = <span class="string">"abc"</span></div><div class="line">b = <span class="literal">null</span> <span class="comment">// ok</span></div></pre></td></tr></table></figure>
<p>在使用可选型变量的时候，这个变量就有可能为空，所以在使用前我们应该对其进行空判断（在 Java 中我们经常这样做），这样往往带来带来大量的工作，这些空判断代码本身没有什么实际意义，并且让代码的可读性和简洁性带来了巨大的挑战。在网上可以看到许多人针对如何减少 NPE 提出了自己的建议，有的的确很不错，但成本依然很大。除此之外，还有一个最可恶的场景「我们会忘记」。</p>
<p>Kotlin 为了解决这个问题，它并不允许我们直接使用一个可选型的变量去调用方法或者属性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l = b.length <span class="comment">// compilation error</span></div></pre></td></tr></table></figure>
<p>你可以和 Java 中一样，在使用变量之前先进行空判断，然后再去调用。如果使用这种方法，那么空判断是必须的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l = <span class="keyword">if</span> (b != <span class="literal">null</span>) b.length <span class="keyword">else</span> <span class="number">-1</span></div></pre></td></tr></table></figure>
<p><strong>注意： 如果你定义的变量是全局变量，即使你做了空判断，依然不能使用变量去调用方法或者属性。</strong>这个时候你需要考虑使用下面的介绍的方法。</p>
<p>Kotlin 为可选型提供了一个安全调用操作符 <code>?.</code>，使用该操作符可以方便调用可选型的方法或者属性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l = b?.length</div></pre></td></tr></table></figure>
<p>这里 <code>l</code> 得到的返回依然是一个可选型 <code>Int?</code>。</p>
<p>Kotlin 还提供了一个强转的操作符 <code>!!</code>，这个操作符能够强行调用变量的方法或者属性，而不管这个变量是否为空，如果这个时候该变量为空时，那么就会发生 NPE。所以如果不想继续陷入 NPE 的困境无法自拔，请不要该操作符走的太近。</p>
<h2 id="Elvis-操作符"><a href="#Elvis-操作符" class="headerlink" title="Elvis 操作符"></a><code>Elvis</code> 操作符</h2><p>上面有提到一种情况，当 <code>b</code> 为空时，返回它的长度值给一个默认值 -1。要实现这样的逻辑当然可以用 <code>ifelse</code> 的逻辑判断实现，但 Kotlin 提供了一个更优雅的书写方式 <code>?:</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l = b?.length ?: <span class="number">-1</span></div></pre></td></tr></table></figure>
<p><code>b?.length ?: -1</code> 和 <code>if (b != null) b.length else -1</code> 完全等价的。</p>
<p>其实你还可以在 <code>?:</code> 后面添加任何表达式，比如你可以在后面会用 <code>return</code> 和 <code>throw</code>（在 Kotlin 中它们都是表达式）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(node: <span class="type">Node</span>)</span></span>: String? &#123;</div><div class="line">  <span class="keyword">val</span> parent = node.getParent() ?: <span class="keyword">return</span> <span class="literal">null</span></div><div class="line">  <span class="keyword">val</span> name = node.getName() ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"name expected"</span>)</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="let-函数"><a href="#let-函数" class="headerlink" title="let 函数"></a><code>let</code> 函数</h2><p><code>let</code> 是官方 <code>stdlib</code> 提供的标准函数库里面的函数，这个函数巧妙的利用的 Kotlin 语言的特性让 <code>let</code> 接受的表达式参数中的调用方是非空的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> listWithNulls: List&lt;String?&gt; = listOf(<span class="string">"A"</span>, <span class="literal">null</span>)</div><div class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> listWithNulls) &#123;</div><div class="line">    item?.let &#123; println(it) &#125; <span class="comment">// prints A and ignores null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码的只会输出 <code>A</code>，而不会输出 <code>null</code>。</p>
<p><strong>需要注意的是，这个方法调用的时候必须要使用 <code>?.</code> 操作符调用才能生效哦。</strong>如果你的部分代码依赖于一个可选型变量为非空的时候，就可以使用 <code>let</code> 函数。</p>
<p>参考这个函数的实现，下面我尝试提供几个自己定义的方法。</p>
<h2 id="自定义处理"><a href="#自定义处理" class="headerlink" title="自定义处理"></a>自定义处理</h2><p>这里定义的两个方法是参考 <code>Swift</code> 里面的 <code>if let</code> 和 <code>guard</code> 进行的抽象。</p>
<h3 id="orElse-函数"><a href="#orElse-函数" class="headerlink" title="orElse 函数"></a><code>orElse</code> 函数</h3><p><code>orElse</code> 是和 <code>Elvis</code> 函数结合使用的，默认 <code>Elvis</code> 后面只能直接或者执行一个表达式获取返回值或者直接通过 <code>return</code> 或者 <code>throw</code> 结束当前函数的执行。结合 <code>orElse</code> 函数，你能够更加灵活的处理前面的 <code>null</code>。</p>
<ul>
<li>你可以处理一些逻辑以后，再返回一个可用的值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a:String? = <span class="literal">null</span></div><div class="line"><span class="keyword">var</span> b = a ?: orElse &#123;</div><div class="line">	<span class="comment">// 做任何事</span></div><div class="line">   <span class="keyword">return</span><span class="symbol">@orElse</span> <span class="string">"s"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>也可以处理一些逻辑后， 通过<code>return</code> 或者 <code>throw</code> 结束当前函数的执行。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a:String? = <span class="literal">null</span></div><div class="line"><span class="keyword">var</span> b = a ?: orElse &#123;</div><div class="line">	<span class="comment">// 做任何事</span></div><div class="line">   <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="guard-函数"><a href="#guard-函数" class="headerlink" title="guard 函数"></a><code>guard</code> 函数</h3><p><code>Elvis</code> 默认只能对单个变量或表达式是否为空进行处理，当碰到多个变量需要一起判断时，就会束手无策，<code>guard</code> 就是为了解决这个问题。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fun testGuard(a: String?, b: String?, c: String?)&#123;</div><div class="line">	guard(a, b, c) ?: orElse &#123;</div><div class="line">        print("a or b or c is null </div><div class="line">")</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    // 现在 `a`，`b`，`c` 都是不为空</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于没有编译器的支持，所以暂时还不能实现 <a href="https://kotlinlang.org/docs/reference/null-safety.html#checking-for-null-keyword--in-conditions" target="_blank" rel="external">空屏蔽</a>。</p>
<p>这里定义的两个函数的实现，你可以自己尝试去实现一下，就当是个练习（鬼笑）。<a href="https://github.com/KotlinThree/AndroidExtension" target="_blank" rel="external">AndroidExtension</a>有具体的实现代码。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过一系列分析以后，我们已经对怎么使用好 Kotlin 可选型有一定的了解，如果不想 NPE 问题不断困扰，可以参考这里总结的几条。</p>
<ul>
<li>尽可能的使用非空类型的定义</li>
<li>远离 <code>!!</code>，如果非要用，请调用代码在前面「三行之内」进行非空判断</li>
<li>熟练使用 <code>Elvis</code> 操作符</li>
<li>自定义一些常用的函数，让自己的代码更流畅</li>
</ul>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://kotlinlang.org/docs/reference/null-safety.html" target="_blank" rel="external">null-safety</a></li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0056-trailing-closures-in-guard.md" target="_blank" rel="external">trailing-closures-in-guard</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tags: Kotlin&lt;/p&gt;
&lt;p&gt;NullPointException (简称 NPE ) 被称作 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The Billion Dollar Mistake&lt;/a&gt; 一直困扰着Java 和 Android 开发者。Kotlin 的类型系统中提供可选类型用于减少 NPE 问题带来的风险。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 函数式编程三板斧</title>
    <link href="http://yoursite.com/2016/07/05/kotlin_function_three_common_methods/"/>
    <id>http://yoursite.com/2016/07/05/kotlin_function_three_common_methods/</id>
    <published>2016-07-05T14:06:41.000Z</published>
    <updated>2017-05-19T16:03:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>tags: kotlin, 函数式编程, map, filter, reduce</p>
<p>每个函数式语言都提供及几大类基本函数，这些函数在功能上一般都极为相似，但是在名称和调用方法上可能有一些细微的差别。今天就讲讲 <code>Kotlin</code> 中提供的函数式编程三板斧<code>filter</code>、<code>map</code>、<code>reduce</code>。</p>
<a id="more"></a>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>筛选函数将用户给定的布尔逻辑作用于集合，返回由原集合中符合条件的元素组合的一个子集。假设一个逻辑，将数组中是3的倍数的数筛选出来，和 <code>Java</code> 做一个简单的对比。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java 代码</span></div><div class="line"><span class="keyword">int</span>[] all = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</div><div class="line">List&lt;Integer&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a : all) &#123;</div><div class="line">    <span class="keyword">if</span> (a % <span class="number">3</span> == <span class="number">0</span>) &#123;</div><div class="line">        filters.add(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Kotlin 代码</span></div><div class="line"><span class="keyword">val</span> all = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</div><div class="line"><span class="keyword">val</span> filters = all.filter &#123; it % <span class="number">3</span> == <span class="number">0</span> &#125;</div></pre></td></tr></table></figure>
<p>Kotlin 还提供一系列类似的过滤函数：</p>
<ul>
<li><code>filterIndexed</code>, 同 <code>filter</code>，不过在逻辑判断的方法块中可以拿到当前item的index</li>
<li><code>filterNot</code>，与<code>filter</code>相反，只返回不符合条件的元素组合</li>
</ul>
<p>针对 <code>Map</code> 类型数据集合，提供了 <code>filterKeys</code> 和 <code>filterValues</code> 方法，方便只做 key 或者 value 的判断。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>映射函数也是一个高阶函数，将一个集合经过一个传入的变换函数映射成另外一种集合。</p>
<p>假设我们现在需要将一系列的名字的长度保存到另一个数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java 代码</span></div><div class="line">String[] names = &#123;<span class="string">"James"</span>, <span class="string">"Tom"</span>, <span class="string">"Jack"</span>, <span class="string">"Kobe"</span>&#125;;</div><div class="line"><span class="keyword">int</span>[] namesLength = <span class="keyword">new</span> <span class="keyword">int</span>[names.length];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.length ; i ++) &#123;</div><div class="line">    namesLength[i] = names[i].length();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Kotlin 代码</span></div><div class="line"><span class="keyword">val</span> names = arrayOf(<span class="string">"James"</span>, <span class="string">"Tom"</span>, <span class="string">"Jack"</span>, <span class="string">"Kobe"</span>);</div><div class="line"><span class="keyword">val</span> namesLength = names.map &#123; it.length &#125;</div></pre></td></tr></table></figure>
<p>映射函数是将一个集合映射成另外一种集合，所以当你需要见一个 HaspMap 映射成一个 List 的时候，会非常方便。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> params = mapOf(<span class="string">"limit"</span> to <span class="string">"10"</span>, <span class="string">"offset"</span> to <span class="string">"20"</span>, <span class="string">"order"</span> to <span class="string">"asc"</span>)</div><div class="line"><span class="keyword">val</span> s = params.map &#123; <span class="string">"<span class="subst">$&#123;it.key&#125;</span>=<span class="subst">$&#123;it.value&#125;</span>"</span> &#125;.joinToString(<span class="string">"&amp;"</span>)</div><div class="line"><span class="comment">// s = limit=10&amp;offset=20&amp;order=asc</span></div></pre></td></tr></table></figure>
<p>同 <code>filter</code> 相似，Kotlin 也提供的 <code>mapIndexed</code> 的类似方法方便使用，针对 <code>Map</code> 类型的集合也有 <code>mapKeys</code> 和 <code>mapValues</code> 的封装。</p>
<h2 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h2><p>归纳函数将一个数据集合的所有元素通过传入的操作函数实现数据集合的积累叠加效果。</p>
<p>假设我们需要将一首藏头诗的每句诗的第一句拿出来拼成一句话。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java 代码</span></div><div class="line">String[] texts = &#123;<span class="string">"芦花丛中一扁舟"</span>, <span class="string">"俊杰俄从此地游"</span>, <span class="string">"义士若能知此理"</span>, <span class="string">"反躬难逃可无忧"</span>&#125;;</div><div class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; texts.length ; i ++) &#123;</div><div class="line">    sb.append(texts[i].substring(<span class="number">0</span>, <span class="number">1</span>));</div><div class="line">&#125;</div><div class="line">String result = sb.toString();</div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Kotlin 代码</span></div><div class="line"><span class="keyword">val</span> texts = arrayOf(<span class="string">"芦花丛中一扁舟"</span>, <span class="string">"俊杰俄从此地游"</span>, <span class="string">"义士若能知此理"</span>, <span class="string">"反躬难逃可无忧"</span>)</div><div class="line"><span class="keyword">val</span> result = texts.map &#123; it.substring(<span class="number">0</span>,<span class="number">1</span>) &#125;.reduce &#123; r, s -&gt; <span class="string">"<span class="subst">$r</span><span class="subst">$s</span>"</span>&#125;</div></pre></td></tr></table></figure>
<p>最后得到的结果是「卢俊义反」。</p>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程的精髓在于函数本身。在函数式编程中函数是第一等公民，与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p>
<p>函数式编程好的实践在于对运算过程的高度抽象和没有”副作用”（既保持函数的独立性），函数式编程三板斧是函数式编程的典型范式，在编程中被大量使用，即使人们不关注函数式编程，在使用函数式编程语言的时候，也会不自觉的使用这些函数。</p>
<p>函数式编程是一种思维方式，函数式编程鼓励放弃对状态的维持（是命令式编程的基础），将所有的操作都交给运行时去执行。当然为了保证程序运行的效率，这需要提供一些辅助性的手段（缓存、缓求值等）。</p>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://book.douban.com/subject/26587213/" target="_blank" rel="external">函数式编程思维</a></li>
<li><a href="http://baike.baidu.com/view/1711147.htm" target="_blank" rel="external">函数式编程</a></li>
<li><a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="external">kotlin doc</a></li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/" target="_blank" rel="external">kotlin api doc</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tags: kotlin, 函数式编程, map, filter, reduce&lt;/p&gt;
&lt;p&gt;每个函数式语言都提供及几大类基本函数，这些函数在功能上一般都极为相似，但是在名称和调用方法上可能有一些细微的差别。今天就讲讲 &lt;code&gt;Kotlin&lt;/code&gt; 中提供的函数式编程三板斧&lt;code&gt;filter&lt;/code&gt;、&lt;code&gt;map&lt;/code&gt;、&lt;code&gt;reduce&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="函数式编程" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 实现配置化网络请求</title>
    <link href="http://yoursite.com/2016/06/13/kotlin_config_http_kolley/"/>
    <id>http://yoursite.com/2016/06/13/kotlin_config_http_kolley/</id>
    <published>2016-06-13T12:23:05.000Z</published>
    <updated>2017-05-19T15:57:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin官方提供一个DSL的典型应用场景，<a href="https://github.com/Kotlin/anko" target="_blank" rel="external">Anko</a>致力直接用Kotlin配置页面布局和视图的属性。将布局文件代码化能够带来许多如类型安全、解析效率、代码重用等好处，而<code>Anko</code>让代码布局和XML一样简洁清晰。</p>
<a id="more"></a>
<p>受到<code>Anko</code>的启发，让我萌生了把<code>Android</code>中网络请求纷繁复杂配置信息也封装成配置化方式，实现如下方式的网络请求。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Http.<span class="keyword">get</span> &#123;</div><div class="line">    url = <span class="string">"http://api.openweathermap.org/data/2.5/weather"</span></div><div class="line">    headers &#123;</div><div class="line">        <span class="string">"Content-Type"</span> - <span class="string">'application/json'</span></div><div class="line">        <span class="string">"pragma-token"</span> - <span class="string">'33162acxxxxxx5032ad21e0e79ff70d'</span></div><div class="line">    &#125;</div><div class="line">    params &#123;</div><div class="line">        <span class="string">"q"</span> - <span class="string">"shanghai"</span></div><div class="line">        <span class="string">"appid"</span> - <span class="string">"d7a98cf22463b1c0c3df4adfe5abbc77"</span></div><div class="line">    &#125;</div><div class="line">    onSuccess &#123; bytes -&gt;</div><div class="line">        <span class="comment">// handle data</span></div><div class="line">    &#125;</div><div class="line">    onFail &#123; error -&gt;</div><div class="line">        <span class="comment">// handle error</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>目前该框架已经完成，后面还会继续完善，项目地址<a href="https://github.com/ohmerhe/Kolley" target="_blank" rel="external">Kolley</a></p>
<p>奔着这个目标，我把之前自己简单封装的Volley库翻出来，用Kotlin重新封装一下。经过分析总体过程大概如下：</p>
<ul>
<li>基础代码转Kotlin</li>
<li>重定义原子Request</li>
<li>Request构造配置化</li>
<li>提供RESTful方法</li>
</ul>
<h2 id="基础代码转Kotlin"><a href="#基础代码转Kotlin" class="headerlink" title="基础代码转Kotlin"></a>基础代码转Kotlin</h2><p>之前的框架是参考<a href="https://github.com/loopj/android-async-http" target="_blank" rel="external">android-async-http</a>做的封装，用<code>okhttp</code>作为网络请求引擎，图片请求缓存模块使用的<code>jakewharton</code>提供的<code>disklrucache</code>，这两块都可以复用，先将这部分代码直接转成<code>Kotlin</code>实现。</p>
<p>这不需要花太多的功夫，将java代码复制过来以后，直接使用Android Studio的快速转换功能，转换后可能会有一些语法上的错误，稍微处理一下就可以了，得到类似的内容。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OkHttpStack</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(client: OkHttpClient = OkHttpClient()) : HurlStack() &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mFactory: OkUrlFactory</div><div class="line">    init &#123;</div><div class="line">        mFactory = OkUrlFactory(client)</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Throws(IOException::class)</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createConnection</span><span class="params">(url: <span class="type">URL</span>)</span></span>: HttpURLConnection &#123;</div><div class="line">        <span class="keyword">return</span> mFactory.<span class="keyword">open</span>(url)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重定义原子Request"><a href="#重定义原子Request" class="headerlink" title="重定义原子Request"></a>重定义原子Request</h2><p>需要在Volley提供的<code>Request</code>基础上继承一个<code>BaseRequest</code>预处理一些信息，如params。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByteRequest</span></span>(method: <span class="built_in">Int</span>, url: String, errorListener: Response.ErrorListener? = Response.ErrorListener &#123;&#125;)</div><div class="line">: BaseRequest&lt;ByteArray&gt;(method, url, errorListener) &#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseNetworkResponse</span><span class="params">(response: <span class="type">NetworkResponse</span>?)</span></span>: Response&lt;ByteArray&gt;? &#123;</div><div class="line">        <span class="keyword">return</span> Response.success(response?.<span class="keyword">data</span>, HttpHeaderParser.parseCacheHeaders(response))</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseRequest</span>&lt;<span class="type">D</span>&gt;</span>(method: <span class="built_in">Int</span>, url: String, errorListener: Response.ErrorListener? = Response.ErrorListener &#123;&#125;)</div><div class="line">: Request&lt;D&gt;(method, url, errorListener) &#123;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> DEFAULT_CHARSET = <span class="string">"UTF-8"</span></div><div class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _listener: Response.Listener&lt;D&gt;? = <span class="literal">null</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> _params: MutableMap&lt;String, String&gt; = HashMap() <span class="comment">// used for a POST or PUT request.</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns a Map of parameters to be used for a POST or PUT request.</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getParams</span><span class="params">()</span></span>: MutableMap&lt;String, String&gt; &#123;</div><div class="line">        <span class="keyword">return</span> _params</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">deliverResponse</span><span class="params">(response: <span class="type">D</span>?)</span></span> &#123;</div><div class="line">        _listener?.onResponse(response)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</div><div class="line">            Log.d(<span class="keyword">this</span>.javaClass.simpleName, msg)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Request构造配置化"><a href="#Request构造配置化" class="headerlink" title="Request构造配置化"></a>Request构造配置化</h2><p>上一步封装的<code>Request</code>必须在构造器中提供一些参数，并且像<code>Listener</code>这样的参数不能直接传递表达式，为配置化调用的封装提供了一定的困难。需要重新封装一个<code>Request</code>构造器，再在最后交给执行队列的时候创建真正的<code>Request</code>传递给它，这样让所有网络请求需要的配置信息都可以很方便的构造。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseRequestWapper</span></span>() &#123;</div><div class="line">    <span class="keyword">internal</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> _request: ByteRequest</div><div class="line">    <span class="keyword">var</span> url: String = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> method: <span class="built_in">Int</span> = Request.Method.GET</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _start: (() -&gt; <span class="built_in">Unit</span>) = &#123;&#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _success: (ByteArray) -&gt; <span class="built_in">Unit</span> = &#123;&#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _fail: (VolleyError) -&gt; <span class="built_in">Unit</span> = &#123;&#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _finish: (() -&gt; <span class="built_in">Unit</span>) = &#123;&#125;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> _params: MutableMap&lt;String, String&gt; = HashMap() <span class="comment">// used for a POST or PUT request.</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> _headers: MutableMap&lt;String, String&gt; = HashMap()</div><div class="line">    <span class="keyword">var</span> tag: Any? = <span class="literal">null</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">(onStart: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        _start = onStart</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(onError: (<span class="type">VolleyError</span>)</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        _fail = onError</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(onSuccess: (<span class="type">ByteArray</span>)</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        _success = onSuccess</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onFinish</span><span class="params">(onFinish: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        _finish = onFinish</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">params</span><span class="params">(makeParam: <span class="type">RequestPairs</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        <span class="keyword">val</span> requestPair = RequestPairs()</div><div class="line">        requestPair.makeParam()</div><div class="line">        _params.putAll(requestPair.pairs)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">headers</span><span class="params">(makeHeader: <span class="type">RequestPairs</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        <span class="keyword">val</span> requestPair = RequestPairs()</div><div class="line">        requestPair.makeHeader()</div><div class="line">        _headers.putAll(requestPair.pairs)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">excute</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">var</span> url = url</div><div class="line">        <span class="keyword">if</span> (Request.Method.GET == method) &#123;</div><div class="line">            url = getGetUrl(url, _params) &#123; it.toQueryString() &#125;</div><div class="line">        &#125;</div><div class="line">        _request = ByteRequest(method, url, Response.ErrorListener &#123;</div><div class="line">            _fail(it)</div><div class="line">            _finish()</div><div class="line">        &#125;)</div><div class="line">        _request._listener = Response.Listener &#123;</div><div class="line">            _success(it)</div><div class="line">            _finish()</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (tag != <span class="literal">null</span>) &#123;</div><div class="line">            _request.tag = tag</div><div class="line">        &#125;</div><div class="line">        Http.getRequestQueue().add(_request)</div><div class="line">        _start()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getGetUrl</span><span class="params">(url: <span class="type">String</span>, params: <span class="type">MutableMap</span>&lt;<span class="type">String</span>, String&gt;, toQueryString: (<span class="type">map</span>: <span class="type">Map</span>&lt;<span class="type">String</span>, String&gt;)</span></span> -&gt;</div><div class="line">    String): String &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (params == <span class="literal">null</span> || params.isEmpty()) url <span class="keyword">else</span> <span class="string">"<span class="subst">$url</span>?<span class="subst">$&#123;toQueryString(params)&#125;</span>"</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> Map<span class="type">&lt;K, V&gt;</span>.<span class="title">toQueryString</span><span class="params">()</span></span>: String = <span class="keyword">this</span>.map &#123; <span class="string">"<span class="subst">$&#123;it.key&#125;</span>=<span class="subst">$&#123;it.value&#125;</span>"</span> &#125;.joinToString(<span class="string">"&amp;"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码中将网络请求需要的所有信息全部包装了一层，这样在调用的时候就可以很方便的逐个设置每个参数（当然会有一些默认值），最后在<code>excute()</code>方法中全部设置给真正的<code>Request</code>。这个封装保证了下面的调用方式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">url = <span class="string">"http://api.openweathermap.org/data/2.5/weather"</span></div><div class="line">params &#123;</div><div class="line">    <span class="string">"q"</span> - <span class="string">"shanghai"</span></div><div class="line">    <span class="string">"appid"</span> - <span class="string">"d7a98cf22463b1c0c3df4adfe5abbc77"</span></div><div class="line">&#125;</div><div class="line">onSuccess &#123; bytes -&gt;</div><div class="line">    <span class="comment">// handle data</span></div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>PS：上面<code>params</code>是的书写方式，使用了<code>Kotlin</code>的操作符重载功能，具体实现可以下载<a href="https://github.com/ohmerhe/Kolley" target="_blank" rel="external">源码</a>看下。</p>
<h2 id="提供RESTful方法"><a href="#提供RESTful方法" class="headerlink" title="提供RESTful方法"></a>提供RESTful方法</h2><p>实现到上一步，已经准备的差不多了，接下来还需要最后一步，提供RESTful请求方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">object</span> Http &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mRequestQueue: RequestQueue? = <span class="literal">null</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</div><div class="line">        <span class="comment">// Set up the network to use OKHttpURLConnection as the HTTP client.</span></div><div class="line">        <span class="comment">// getApplicationContext() is key, it keeps you from leaking the</span></div><div class="line">        <span class="comment">// Activity or BroadcastReceiver if someone passes one in.</span></div><div class="line">        mRequestQueue = Volley.newRequestQueue(context.applicationContext, OkHttpStack(OkHttpClient()))</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getRequestQueue</span><span class="params">()</span></span>: RequestQueue &#123;</div><div class="line">        <span class="keyword">return</span> mRequestQueue!!</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">val</span> request: (<span class="built_in">Int</span>, BaseRequestWapper.() -&gt; <span class="built_in">Unit</span>) -&gt; Request&lt;ByteArray&gt; = &#123; method, request -&gt;</div><div class="line">        <span class="keyword">val</span> baseRequest = BaseRequestWapper()</div><div class="line">        baseRequest.method = method</div><div class="line">        baseRequest.request()</div><div class="line">        baseRequest.excute()</div><div class="line">        baseRequest._request</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">val</span> post = request.partially1(Request.Method.POST)</div><div class="line">    <span class="keyword">val</span> put = request.partially1(Request.Method.PUT)</div><div class="line">    <span class="keyword">val</span> delete = request.partially1(Request.Method.DELETE)</div><div class="line">    <span class="keyword">val</span> head = request.partially1(Request.Method.HEAD)</div><div class="line">    <span class="keyword">val</span> options = request.partially1(Request.Method.OPTIONS)</div><div class="line">    <span class="keyword">val</span> trace = request.partially1(Request.Method.TRACE)</div><div class="line">    <span class="keyword">val</span> patch = request.partially1(Request.Method.PATCH)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的<code>request: (Int, BaseRequestWapper.() -&gt; Unit) -&gt; Request&lt;ByteArray&gt;</code>方法为网络请求提供了入口、保证了配置化代码都可以在<code>{}</code>中调用、完成了真正网络请求添加到执行队列。用户可以通过<code>http.requset(method){}</code>方式发起各种请求。</p>
<p><code>val get = request.partially1(Request.Method.GET)</code>等提供了RESTful方法的封装，实现<code>Http.get{}</code>的方便调用。</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>关于图片请求模块的实现，其实也是异曲同工，虽然更加复杂一点，但是具体思路是一样的。有兴趣的可以下载<a href="https://github.com/ohmerhe/Kolley" target="_blank" rel="external">源码</a>查看实现，也欢迎提交代码。</p>
<p>图片请求的方式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Image.display &#123;</div><div class="line">    url = <span class="string">"http://7xpox6.com1.z0.glb.clouddn.com/android_bg.jpg"</span></div><div class="line">    imageView = mImageView</div><div class="line">    options &#123;</div><div class="line">        <span class="comment">// these values are all default value , you do not need specific them if you do not want to custom</span></div><div class="line">        imageResOnLoading = R.drawable.default_image</div><div class="line">        imageResOnLoading = R.drawable.default_image</div><div class="line">        imageResOnFail = R.drawable.default_image</div><div class="line">        decodeConfig = Bitmap.Config.RGB_565</div><div class="line">        scaleType = ImageView.ScaleType.CENTER_CROP</div><div class="line">        maxWidth = ImageDisplayOption.DETAULT_IMAGE_WIDTH_MAX</div><div class="line">        maxHeight = ImageDisplayOption.DETAULT_IMAGE_HEIGHT_MAX</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Image.load &#123;</div><div class="line">    url = <span class="string">"http://7xpox6.com1.z0.glb.clouddn.com/android_bg.jpg"</span></div><div class="line">    options &#123;</div><div class="line">        scaleType = ImageView.ScaleType.CENTER_CROP</div><div class="line">        maxWidth = ImageDisplayOption.DETAULT_IMAGE_WIDTH_MAX</div><div class="line">        maxHeight = ImageDisplayOption.DETAULT_IMAGE_HEIGHT_MAX</div><div class="line">    &#125;</div><div class="line">    onSuccess &#123; bitmap -&gt;</div><div class="line">        _imageView2?.setImageBitmap(bitmap)</div><div class="line">    &#125;</div><div class="line">    onFail &#123; error -&gt;</div><div class="line">        log(error.toString())</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/Kotlin/anko" target="_blank" rel="external">Anko</a></li>
<li><a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="external">Kotlin Refrence</a></li>
<li><a href="https://developer.android.com/training/volley/index.html" target="_blank" rel="external">Volley</a></li>
<li><a href="http://square.github.io/okhttp" target="_blank" rel="external">OKHttp</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin官方提供一个DSL的典型应用场景，&lt;a href=&quot;https://github.com/Kotlin/anko&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Anko&lt;/a&gt;致力直接用Kotlin配置页面布局和视图的属性。将布局文件代码化能够带来许多如类型安全、解析效率、代码重用等好处，而&lt;code&gt;Anko&lt;/code&gt;让代码布局和XML一样简洁清晰。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="网络请求" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>kotlin中的语法糖</title>
    <link href="http://yoursite.com/2016/01/14/kotlin%E4%B8%AD%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <id>http://yoursite.com/2016/01/14/kotlin中的语法糖/</id>
    <published>2016-01-14T05:49:44.000Z</published>
    <updated>2017-05-19T15:57:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun sum(a: Int, b: Int) = a + b</div><div class="line">	</div><div class="line">fun max(a: Int, b: Int) = if (a &gt; b) a else b</div></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// range in</div><div class="line">for (x in 1..100) </div><div class="line">	print(x)</div><div class="line">	</div><div class="line">for ((k, v) in map) &#123; </div><div class="line">	println(&quot;$k -&gt; $v&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">val list = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</div><div class="line"></div><div class="line">val a = array(1, 2, 3)</div><div class="line"></div><div class="line">val map = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2, &quot;c&quot; to 3)</div><div class="line"></div><div class="line">fun transform(color: String): Int = when (color) &#123;</div><div class="line">	&quot;Red&quot; -&gt; 0</div><div class="line">	&quot;Green&quot; -&gt; 1</div><div class="line">	&quot;Blue&quot; -&gt; 2</div><div class="line">	else -&gt; throw IllegalArgumentException(&quot;Invalid color param value&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Null安全, user为null也不会报NullPointException</div><div class="line">val name = user?.name ?: &quot;&quot;</div><div class="line"></div><div class="line">// user.name不为null返回user.name，否者返回&quot;unknow&quot;</div><div class="line">val name = user.name ?? &quot;unknow&quot;</div><div class="line">	</div><div class="line">// 字符串模板</div><div class="line">print(&quot;my name is $name or $&#123;user.name&#125;&quot;)</div></pre></td></tr></table></figure>
<h3 id="lanmda表达式"><a href="#lanmda表达式" class="headerlink" title="lanmda表达式"></a>lanmda表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">names</div><div class="line">.filter &#123; it.startsWith(&quot;A&quot;) &#125; </div><div class="line">.sortedBy &#123; it &#125;</div><div class="line">.map &#123; it.toUpperCase() &#125; </div><div class="line">.forEach &#123; print(it) &#125;</div></pre></td></tr></table></figure>
<!--more-->
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">object Singlton &#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">	companion object &#123;</div><div class="line">		fun sayHi()&#123; println(&quot;&quot;) &#125;</div><div class="line">	&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyClass.sayHi()</div></pre></td></tr></table></figure>
<h3 id="方法扩展-Extension-Functions"><a href="#方法扩展-Extension-Functions" class="headerlink" title="方法扩展(Extension Functions)"></a>方法扩展(Extension Functions)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fun &lt;T&gt; MutableList&lt;T&gt;.swap(index1: Int, index2: Int) &#123;</div><div class="line">	val tmp = this[index1] // &apos;this&apos; corresponds to the list </div><div class="line">	this[index1] = this[index2]</div><div class="line">	this[index2] = tmp</div><div class="line">&#125;</div><div class="line"></div><div class="line">val l = mutableListOf(1, 2, 3)</div><div class="line">l.swap(0, 2) // &apos;this&apos; inside &apos;swap()&apos; will hold the value of &apos;l&apos;</div></pre></td></tr></table></figure>
<h3 id="属性扩展"><a href="#属性扩展" class="headerlink" title="属性扩展"></a>属性扩展</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val &lt;T&gt; List&lt;T&gt;.lastIndex: Int </div><div class="line">	get() = size - 1</div></pre></td></tr></table></figure>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">View.setOnClickListener&#123; println(&apos;hello&apos;) &#125;</div><div class="line"></div><div class="line">ps： 这种写法仅限于只有一个重载方法的情况，多方法只能用下面形式</div><div class="line"></div><div class="line">window.addMouseListener(object : MouseAdapter() &#123; </div><div class="line">	override fun mouseClicked(e: MouseEvent) &#123;</div><div class="line">	// ...</div><div class="line">	&#125;</div><div class="line">	override fun mouseEntered(e: MouseEvent) &#123;</div><div class="line">	 	// ...</div><div class="line">	&#125;	</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="观察属性变化自动通知Observable"><a href="#观察属性变化自动通知Observable" class="headerlink" title="观察属性变化自动通知Observable"></a>观察属性变化自动通知Observable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class User &#123;</div><div class="line">	var name: String by Delegates.observable(&quot;&lt;no name&gt;&quot;) &#123;</div><div class="line">		prop, old, new -&gt; println(&quot;$old -&gt; $new&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">	val user = User()</div><div class="line">	user.name = &quot;first&quot;</div><div class="line">	user.name = &quot;second&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;no name&gt; -&gt; first</div><div class="line">first -&gt; second</div></pre></td></tr></table></figure>
<h3 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h3><p>java代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class Artist &#123;</div><div class="line">    private long id;</div><div class="line">    private String name;</div><div class="line">    private String url;</div><div class="line">    private String mbid;</div><div class="line"> </div><div class="line">    public long getId() &#123;</div><div class="line">        return id;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void setId(long id) &#123;</div><div class="line">        this.id = id;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public String getUrl() &#123;</div><div class="line">        return url;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void setUrl(String url) &#123;</div><div class="line">        this.url = url;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public String getMbid() &#123;</div><div class="line">        return mbid;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void setMbid(String mbid) &#123;</div><div class="line">        this.mbid = mbid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等同于下面kotlin代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data class Artist(var id: Long, var name: String, var url: String, var mbid: String)</div></pre></td></tr></table></figure>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本&quot;&gt;&lt;a href=&quot;#基本&quot; class=&quot;headerlink&quot; title=&quot;基本&quot;&gt;&lt;/a&gt;基本&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;fun sum(a: Int, b: Int) = a + b&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fun max(a: Int, b: Int) = if (a &amp;gt; b) a else b&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>类与对象 —— 类（一）</title>
    <link href="http://yoursite.com/2016/01/02/object-class-class/"/>
    <id>http://yoursite.com/2016/01/02/object-class-class/</id>
    <published>2016-01-02T08:01:28.000Z</published>
    <updated>2017-05-19T16:03:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h2><p>kotlin用关键字<code>class</code>声明，声明一个类可以只声明头的部分，类的声明默认是<code>final</code>的。就像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Persion</div><div class="line">//或者</div><div class="line">class Person(name: String)</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>类的构造函数可以有很多，但是只有一个可以声明在类的头部，这个构造函数被称做“主构造函数”，其他的被称做“次构造函数”。构造函数使用<code>constructor</code>关键字，主构造函数在没有可见性修饰符和注解的情况下，<code>constructor</code>可以被省略。默认的情况下，所有的构造函数的可见性都是<code>public</code>，对于使用方来说是与类的可见性保持一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Customer public @Inject constructor(name: String) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>主构造函数没有自己的函数体，它的参数可以在类的初始化块（<code>init</code>修饰）访问，在类的属性初始化时也可以访问。所以，在主构造函数里面想要做的事情，可以放在类的初始化块中实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Customer(name: String) &#123;</div><div class="line">	val customerKey = name.toUpperCase()</div><div class="line">    init &#123;</div><div class="line">        print(&quot;Customer initialized with value $&#123;name&#125;&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们想要在类的全局都可以访问主构造函数的参数，可以在参数前面加上<code>val</code>或者<code>var</code>，这样主构造函数的参数就和类的属性一样了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">open class Person(val name: String,val age: Int)&#123;</div><div class="line">    fun showName()&#123;</div><div class="line">        print(&quot;my name is $name&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    open fun showAge()&#123;</div><div class="line">        print(&quot;my age is $age&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>次构造函数必须要使用<code>constructor</code>修饰，并且必须直接或者间接的委托给主构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Person(val name: String) &#123;</div><div class="line">    constructor(name: String, parent: Person) : this(name) &#123;</div><div class="line">        parent.children.add(this)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>kotlin中所有的类都有一个父类<code>Any</code>，类似于java中的Object，但不存在对等关系。Any中只有<code>equals()</code>、<code>hashCode()</code>和<code>toString()</code>三个方法，所以其他的Object的方法都不能直接调用。详情请参见<a href="https://kotlinlang.org/docs/reference/java-interop.html#object-methods" target="_blank" rel="external">Java interoperability</a>。后面有机会我们会再讲到。</p>
<p>kotlin默认类都是<code>final</code>的，为了可以被继承，我们需要在类的声明前面加上<code>open</code>，让该类可以被其他类继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open class Base(p: Int)</div></pre></td></tr></table></figure>
<p>如果父类有主构造函数的话，则必须在子类声明的头部被初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Derived(p: Int) : Base(p)</div></pre></td></tr></table></figure>
<p>次构造函数也必须直接或间接的初始化父类的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class MyView : View &#123;</div><div class="line">    constructor(ctx: Context) : super(ctx) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="复写方法"><a href="#复写方法" class="headerlink" title="复写方法"></a>复写方法</h3><p>同类一样，子类只能复写父类中被<code>open</code>修饰的函数，复写方法必须使用<code>override</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">open class Person(name: String, age: Int)&#123;</div><div class="line">    var name = name;</div><div class="line">    val age = age;</div><div class="line">    fun showName()&#123;</div><div class="line">        print(&quot;my name is $name&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    open fun showAge()&#123;</div><div class="line">        print(&quot;my age is $age&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Women(name: String, age: Int) : Person(name, age)&#123;</div><div class="line">    override fun showAge()&#123;</div><div class="line">        print(&quot;my age is 18&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    override fun showName()&#123;</div><div class="line">        // error, compiler complain</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>子类中复写的方法，默认也是<code>open</code>的，如果需要，可以在方法<code>override</code>之前添加<code>final</code>注解，让该子类的子类不能再复写该方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">final override fun v() &#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>kotlin和java8一样，本身并不能同时继承于多个类，但是可以实现多个接口，而且接口可以有自己的实现，所以当父类和接口或者接口和接口中的方法一样时，会发生冲突，我们需要明确这个时候的解决方案，不然就会<code>compiler complain</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">interface Young&#123;</div><div class="line">    fun showAge()&#123;</div><div class="line">        print(&quot;my age is between 13 and 25&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Student(name: String, age: Int) : Person(name, age), Young&#123;</div><div class="line"></div><div class="line">    override fun showAge() &#123;</div><div class="line">        super&lt;Person&gt;.showAge()</div><div class="line">        super&lt;Young&gt;.showAge()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>委托被认为是一个非常好的替代继承和实现的设计模式，kotlin也支持这种模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">interface Base &#123;</div><div class="line">    fun print()</div><div class="line">&#125;</div><div class="line"></div><div class="line">class BaseImpl(val x: Int) : Base &#123;</div><div class="line">    override fun print() &#123; print(x) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Derived(b: Base) : Base by b</div><div class="line"></div><div class="line">fun main() &#123;</div><div class="line">    val b = BaseImpl(10)</div><div class="line">    Derived(b).print() // prints 10</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在类的声明过程中，在父类类型后面使用<code>by</code>关键字指明在Derived的对象中将会内部存储<code>b</code>对象，并且编译器会将<code>Base</code>的所有方法指向<code>b</code>。</p>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类的声明&quot;&gt;&lt;a href=&quot;#类的声明&quot; class=&quot;headerlink&quot; title=&quot;类的声明&quot;&gt;&lt;/a&gt;类的声明&lt;/h2&gt;&lt;p&gt;kotlin用关键字&lt;code&gt;class&lt;/code&gt;声明，声明一个类可以只声明头的部分，类的声明默认是&lt;code&gt;final&lt;/code&gt;的。就像：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;class Persion&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//或者&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;class Person(name: String)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
      <category term="class" scheme="http://yoursite.com/tags/class/"/>
    
      <category term="类" scheme="http://yoursite.com/tags/%E7%B1%BB/"/>
    
      <category term="继承" scheme="http://yoursite.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="委托" scheme="http://yoursite.com/tags/%E5%A7%94%E6%89%98/"/>
    
  </entry>
  
  <entry>
    <title>类与对象——泛型</title>
    <link href="http://yoursite.com/2015/12/22/class-object-generic/"/>
    <id>http://yoursite.com/2015/12/22/class-object-generic/</id>
    <published>2015-12-22T15:08:50.000Z</published>
    <updated>2017-05-19T15:56:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>与java一样，Kotlin也提供泛型，为类型安全提供保证，消除类型强转的烦恼。</p>
<h3 id="泛型定义"><a href="#泛型定义" class="headerlink" title="泛型定义"></a>泛型定义</h3><p>好吧，如果只是简单声明一个泛型，和<code>Java</code>没有什么大的区别，你可以这样声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Box&lt;T&gt;(t: T) &#123;</div><div class="line">    var value = t</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后可以这样使用</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val box: Box&lt;Int&gt; = Box&lt;Int&gt;(1)</div><div class="line"></div><div class="line">// 或者</div><div class="line"></div><div class="line">val box = Box(1) // 编译器会进行类型推断</div></pre></td></tr></table></figure>
<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>和类的继承一样，<code>Kotlin</code>中使用<code>:</code>代替<code>extends</code>对泛型的的类型上限进行约束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class SwipeRefreshableView&lt;T : View&gt;&#123;&#125;</div></pre></td></tr></table></figure>
<p>不过这里你可以进行多个类型的上限约束：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class SwipeRefreshableView&lt;T&gt;</div><div class="line">    where T : View,</div><div class="line">          T : Refreshable &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">// 或者</div><div class="line"></div><div class="line">fun &lt;T&gt; cloneWhenGreater(list: List&lt;T&gt;, threshold: T): List&lt;T&gt;</div><div class="line">    where T : Comparable,</div><div class="line">          T : Cloneable &#123;</div><div class="line">  return list.filter &#123; it &gt; threshold &#125;.map &#123; it.clone() &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，对于之前用过泛型的同学来说都没有什么难度。so，kotlin还有什么java里没有的东西吗？</p>
<h3 id="in和out"><a href="#in和out" class="headerlink" title="in和out"></a><code>in</code>和<code>out</code></h3><p><code>Kotlin</code>中引入两个新的泛型修饰符<code>in</code>和<code>out</code>，要解释这两个关键字的用法，我们先从另外两个概念说起‘covariant（协变性）’和‘contravariance（逆变性）’（不知道的可以<a href="http://www.cnblogs.com/Figgy/p/4575719.html" target="_blank" rel="external">参考</a>）。我们都知道在java中List不是协变的，而Array是协变的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Integer[] intArray = new Integer[10];</div><div class="line">Number[] numberArray = intArray;</div><div class="line">numberArray[0] = 1.0f;</div></pre></td></tr></table></figure>
<p>在上面的代码中，<code>Integer[]</code>被认为是<code>Number[]</code>的子类型，所以可以将<code>intArray</code>赋值给<code>numberArray</code>，但是在随后的代码，我们将<code>1.0f</code>赋给<code>numberArray[0]</code>，因为在这里看来，将一个浮点型赋给一个Number对象不会有什么问题。最后悲剧发生了，当执行时，程序crash了。</p>
<p>但是当你使用泛型的的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; strs = new ArrayList&lt;&gt;();</div><div class="line">List&lt;Object&gt; objs = strs; // error, compiler complain</div></pre></td></tr></table></figure>
<p><code>List&lt;String&gt;</code>并不是<code>List&lt;Object&gt;</code>的子类型，于是编译器告诉你，不能直接赋值。或许你会说我们可以使用通配符<code>? extends T</code>让它变得协变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; strs = new ArrayList&lt;String&gt;();</div><div class="line">strs.add(&quot;0&quot;);</div><div class="line">strs.add(&quot;1&quot;);</div><div class="line">List&lt;? extends Object&gt; objs = strs;</div><div class="line">//编译通过</div></pre></td></tr></table></figure>
<p><code>List&lt;String&gt;</code>是<code>List&lt;? extends Object&gt;</code>的子类，所以上面的代码的确能够编译运行，但是当你尝试为<code>objs</code>添加内容时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//然后添加一个int型试试</div><div class="line">objs.add(1); // error, compiler complain</div><div class="line">// 编译器编译出错</div><div class="line"></div><div class="line">// 现在再添加一个String</div><div class="line">objs.add(&quot;1&quot;); // error, compiler complain</div><div class="line">// 编译出错</div></pre></td></tr></table></figure>
<p>对于objs并不会因为<code>objs = strs;</code>的赋值，而将<code>objs</code>的泛型类型转化为<code>String</code>类型，所以在不能判断objs的泛型类型的情况下，往objs添加任何类型的对象都是不被允许的。但是我们明确知道objs的所有类型上限（upper bound），于是我们可以通过<code>objs.get(0)</code>获取Object的对象。</p>
<p> 小结一下，我们可以用通配符<code>? extends T</code>让泛型类变得协变，但是对于具体泛型类型的对象我们不能赋值，只能获取。于是在下面的假设中java就可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">interface Source&lt;T&gt; &#123;</div><div class="line">    public T getT();</div><div class="line">    public void setT(T t);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void copy(Source&lt;String&gt; strs)&#123;</div><div class="line">    Source&lt;? extends Object&gt; objs = strs;</div><div class="line">    objs.setT(&quot;a&quot;); // error, compiler complain</div><div class="line">	String str = (String) objs.getT();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>Kotlin</code>中就可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">abstract class Source&lt;T&gt; &#123;</div><div class="line">    abstract fun getT(): T</div><div class="line">    abstract fun setT(t: T)  </div><div class="line">&#125;</div><div class="line"></div><div class="line">fun copyT(strs: Source&lt;String&gt;)&#123;</div><div class="line">    val objs: Source&lt;out Any?&gt; = strs;</div><div class="line">    objs.setT(&quot;a&quot;) // error, compiler complain</div><div class="line">    objs.getT()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的<code>out Any?</code>可以用<code>*</code>代替。</p>
<p>如果我们可以确定<code>Source</code>这个类不会有<code>abstract fun setT(t: T)</code>类似的操作，我们可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">abstract class Source&lt;out T&gt; &#123;</div><div class="line">    abstract fun getT(): T</div><div class="line">    // 如果下面出现会编译不过</div><div class="line">    // abstract fun setT(t: T) // error, compiler complain</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun copyT(strs: Source&lt;String&gt;)&#123;</div><div class="line">    val objs: Source&lt;Any&gt; = strs;</div><div class="line">    objs.setT(&quot;a&quot;) // error, compiler complain</div><div class="line">    objs.getT()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>小结一下，在定义泛型类<code>C&lt;T&gt;</code>时，当我们在泛型类型<code>T</code>前面添加<code>out</code>，<code>C</code>为<code>T</code>的协变类。在该类的作用域内，类型<code>T</code>只能作为该类中函数的返回类型，不能作为参数传递进来，这时也称做<code>C</code>为<code>T</code>的生产者（Producer）。</p>
<p>以此类推，在定义泛型类<code>C&lt;T&gt;</code>时，当我们在泛型类型<code>T</code>前面添加<code>in</code>，<code>C</code>为<code>T</code>的逆变类。在该类的作用域内，类型<code>T</code>只能作为该类中函数的参数传递进来，不能作为返回类型，这时也称做<code>C</code>为<code>T</code>的消费者（Consumer）。</p>
<p>类似于<code>java</code>中的<a href="http://www.importnew.com/8966.html" target="_blank" rel="external">PECS</a>（Producer Extends，Consumer Super），我们可以总结出：‘Consumer in, Producer out’。</p>
<p>如果在泛型类型使用测，在对应泛型的具体类型前面使用<code>out</code>，则等同于使用<code>java</code>中的<code>extends</code>字段，<code>in</code>则等同于<code>super</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fun copy(from: Array&lt;out String&gt;, to: Array&lt;in String&gt;) &#123;</div><div class="line">    assert(from.size == to.size)</div><div class="line">    for (i in from.indices)</div><div class="line">        to[i] = from[i]</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 等同于</div><div class="line"></div><div class="line">public void copy(List&lt;? extends String&gt; from, List&lt;? super String&gt; to) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>PS： 这里Array 与 List 不是对等关系。</p>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.cnblogs.com/panjun-Donet/archive/2008/09/27/1300609.html" target="_blank" rel="external">java泛型</a></li>
<li><a href="http://www.cnblogs.com/Figgy/p/4575719.html" target="_blank" rel="external">不变性、协变性和逆变性（Invariance, Covariance &amp; Contravariance</a></li>
<li><a href="http://www.importnew.com/8966.html" target="_blank" rel="external">Java 泛型: 什么是PECS（Producer Extends, Consumer Super）</a></li>
<li><a href="https://kotlinlang.org/docs/reference/generics.html" target="_blank" rel="external">Kotlin-Generics</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与java一样，Kotlin也提供泛型，为类型安全提供保证，消除类型强转的烦恼。&lt;/p&gt;
&lt;h3 id=&quot;泛型定义&quot;&gt;&lt;a href=&quot;#泛型定义&quot; class=&quot;headerlink&quot; title=&quot;泛型定义&quot;&gt;&lt;/a&gt;泛型定义&lt;/h3&gt;&lt;p&gt;好吧，如果只是简单声明一个泛型，和&lt;code&gt;Java&lt;/code&gt;没有什么大的区别，你可以这样声明：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;class Box&amp;lt;T&amp;gt;(t: T) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    var value = t&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后可以这样使用&lt;/p&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
      <category term="generics" scheme="http://yoursite.com/tags/generics/"/>
    
      <category term="泛型" scheme="http://yoursite.com/tags/%E6%B3%9B%E5%9E%8B/"/>
    
      <category term="类与对象" scheme="http://yoursite.com/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>类与对象 -- object</title>
    <link href="http://yoursite.com/2015/12/19/class-object-object/"/>
    <id>http://yoursite.com/2015/12/19/class-object-object/</id>
    <published>2015-12-19T11:02:38.000Z</published>
    <updated>2017-05-19T15:57:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象（object）表达式和对象声明"><a href="#对象（object）表达式和对象声明" class="headerlink" title="对象（object）表达式和对象声明"></a>对象（object）表达式和对象声明</h2><p>Kotlin中提供关键object，与java中的“Object”不同（在java中“Object”是所有类的基类，等同于Kotlin的“Any”，参考<a href="https://kotlinlang.org/docs/reference/java-interop.html#mapped-types" target="_blank" rel="external">java-interop</a>），用于直接申明一个对象，有两种使用写法：对象表达式和对象声明</p>
<h3 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h3><p>通过对象表达式可以越过类的定义直接得到一个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">val point = object &#123;</div><div class="line">	var x: Int = 0</div><div class="line">	var y: Int = 0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个对象可以继承于某个基类，或者实现其他接口:</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">open class Device(var name: String) &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface Vedio &#123;</div><div class="line">    fun play()&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var television = object : Device(&quot;Sony&quot;), Vedio&#123;&#125;</div></pre></td></tr></table></figure>
<p>这可以方便的实现一个匿名内部类的对象用于方法的参数中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">window.addMouseListener(object : MouseAdapter() &#123;</div><div class="line">    override fun mouseClicked(e: MouseEvent) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    override fun mouseEntered(e: MouseEvent) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在对象表达中可以方便的访问到作用域中的其他变量，及时这个变量并不是<code>final</code>的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">fun countClicks(window: JComponent) &#123;</div><div class="line">    var clickCount = 0</div><div class="line">    var enterCount = 0</div><div class="line"></div><div class="line">    window.addMouseListener(object : MouseAdapter() &#123;</div><div class="line">        override fun mouseClicked(e: MouseEvent) &#123;</div><div class="line">            clickCount++</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        override fun mouseEntered(e: MouseEvent) &#123;</div><div class="line">            enterCount++</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h3><p>对象声明可类似定义一个类一样定义一个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">object RCtrl : Device(&quot;Remote Control&quot;), Infrared &#123;</div><div class="line">    override fun send(command: Int) &#123;</div><div class="line">        // send command</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">object RCtrl : Device(&quot;Remote Control&quot;), Infrared &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在使用的时候可以直接使用定义的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    RCtrl.send(1)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然你也可以定义一个变量来获取获取这个对象，当时当你定义两个不同的变量来获取这个对象时，你会发现你并不能得到两个不同的变量。也就是说通过这种方式，我们获得一个<strong><em>单例</em></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var rCtrl1 = RCtrl</div><div class="line">var rCtrl2 = RCtrl</div><div class="line">rCtrl1.name = &quot;TV Control&quot;</div><div class="line">print(&quot;rCtrl2 name = $&#123;rCtrl2.name&#125;&quot;)</div></pre></td></tr></table></figure>
<p>在Kotlin中我们可以方便的通过对象声明来获得一个单例。</p>
<p>不过需要注意的是，对象声明不能直接定义在一个函数中。</p>
<p>与对象表达式不同，当对象声明在另一个类的内部时，这个对象并不能通过外部类的实例访问到该对象，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Desk&#123;</div><div class="line">	var legCount = 4</div><div class="line">	object DeskTop&#123;</div><div class="line">       var area = 0</div><div class="line">       fun showLegs()&#123;</div><div class="line">       	print&#123;&quot;desk legs $legCount&quot;&#125; // error, compile complain</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">	var desk = Desk()</div><div class="line">   	desk.DeskTop.area // error, compile complain</div><div class="line">   	Desk.DeskTop.area // right</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="companion对象"><a href="#companion对象" class="headerlink" title="companion对象"></a>companion对象</h3><p>当对象声明在另一个对象中时，我们可以通过关键字<code>companion</code>将对象与外部类关联在一起，这样我们就可以直接通过外部类访问到对象的内部元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">    companion object Factory &#123;</div><div class="line">        fun create(): MyClass = MyClass()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">val instance = MyClass.create()</div></pre></td></tr></table></figure>
<p>我们甚至可以省略掉该对象的对象名，然后使用<code>Companion</code>替代需要声明的对象名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">    companion object &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">val x = MyClass.Companion</div></pre></td></tr></table></figure>
<p>看到上面的例子我们我们就会思考如果我们定义两个内部关联对象怎么办，答案当然是不行，不管是否声明对象名，一个类里面只能声明一个内部关联对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Desk&#123;</div><div class="line">    companion object DeskTop &#123;</div><div class="line">        var area = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    companion object Leg&#123;  // error, compile complain</div><div class="line">        var lenght = 80</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://kotlinlang.org" target="_blank" rel="external">kotlin</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对象（object）表达式和对象声明&quot;&gt;&lt;a href=&quot;#对象（object）表达式和对象声明&quot; class=&quot;headerlink&quot; title=&quot;对象（object）表达式和对象声明&quot;&gt;&lt;/a&gt;对象（object）表达式和对象声明&lt;/h2&gt;&lt;p&gt;Kotlin中提供关键object，与java中的“Object”不同（在java中“Object”是所有类的基类，等同于Kotlin的“Any”，参考&lt;a href=&quot;https://kotlinlang.org/docs/reference/java-interop.html#mapped-types&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;java-interop&lt;/a&gt;），用于直接申明一个对象，有两种使用写法：对象表达式和对象声明&lt;/p&gt;
&lt;h3 id=&quot;对象表达式&quot;&gt;&lt;a href=&quot;#对象表达式&quot; class=&quot;headerlink&quot; title=&quot;对象表达式&quot;&gt;&lt;/a&gt;对象表达式&lt;/h3&gt;&lt;p&gt;通过对象表达式可以越过类的定义直接得到一个对象：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;val point = object &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	var x: Int = 0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	var y: Int = 0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个对象可以继承于某个基类，或者实现其他接口:&lt;/p&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
      <category term="object" scheme="http://yoursite.com/tags/object/"/>
    
      <category term="companion" scheme="http://yoursite.com/tags/companion/"/>
    
      <category term="单例" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B/"/>
    
      <category term="对象" scheme="http://yoursite.com/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin简介</title>
    <link href="http://yoursite.com/2015/12/17/new-to-kotlin/"/>
    <id>http://yoursite.com/2015/12/17/new-to-kotlin/</id>
    <published>2015-12-17T13:35:29.000Z</published>
    <updated>2017-05-19T16:03:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kotlin是什么"><a href="#Kotlin是什么" class="headerlink" title="Kotlin是什么"></a>Kotlin是什么</h2><p>发布于2011年，是一门适用于JVM, Android以及浏览器静态语言，<strong><em>100% 兼容Java™</em></strong></p>
<h2 id="为什么选择Kotlin"><a href="#为什么选择Kotlin" class="headerlink" title="为什么选择Kotlin"></a>为什么选择Kotlin</h2><ul>
<li>简洁，大幅度减少你需要写的重复代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">使用lambda表达式来过滤链表：</div><div class="line">val positiveNumbers = list.filter &#123;it &gt; 0&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>安全，避免整个类中类似空指针异常这样的错误，测试妹妹再也不用担心你的NullPointException了</p>
</li>
<li><p>通用，可以用于构建服务器端程序、Android程序或者运行在浏览器里的前端程序</p>
</li>
<li><p>互操作，重用已有的JVM平台框架或库，与Java无缝兼容，可直接在之前项目上面使用Kotlin</p>
</li>
<li><p>工具，一门语言需要工具化，这正是JetBrains做得最好的地方</p>
</li>
<li><p>可靠，JetBrains提供技术支持</p>
</li>
</ul>
<a id="more"></a>
<h2 id="试用Kotlin"><a href="#试用Kotlin" class="headerlink" title="试用Kotlin"></a>试用Kotlin</h2><ul>
<li>单独编译，你可以使用ant、maven或者gradle编译kotlin，<a href="https://kotlinlang.org/docs/tutorials/command-line.html" target="_blank" rel="external">编译器下载</a></li>
<li>在IntelliJ IDEA或者Android Studio上编写kotlin，<a href="https://kotlinlang.org/docs/tutorials/getting-started.html" target="_blank" rel="external">安装插件</a></li>
<li>在eclipse上编写kotlin，<a href="https://kotlinlang.org/docs/tutorials/getting-started-eclipse.html" target="_blank" rel="external">安装插件</a></li>
<li><a href="http://try.kotlinlang.org/" target="_blank" rel="external">在线编辑</a></li>
</ul>
<h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul>
<li><a href="https://kotlinlang.org/" target="_blank" rel="external">官方网站</a></li>
<li><a href="http://kotlinlang.cn/" target="_blank" rel="external">中文网站</a></li>
<li><a href="https://kotlinlang.org/docs/kotlin-docs.pdf" target="_blank" rel="external">文档下载</a></li>
<li><a href="https://kotlinthree.github.io/" target="_blank" rel="external">KotlinThree</a></li>
</ul>
<h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a href="http://kotlinlang.cn/" target="_blank" rel="external">Kotlin</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Kotlin是什么&quot;&gt;&lt;a href=&quot;#Kotlin是什么&quot; class=&quot;headerlink&quot; title=&quot;Kotlin是什么&quot;&gt;&lt;/a&gt;Kotlin是什么&lt;/h2&gt;&lt;p&gt;发布于2011年，是一门适用于JVM, Android以及浏览器静态语言，&lt;strong&gt;&lt;em&gt;100% 兼容Java™&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么选择Kotlin&quot;&gt;&lt;a href=&quot;#为什么选择Kotlin&quot; class=&quot;headerlink&quot; title=&quot;为什么选择Kotlin&quot;&gt;&lt;/a&gt;为什么选择Kotlin&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;简洁，大幅度减少你需要写的重复代码&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;使用lambda表达式来过滤链表：&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;val positiveNumbers = list.filter &amp;#123;it &amp;gt; 0&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安全，避免整个类中类似空指针异常这样的错误，测试妹妹再也不用担心你的NullPointException了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通用，可以用于构建服务器端程序、Android程序或者运行在浏览器里的前端程序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;互操作，重用已有的JVM平台框架或库，与Java无缝兼容，可直接在之前项目上面使用Kotlin&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;工具，一门语言需要工具化，这正是JetBrains做得最好的地方&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可靠，JetBrains提供技术支持&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Welcome</title>
    <link href="http://yoursite.com/2015/12/15/welcome/"/>
    <id>http://yoursite.com/2015/12/15/welcome/</id>
    <published>2015-12-15T13:36:29.000Z</published>
    <updated>2017-05-19T16:02:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xpox6.com1.z0.glb.clouddn.com/104429.88533097_620X620.jpg" alt="Zenus"></p>
<a id="more"></a>
<h2 id="KotlinThree组织成立了！！！欢迎大家前来做客！-此处应有掌声-欢迎大家一起来学习探讨Kotlin"><a href="#KotlinThree组织成立了！！！欢迎大家前来做客！-此处应有掌声-欢迎大家一起来学习探讨Kotlin" class="headerlink" title="KotlinThree组织成立了！！！欢迎大家前来做客！(此处应有掌声~), 欢迎大家一起来学习探讨Kotlin"></a><strong>KotlinThree组织成立了</strong>！！！欢迎大家前来做客！(此处应有掌声~), 欢迎大家一起来学习探讨Kotlin</h2><h2 id="欢迎大家关注我们的公众号"><a href="#欢迎大家关注我们的公众号" class="headerlink" title="欢迎大家关注我们的公众号"></a>欢迎大家关注我们的公众号</h2><p><img src="http://7xpox6.com1.z0.glb.clouddn.com/qrcode_for_gh_b2ad0581a6c4_430.jpg?imageView2/2/w/320" alt=""> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xpox6.com1.z0.glb.clouddn.com/104429.88533097_620X620.jpg&quot; alt=&quot;Zenus&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="star" scheme="http://yoursite.com/tags/star/"/>
    
  </entry>
  
</feed>
