<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[KotlinThree's Blog]]></title>
  <subtitle><![CDATA[for the dream]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2017-05-16T15:56:52.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[KotlinThree]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Kotlin：The Good, The Bad, and The Ugly(译)]]></title>
    <link href="http://yoursite.com/2016/08/27/kotlin_good_bad_bugly/"/>
    <id>http://yoursite.com/2016/08/27/kotlin_good_bad_bugly/</id>
    <published>2016-08-27T08:59:00.000Z</published>
    <updated>2017-05-16T15:56:52.000Z</updated>
    <content type="html"><![CDATA[<p>tags: Kotlin, Android</p>
<p>在我的 <a href="https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6" target="_blank" rel="external">上一篇文章</a>, 谈到了关于转换 Java 到 Kotlin 代码和我喜欢的一些库。现在，我想要谈谈关于 Kotlin 这门语言本身的想法，还有它和 Java 交互的方式。</p>
<a id="more"></a>
<h2 id="The_Good"><a href="#The_Good" class="headerlink" title="The Good"></a>The Good</h2><p>Kotlin 有许多让人喜欢的理由。像 <code>null safety</code>、<code>property access</code> 和 <code>unchecked exceptions</code> 类似这些明显的特性在 <a href="https://blog.jetbrains.com/kotlin/2016/01/kotlin-digest-2015/" target="_blank" rel="external">publications</a> 都有描述，我就不重复了。我只讲一些我真正喜欢但很少被提到的特性。</p>
<h3 id="Automatic_conversion_of_Java_to_Kotlin"><a href="#Automatic_conversion_of_Java_to_Kotlin" class="headerlink" title="Automatic conversion of Java to Kotlin"></a>Automatic conversion of Java to Kotlin</h3><p>JetBrains 在 IntelliJ 中集成了 <code>Java to Kotlin converter</code> 为我们节约了大量的时间。虽然它还不是很完美，但是它让你不用再重复输入。要是没有它，你将要花费大量的时间从 Java 代码转换成 Kotlin。</p>
<h3 id="lateinit_2C_Delegates-notNull_and_lazy"><a href="#lateinit_2C_Delegates-notNull_and_lazy" class="headerlink" title="lateinit, Delegates.notNull and lazy"></a>lateinit, Delegates.notNull and lazy</h3><p>Kotlin 的 <code>null safety</code> 非常好，但是由于在 Android 的 Activity 生命周期的设计，你常常不得不在 <em>onCreate</em> 这样的回调中初始化一个变量，而不是在类的构造函数中。假设你有一个属性需要定义，你肯定想要这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> name</span>: String</span><br></pre></td></tr></table></figure>
<p>如果你必须在 <code>onCreate</code> 中初始化这个属性，就不能用 <code>val</code> 定义，而必须使用 <code>var</code>。但是这样你必须在定义的时候为该属性提供一个值进行初始化，或者将它定义为可空类型：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name: <span class="built_in">String</span>? = <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>这样的确有效，但是当你每次使用它的时候都要进行空检查。虽然 Korlin 提供了友好的的空断言，但是在实践中即使你知道你的属性不会为空，你也不愿意到处使用 <code>!!</code>。庆幸的是，Kotlin 提供了更好的方式：<a href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties" target="_blank" rel="external"><em>lateinit</em></a> 和 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/not-null.html" target="_blank" rel="external"><em>Delegates.notNull</em></a>。任何一个都能可以让你在不初始化的情况下定义一个非空类型。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lateinit <span class="variable"><span class="keyword">var</span> name</span>: String</span><br><span class="line"><span class="variable"><span class="keyword">var</span> age</span>: <span class="typename">Int</span> by Delegates.notNull<span class="type">&lt;Int&gt;</span>()</span><br></pre></td></tr></table></figure>
<p>这两种方式中，当你尝试在初始化之前访问该属性都会抛出异常。除了<code>lateinit</code> 不能用于基础类型的定义，这两种方法没有什么大的差别。</p>
<p>你还有第三种选择就是使用 <code>lazy</code> 委托。如果一个属性能够利用其他属性或方法获得数据进行初始化，那么 <code>lazy</code> 会是一个很好的选择。类似这样：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> imm: InputMethodManager by <span class="keyword">lazy</span> &#123; </span><br><span class="line">    getSystemService(INPUT_METHOD_SERVICE) <span class="keyword">as</span> InputMethodManager </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面块里面的代码在第一次读取之前并不会执行，执行的结果会被保存起来以供后面使用，所以后面的代码块只会被执行一次。</p>
<h3 id="Functional_collection_extensions"><a href="#Functional_collection_extensions" class="headerlink" title="Functional collection extensions"></a>Functional collection extensions</h3><p>Kotlin 提供为集合和迭代类提供了大量的函数式 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html#functions" target="_blank" rel="external">扩展方法</a>。像 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/any.html" target="_blank" rel="external"><em>any</em></a>、 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/join-to-string.html" target="_blank" rel="external"><em>joinToString</em></a> 和 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/associate.html" target="_blank" rel="external"><em>associate</em></a> 的方法能够帮助节约大量的时间，不用像 Java 里面一样手工编写 <em>for</em> 循环去实现。</p>
<p>Kotlin 还提供了大量的函数式集合操作的懒加载模式，在这种模式下载每个操作执行之前并不会进行集合的拷贝，但是在我的接受范围内，发现懒加载和即刻加载在性能上并没有什么大的差别。</p>
<h3 id="Named_and_default_function_arguments"><a href="#Named_and_default_function_arguments" class="headerlink" title="Named and default function arguments"></a>Named and default function arguments</h3><p><a href="https://kotlinlang.org/docs/reference/functions.html#named-arguments" target="_blank" rel="external">命名参数</a> 和 <a href="https://kotlinlang.org/docs/reference/functions.html#named-arguments" target="_blank" rel="external">默认参数</a> 是非常基础的，但它们让你不再需要重载方法，并且也替代了 Builder 模式的一种使用场景。</p>
<p>根据具体使用场景，你甚至可以在依赖注入中将生产依赖作为默认参数，然后在测试的时候传入模拟的数据。</p>
<p>例如，你在 <code>presenter</code> 中需要一些全局状态，你可以这样定义构造函数：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Presenter</span>(</span><br><span class="line">        val okhttp: <span class="type">OkHttp</span> = productionOkHttp(),</span><br><span class="line">        val picasso: <span class="type">Picasso</span> = productionPicassoInstance()</span><br><span class="line">) <span class="decorator">&#123;...&#125;</span></span><br></pre></td></tr></table></figure>
<p>这样，你就你可以 <code>UI</code> 代码中创建 <code>presenter</code> 实例的时候不传递任何参数，但是在测试的时候可以传递模拟的实例作为参数。完整的依赖注入框架会更加强大，但这是一个一些简单语言构造的很好的例子。</p>
<h2 id="The_Bad"><a href="#The_Bad" class="headerlink" title="The Bad"></a>The Bad</h2><p>尽管 Kotlin 非常棒，但是它并不完美。我列举了一下我不喜欢的部分。</p>
<h3 id="No_namespaces"><a href="#No_namespaces" class="headerlink" title="No namespaces"></a>No namespaces</h3><p>Kotlin 允许你在文件中定义顶级的函数和属性。这是一个非常棒的特性，但是这会带来所有从 Kotlin 引用的顶级声明无法区分的困扰。有时，这让我们在读代码的时候很难快速确定用的是哪一个函数。</p>
<p>例如，你定义这样一个顶级函数：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun foo() <span class="decorator">&#123;...&#125;</span></span><br></pre></td></tr></table></figure>
<p>你可以通过 <code>foo()</code> 调用。如果你在不同的包里面也存在同样的方法，在调用侧不能明显区分出是调用的哪个方法。你可以通过在前面添加包名的方式去调用，但是如果 Java 约定的包名很深，似乎不太好。</p>
<p>一种近似的解决方案是使用单例的 <code>object</code> 类。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> <span class="type">FooActions</span> &#123;</span><br><span class="line">    fun foo() <span class="decorator">&#123;...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样你在 Kotlin 中可以通过 <code>FooActions.foo()</code> 调用，但是在 Java 代码中就不是那么友好了。在 Java 中你必须要这样 <code>FooActions.INSTANCE.foo()</code> 这样调用，这看起来并不完美。你可以使用 <code>@JvmStatic</code> 去注解你的方法从而省掉 <code>INSTANCE</code>，这是你能做到的最好结果。这并不是什么大不了的事，但是如果 Kotlin 能够提供命名空间的话，能省不少事。</p>
<h3 id="No_static_modifier"><a href="#No_static_modifier" class="headerlink" title="No static modifier"></a>No static modifier</h3><p>无独有偶，Kotlin 提供为静态函数和属性提供了一个和 Java 不一样的处理方式。并不是说有多烂，只是觉得让代码变得不干净而且没有必要。例如，在 Android 的 <code>View</code> 类中定义的静态属性 <code>View.VISIBLE</code> 和静态函数 <code>View.inflate</code>。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">View</span> &#123;</span><br><span class="line">    public <span class="keyword">static</span> final <span class="type">int</span> <span class="type">VISIBLE</span> = <span class="number">0x00000000</span>;</span><br><span class="line">    public <span class="keyword">static</span> final <span class="type">int</span> <span class="type">INVISIBLE</span> = <span class="number">0x00000004</span>;</span><br><span class="line">    public <span class="keyword">static</span> <span class="type">View</span> inflate(<span class="type">Context</span> context, <span class="type">int</span> resource) <span class="decorator">&#123;...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个定义是简单的。然而，在 Kotlin 代码中：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">class</span> <span class="tag">View</span> &#123;</span><br><span class="line">    <span class="tag">companion</span> <span class="tag">object</span> &#123;</span><br><span class="line">        <span class="variable">@JvmField</span> </span><br><span class="line">        val <span class="attribute">VISIBLE</span>: Int = <span class="number">0</span>x00000000</span><br><span class="line">        <span class="variable">@JvmField</span> </span><br><span class="line">        val <span class="attribute">INVISIBLE</span>: Int = <span class="number">0</span>x00000004</span><br><span class="line">        <span class="variable">@JvmStatic</span></span><br><span class="line">        fun <span class="function">inflate</span>(<span class="attribute">context</span>: Context, <span class="attribute">resource</span>: Int) &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管 Kotlin 的版本并没有那么恐怖，但是它的复杂程度超过了我对这门语言的预期。如果把注解去掉，那么你在 Java 代码中不得不使用这样可怕的语法去调用：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With annotations:</span></span><br><span class="line"><span class="keyword">View</span>.VISIBLE;</span><br><span class="line"><span class="comment">//Without annotations:</span></span><br><span class="line"><span class="keyword">View</span>.Companion.getVISIBLE();</span><br></pre></td></tr></table></figure>
<p>没有更好的方式去创建静态函数和属性让我感觉很奇怪。我知道 <code>companion objects</code> 是真正的对象并且能够用来实现接口，但是这并不能足够说明能完全替代普通的静态声明。</p>
<h3 id="Automatic_conversion_of_Java_to_Kotlin-1"><a href="#Automatic_conversion_of_Java_to_Kotlin-1" class="headerlink" title="Automatic conversion of Java to Kotlin"></a>Automatic conversion of Java to Kotlin</h3><p>在我的第一篇帖子里这是我列出来的我喜欢 Kotlin 的愿意之一，并且它很好用。但是正由于它在 80% 的时候都运行的很好，它在一些场景的失败实在令人沮丧。</p>
<p>Java 文档经常错位，特别是在段落横跨了好几行的时候。静态域和方法被转换成 <code>companion object</code>，除非你手动添加为他们分别添加 <code>@JvmField</code> 和 <code>@JvmStatic</code> ，你之前 Java 调用代码不在有效而出错。</p>
<p>由于 Kotlin 团队花了大量的时间在转换代码上，我相信这些问题一定会被修复的，因此我对这些问题保持乐观。</p>
<h3 id="Required_property_accessor_syntax"><a href="#Required_property_accessor_syntax" class="headerlink" title="Required property accessor syntax"></a>Required property accessor syntax</h3><p>Kotlin 提供一个很棒的语法糖叫做「属性访问语法」，它让你可以像访问 Kotlin 属性一样访问 <code>JavaBeans</code> 类型的 <code>getters</code> 和 <code>setters</code> 方法。例如，你可以这样 <code>activity.context</code> 调用 <code>Activity.getContext()</code>，而不用写整个方法名。如果你在 Kotlin 使用传统的方式调用，lint 会给你一个警告告诉你使用「属性调用语法」。</p>
<p>这是一个很好的特性，但是有时候我的方法名以 <code>get</code> 开始，但是并不想使用「属性调用语法」。一个很常见的例子就是 Java 的原子类。如果你有一个变量 <code>val i = AtomicInteger()</code>，你可能想通过 <code>i.getAndIncrement()</code> 调用。但是 Kotlin 会想让你用 <code>i.andIncrement</code> 这种方式调用。这明显是画蛇添足。</p>
<p>你可以在每个调用的地方加上 <code>@Suppress(“UsePropertyAccessSyntax”)</code>，但很丑。如果你可以为这个函数添加一个注解告诉 linter 不要把它当做一个属性会更好。</p>
<h3 id="Method_count"><a href="#Method_count" class="headerlink" title="Method count"></a>Method count</h3><p>用 Kotlin 写代码肯定会减少你项目中的代码行数。但是它也会提高你的代码在编译以后的方法数。有很多原因导致这一点，但是其中一个主要原因就是 Kotlin 属性的实现方式。</p>
<p>和 Java 不一样，Kotlin 没有提供单独定义域的方式。你必须使用 <code>val</code> 或者 <code>var</code> 来声明变量。这样有一个好处，就是你可以随意为一个属性添加 <code>get</code> 或 <code>set</code> 方法而不会破坏其他地方对该属性引用的代码。这个特性省去了像 Java 一样定义 <code>getters</code> 和 <code>setters</code> 方法。</p>
<p>尽管如此，这个特性需要一定的成本。每一个公开的 <code>val</code> 变量都会导致 Kotlin 生成一个「支持域」和一个能被 Java 调用的 <code>getter</code> 方法。每一个公开的 <code>var</code> 变量都会生成 <code>getter</code> 和 <code>setter</code> 方法。庆幸的是，私有属性的 <code>getters</code> 和 <code>setters</code> 会生成域而不是生成方法。如果你之前的 Java 代码中定义了大量的公开域（这在定义常量的时候很常见），你会惊奇的发现方法大幅上升。</p>
<p>如果你的 Android 应用快接近方法数限制了，我建议你为不需要自定义 <code>getter</code> 方法的常量加上 <code>@JvmField</code> 注解。这样会阻止  <code>getters</code> 方法的生成，从而减少你的方法数。「更新：Kirill Rakhman 在评论中指出，你可以使用 <code>const</code> 修饰符替代 </p>
<p>不过其实没有那么糟。就像我在 <a href="https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6" target="_blank" rel="external">converting an app to 100% Kotlin</a> 文章里讨论过的，Kotlin 的标准库非常小，并且能够替代 Java 的许多常用库，这些库通常都更大，现在你再也不需要他们了。多亏了 Kotlin 的标准库，在从 Java 全部转换到 Kotlin 以后方法数反而减少了。只要你控制不会出现大范围的方法数提升，就不会有什么问题。</p>
<h2 id="The_Ugly"><a href="#The_Ugly" class="headerlink" title="The Ugly"></a>The Ugly</h2><p>最后，Kotlin 有两个设计我不是很认同，而且我不期望这个在未来会有什么改变。</p>
<h3 id="SAM_conversion_and_Unit_returning_lambdas"><a href="#SAM_conversion_and_Unit_returning_lambdas" class="headerlink" title="SAM conversion and Unit returning lambdas"></a>SAM conversion and Unit returning lambdas</h3><p>这真是一个莫名其妙的设计。</p>
<p>可以嵌入 lambda 表达式是 Kotlin 最好的特性之一。如果有一个 Java 函数，它只有一个 SAM 接口（只有一个抽象方法的接口）：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">registerCallback</span><span class="params">(View.OnClickListener r)</span></span></span><br></pre></td></tr></table></figure>
<p>无论是 Java 还是 Kotlin，你都可以传递一个普通的 lambda 表达式去调用它。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="tag">registerCallback</span>(() -&gt; &#123; <span class="comment">/** do stuff */</span> &#125;)</span><br><span class="line"><span class="comment">//Kotlin</span></span><br><span class="line"><span class="tag">registerCallback</span> &#123; <span class="comment">/** do stuff */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>这的确很棒。但当你尝试去用 Kotlin 去定义类似的方法是莫名的困难。从 Java 测调用没有什么不同，但是当从 Kotlin 调用时需要明确指定类型。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">registerCallback</span></span>(<span class="symbol">r:</span> <span class="constant">View</span>.<span class="constant">OnClickListener</span>)</span><br><span class="line">/<span class="regexp">/ Kotlin. Note that parenthesis are required now.</span><br><span class="line">registerCallback(View.OnClickListener &#123; /</span>** <span class="keyword">do</span> stuff *<span class="regexp">/ &#125;)</span></span><br></pre></td></tr></table></figure>
<p>不得不说这很烦人，特别是当你从 Java 代码转换到 Kotlin 从而导致 Kotlin 代码不能再正常运行的时候。</p>
<p>常见的方式是用函数类型定义：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">registerCallback</span></span>(<span class="symbol">r:</span> () -&gt; <span class="constant">Unit</span>)</span><br></pre></td></tr></table></figure>
<p> 这样用 Kotlin 调用起来会很方便，但是由于所有的 Kotlin 函数都需要一个返回值，这导致用 Java 调用该函数的时候变得很糟。你不得不显式地从 Java 表达式返回 <code>Unit</code>，这导致 lambda 表达式不可用：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> registerCallback<span class="function"><span class="params">(() -&gt; &#123;</span><br><span class="line">    /** <span class="keyword">do</span> stuff */</span><br><span class="line">    <span class="keyword">return</span> Unit.INSTANCE;</span><br><span class="line">&#125;)</span></span></span><br></pre></td></tr></table></figure>
<p>如果你在用 Kotlin 写库的话，根本找不到一个好的方式去实现一个高阶函数同时让 Java 和 Kotlin 都能方便的调用。在我的 <a href="https://github.com/ajalt/flexadapter" target="_blank" rel="external">FlexAdapter</a> 库里面，我尝试为为每个方法重载 <code>SAM interface</code> 或者 Kotlin 函数类型的参数。这样无论用这两种的哪种语言调用都很方便，但是库的 API 变得不简洁。</p>
<p>希望 Kotlin 的设计者们能够改变他们的想法在将来允许 <code>SAM</code> 转化成 Kotlin 的函数定义，但是我并不抱什么希望。</p>
<h3 id="Closed_by_default"><a href="#Closed_by_default" class="headerlink" title="Closed by default"></a>Closed by default</h3><p>到目前为止我说的所有关于 Kotlin 的缺点基本都是小的语法细节上的不简洁，并不是什么大事。但是，有一个设计在将来有可能导致巨大的痛苦：所有的类和方法默认都是封闭的。这种做法是被 <code>Effective Java</code> 里所推崇的，理论上听起来也很有道理，但对于任何一个需要使用一个有缺陷的第三方库的人来说都是一个坏的选择。</p>
<blockquote>
<p>把所有的叶类都设置成静态的。毕竟你在完成这样一个项目——没有人能够通过扩展你的类的方式来完善你的工作成果。或许是由于安全原因——毕竟，<code>java.lang.String</code> 是 <code>final</code> 不就是由于这个原因吗？如果你项目的其他的成员向你抱怨，就告诉他们这样能提高执行效率——<a href="http://www.mindprod.com/jgloss/unmaindesign.html" target="_blank" rel="external"><em>Roedy Green, How to Write Unmaintainable Code</em></a></p>
</blockquote>
<p>Kotlin 的文档里面的确有文章尝试去抵制这一决定，所以我把他们说的三个理由列出来。</p>
<h3 id="u201CBest_practices_say_that_you_should_not_allow_these_hacks_anyway_u201D"><a href="#u201CBest_practices_say_that_you_should_not_allow_these_hacks_anyway_u201D" class="headerlink" title="“Best practices say that you should not allow these hacks anyway”"></a>“Best practices say that you should not allow these hacks anyway”</h3><p>关于对继承封闭的论据基本是围绕「Fragile Base Class Problem」展开，它认为如果允许在你的库的基础上继承出子类，他们可能改变代码运行的方式从而导致一些 bug。然而这只是一种可能性，会导致库运行异常从而导致 bug 的方式实在太多了。如果你重写一个类的功能，很明显你应该为破坏代码的运行负责。</p>
<p>我之所以用「很明显」是因为重写一个库的功能是很明确的该有使用方自己负责。我已经辅导计算机科学学生很多年了，他们会范所有你能想象到的错误，但是他们从不会因为重载一个方法导致的破坏感到奇怪。实在有太多不经意的方式会导致对依赖库使用的破坏，例如你传递的参数类型是对的但单位却传错了，或者你忘了调用一个必须调用的方法。</p>
<p>我欣赏那种减少代码被破坏可能性的编码方式，把类设置成不可变的的确能达到效果。但可以确定的是所有依赖库一定不是完整的或者是存在缺陷的，你又不可避免的要使用这些依赖库。为了修改一个封闭类，人们常常会使用一些 hack 的方法，这经常会仅仅是重写一两个类或者方法带来的 bug 更多。如果你不相信我说的话，这里有一个活生生的例子，如果你是一个 Android 开发者的话，你应该印象深刻：</p>
<p>AppCompat 23.2.0 终于把 <a href="https://plus.google.com/+AndroidDevelopers/posts/iTDmFiGrVne" target="_blank" rel="external">VectorDrawables</a> 加到 support 包里了。由于可以帮助减少 APK 的体积和内存的占用，要不是它有一个 bug <a href="https://code.google.com/p/android/issues/detail?id=205236" target="_blank" rel="external">会导致在 Activity 里面导致内存泄露</a><br>，本应该收到广泛欢迎。这个支持包在 <a href="https://plus.google.com/+AndroidDevelopers/posts/iTDmFiGrVne" target="_blank" rel="external">几周后被移除</a>。</p>
<p>内存泄露是怎么导致的呢？为了 <a href="https://medium.com/@chrisbanes/appcompat-v23-2-age-of-the-vectors-91cbafa87c88" target="_blank" rel="external">提高 VectorDrawable 填充性能</a>，这个支持包的作者们需要改进 <code>Context.getDrawable</code> 的实现。但是这个方法是不可变的（final），所以他们不得不为每一个视图创建一份 <code>Resources wrapper</code> 的拷贝来处理 <em>VectorDrawables</em>。且不说这带来了大量的工作，这也导致大量的 <code>wrapped Resources</code> 变得不同步和为了复制产生的大量内存开销。如果那个方法不是不可变的，他们就不会这样胡搞了。</p>
<h3 id="u201CPeople_successfully_use_other_languages__28C++_2C_C_23_29_that_have_similar_approach_u201D"><a href="#u201CPeople_successfully_use_other_languages__28C++_2C_C_23_29_that_have_similar_approach_u201D" class="headerlink" title="“People successfully use other languages (C++, C#) that have similar approach”"></a>“People successfully use other languages (C++, C#) that have similar approach”</h3><p>人们在 Python 这样的语言可以在任何时候做任何修改。Python 也有像 <code>_asdict</code> 这样「非公有」不会在文档里描述的方法。它也有像 <code>__intern</code> 这样的 <a href="https://zh.wikipedia.org/wiki/Visual_C%2B%2B%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0" target="_blank" rel="external">name mangled</a> 的函数，很难被发现。你可以自由的用 monkey-patch 或者重写任何一个你想重写的方法，Python 并不禁止这样做。</p>
<p>在我五年全职开发 Python 的期间，我从没有想过谁会通过重写方法破坏我的代码。我能想象在大多数情况下，用正确安全的方法去改变一个私有方法比由于 Python 的禁止而不得不重新实现一个同样的功能更加节约时间。</p>
<p>我并不是说要盲目地把每个类的实现都要改一遍，但是没有理由当我想这么做的时候却做不了。在 Python 社区里面有一句俗语 “We’re all consenting adults here”。你想对我的类做任何修改都可以。</p>
<h3 id="u201CIf_people_really_want_to_hack_2C_there_still_are_ways_3A_you_can_always_write_your_hack_in_Java_and_call_it_from_Kotlin__28see_Java_Interop_29_2C_and_Aspect_frameworks_always_work_for_these_purposes_u201D"><a href="#u201CIf_people_really_want_to_hack_2C_there_still_are_ways_3A_you_can_always_write_your_hack_in_Java_and_call_it_from_Kotlin__28see_Java_Interop_29_2C_and_Aspect_frameworks_always_work_for_these_purposes_u201D" class="headerlink" title="“If people really want to hack, there still are ways: you can always write your hack in Java and call it from Kotlin (see Java Interop), and Aspect frameworks always work for these purposes”"></a>“If people really want to hack, there still are ways: you can always write your hack in Java and call it from Kotlin (see Java Interop), and Aspect frameworks always work for these purposes”</h3><p>这真是一个荒诞的论点。即使是用 Java 如果你不用很难令人接受的反射的话，你依然不能重写封闭的 Kotlin 函数，所以这个论调无足轻重。</p>
<p>不能对依赖库进行扩展意味着想要添加任何新的特性和修改 bug 都很难。现实中，大多数库都需要使用一些黑客的手段。这就是现实，而且不会改变。任何库的作者都不能预测所有用户可能碰到的场景。所有的类都是不可变的只能让库的使用者实现库本身没有的功能的时候变得更加困难。相对于 Kotlin 其他语言特性的便利性，这个设计实在是太令人费解了。</p>
<p>如果你在编写一个 Kotlin 的依赖库，请把你所有的公开方法都设置成开放的。这会让你的用户更加方便。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Kotlin 是一门非常棒的语言。它比 Java 简洁多了，它还有一个非常优秀的标准库，有了这个标准库你就可以将大量为了维持 Java 勉强可用下去的库都删掉了。多亏了代码自动转换功能，你可以很方便的把 Java 代码转换成 Koltin 代码，并且这个功能会越来越完善。如果你是一名 Android 开发者，你真应该去试一试。</p>
<p>原文链接：<a href="http://ohmerhe.com/2016/08/27/kotlin_good_bad_bugly/" target="_blank" rel="external">Kotlin：The Good, The Bad, and The Ugly(译)</a></p>
<p>英文原文：<a href="https://medium.com/keepsafe-engineering/kotlin-the-good-the-bad-and-the-ugly-bf5f09b87e6f#.s0t91g9xn" target="_blank" rel="external">Kotlin: The Good, The Bad, and The Ugly</a></p>
<p>欢迎大家投稿 <a href="http://www.jianshu.com/collection/ce44081f781f" target="_blank" rel="external">Kotlin Three</a></p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>[1]</strong> In the case of a <em>lateinit </em>property,<em>kotlin.UninitializedPropertyAccessException </em>will be thrown, where the<em>Delegates.notNull </em>will throw an <em>IllegalStateException</em>.</li>
<li><strong>[2]</strong> There are some details about <em>lateinit </em>that are worth noting, especially if you plan on accessing a <em>lateinit </em>property from Java code. First is that <em>lateinit</em>cannot be applied to primitive types such as <em>Int </em>or <em>Double</em>. The second is that a <em>lateinit </em>property is backed by a field with the same visibility as the property, and this field is visible from Java. Additionally, that backing field can be freely set to null from Java. If any of those are issues for your use case, <em>Delegates.notNull </em>may be a better choice.</li>
<li><strong>[3]</strong> The lazy <em>Sequence </em>operators can outperform the eager versions by up to 20%, but only once list sizes start growing very large. For lists under a megabyte or so in size, the lazy versions often perform the same or worse than the eager versions.</li>
<li><strong>[4]</strong> This is a bit of a simplification. Kotlin will only generate a backing field if you don’t define a get function, or if the defined get function doesn’t reference the implicit<em> field </em>identifier.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>tags: Kotlin, Android</p>
<p>在我的 <a href="https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6">上一篇文章</a>, 谈到了关于转换 Java 到 Kotlin 代码和我喜欢的一些库。现在，我想要谈谈关于 Kotlin 这门语言本身的想法，还有它和 Java 交互的方式。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin 一个扩展函数，从此丢掉 ViewHolder]]></title>
    <link href="http://yoursite.com/2016/08/02/kotlin_one_method_no_viewholder/"/>
    <id>http://yoursite.com/2016/08/02/kotlin_one_method_no_viewholder/</id>
    <published>2016-08-02T15:57:49.000Z</published>
    <updated>2017-05-16T15:57:03.000Z</updated>
    <content type="html"><![CDATA[<p>tags: Android, Kotlin</p>
<h2 id="ViewHolder"><a href="#ViewHolder" class="headerlink" title="ViewHolder"></a>ViewHolder</h2><p>作为一名 Android 开发者，对 ViewHolder 应该再熟悉不过了。ViewHolder 一开始并不是 Android 原生提供的（现在已经是 RecycleView 的默认实现了），而是 Google 为了提高 ListView 的使用性能，为开发者提供的一种最佳实践，具体可以参考 <a href="https://developer.android.com/training/improving-layouts/smooth-scrolling.html#ViewHolder" target="_blank" rel="external">ViewHolder</a>。</p>
<a id="more"></a>
<p>Google 提供的 ViewHolder 的标准实现如下，熟悉者可以直接跳到下个部分「ViewHolder变种」继续阅读。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">  TextView text;</span><br><span class="line">  TextView timestamp;</span><br><span class="line">  ImageView icon;</span><br><span class="line">  ProgressBar progress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Item 第一次创建视图的时候，填充 ViewHolder 并且将其保存在视图中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ViewHolder holder = <span class="keyword">new</span> ViewHolder();</span><br><span class="line">holder.icon = (ImageView) convertView.findViewById(R.id.listitem_image);</span><br><span class="line">holder.text = (TextView) convertView.findViewById(R.id.listitem_text);</span><br><span class="line">holder.timestamp = (TextView) convertView.findViewById(R.id.listitem_timestamp);</span><br><span class="line">holder.progress = (ProgressBar) convertView.findViewById(R.id.progress_spinner);</span><br><span class="line">convertView.setTag(holder);</span><br></pre></td></tr></table></figure>
<p>在填充 Item 数据的时候，直接使用 Viewholder 对象的属性，这样可以减少在滚动 ListView 频繁调用 <code>findViewById()</code> 而导致的性能问题。</p>
<h2 id="ViewHolder_u53D8_u79CD"><a href="#ViewHolder_u53D8_u79CD" class="headerlink" title="ViewHolder变种"></a>ViewHolder变种</h2><p>Google 提供的 ViewHolder 的确能够提升 ListView 的使用效率，但是 ViewHolder 的实现相对繁琐，需要为每一种 Item 定义一个 ViewHolder，对代码书写和维护都是额外的开销。于是有人针对 ViewHolder 的实现做了一些优化，让 ViewHolder 写起来更方便。网上有很多种写法，我最认可的是下面的这种实现，简单优雅。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> ViewHolder &#123;    </span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)  </span><br><span class="line">    public static &lt;T extends <span class="keyword">View</span>&gt; T <span class="literal">get</span>(<span class="keyword">View</span> <span class="keyword">view</span>, int id) &#123;  </span><br><span class="line">        SparseArray&lt;<span class="keyword">View</span>&gt; viewHolder = (SparseArray&lt;<span class="keyword">View</span>&gt;) <span class="keyword">view</span>.getTag();  </span><br><span class="line">        <span class="keyword">if</span> (viewHolder == null) &#123;  </span><br><span class="line">            viewHolder = new SparseArray&lt;<span class="keyword">View</span>&gt;();  </span><br><span class="line">            <span class="keyword">view</span>.setTag(viewHolder);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">View</span> childView = viewHolder.<span class="literal">get</span>(id);  </span><br><span class="line">        <span class="keyword">if</span> (childView == null) &#123;  </span><br><span class="line">            childView = <span class="keyword">view</span>.findViewById(id);  </span><br><span class="line">            viewHolder.put(id, childView);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> (T) childView;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用 <code>SparseArray</code> 映射每个视图 <code>id</code> 和对应的视图，并将其保存在视图中，这样既保证在滚动过程中频繁获取视图的效率，使用起来也极其方便。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ImageView bananaView = ViewHolder.get(convertView, R.id.banana);  </span><br><span class="line">TextView phoneView = ViewHolder.get(convertView, R.id.phone);  </span><br><span class="line">BananaPhone bananaPhone = getItem(position);  </span><br><span class="line">phoneView.setText(bananaPhone.getPhone());</span><br></pre></td></tr></table></figure>
<h2 id="Kotlin__u6269_u5C55_u51FD_u6570"><a href="#Kotlin__u6269_u5C55_u51FD_u6570" class="headerlink" title="Kotlin 扩展函数"></a>Kotlin 扩展函数</h2><p>这里Kotlin 实现 ViewHolder 的扩展函数和上面的变种使用的同一种思路，但得益于 Kotlin 语言提供的特性，实现和使用起来更加方便流畅，甚至都感觉不到 ViewHolder 这种特殊机制的存在。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : View&gt;</span> View.<span class="title">findViewOften</span><span class="params">(viewId: <span class="typename">Int</span>)</span>: T &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> viewHolder</span>: SparseArray<span class="type">&lt;View&gt;</span> = tag <span class="keyword">as</span>? SparseArray<span class="type">&lt;View&gt;</span> ?: SparseArray()</span><br><span class="line">    tag = viewHolder</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> childView</span>: View? = viewHolder.<span class="keyword">get</span>(viewId)</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == childView) &#123;</span><br><span class="line">        childView = findViewById(viewId)</span><br><span class="line">        viewHolder.put(viewId, childView)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> childView <span class="keyword">as</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里实现了一个 View 的扩展函数 <code>findViewOften(viewId: Int)</code> 意味着在需要频繁寻找一个视图的子视图的情况下使用，这样我们在 Item 中就可以这样写了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val subTitle: TextView = convertView.<span class="function"><span class="title">findViewOften</span><span class="params">(R.id.list_item_subtitle)</span></span></span><br><span class="line">subTitle<span class="class">.text</span> = itemData.subTitle</span><br></pre></td></tr></table></figure>
<p>由于 Kotlin 提供类型推断功能，所以 <code>findViewOften</code> 的返回值不用手动转换或者手动指定泛型类型。</p>
<p>利用 Kotlin 的语言特性，为 View 扩展一个方法，从此再也不用繁琐的定义 Viewholder 了，使用的时候也是如此的顺畅，从此再也不必记得什么 ViewHolder 了。</p>
<p>PS: 该方法在 <a href="https://github.com/KotlinThree/AndroidExtension" target="_blank" rel="external">AndroidExtension</a> 已经提供封装，这个库里面还封装了一些其他方法，也蛮好用的，不过这个库还没有正式发布。</p>
<h2 id="RecycleView__u7684_ViewHolder"><a href="#RecycleView__u7684_ViewHolder" class="headerlink" title="RecycleView 的 ViewHolder"></a>RecycleView 的 ViewHolder</h2><p>最后，不得不提一下在 RecycleView 应该怎么办，因为在 RecycleView 的机制里面，在创建 Item 的 View 的时候，必须创建一个 RecyclerView.ViewHolder 并且返回。对于我们上面那么完美的封装， Google 这明显是在帮倒忙，还好这忙虽然帮倒了，不过还不至于无法挽回。</p>
<p>如果大家在使用 RecycleView 还想使用本文提供的方法的话，可以参考我下面的方式实现。提供一个 RecyclerView.ViewHolder 默认实现类，该类提供一个通过 <code>id</code> 获取视图的方法，在创建 Item 的 View 的时候默认都返回这个类的实例。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewHolder</span></span>(<span class="variable"><span class="keyword">val</span> convertView</span>: View) : RecyclerView.ViewHolder(convertView) &#123;</span><br><span class="line">    	<span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : View&gt;</span> <span class="title">findView</span><span class="params">(viewId: <span class="typename">Int</span>)</span>: T &#123;</span></span><br><span class="line">        <span class="keyword">return</span> convertView.findViewOften(viewId)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不想 <code>MyViewHolder</code> 的外部有不需要的依赖，可以将 <code>findViewOften</code> 直接实现在 <code>MyViewHolder</code> 里面。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.android.com/training/improving-layouts/smooth-scrolling.html#ViewHolder" target="_blank" rel="external">ViewHolder</a></li>
<li><a href="http://www.programcreek.com/java-api-examples/android.util.SparseArray" target="_blank" rel="external">Java Code Examples for android.util.SparseArray</a></li>
<li><a href="https://github.com/KotlinThree/AndroidExtension" target="_blank" rel="external">AndroidExtension</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>tags: Android, Kotlin</p>
<h2 id="ViewHolder"><a href="#ViewHolder" class="headerlink" title="ViewHolder"></a>ViewHolder</h2><p>作为一名 Android 开发者，对 ViewHolder 应该再熟悉不过了。ViewHolder 一开始并不是 Android 原生提供的（现在已经是 RecycleView 的默认实现了），而是 Google 为了提高 ListView 的使用性能，为开发者提供的一种最佳实践，具体可以参考 <a href="https://developer.android.com/training/improving-layouts/smooth-scrolling.html#ViewHolder">ViewHolder</a>。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NullPointException 利器 Kotlin 可选型]]></title>
    <link href="http://yoursite.com/2016/07/14/kotlin-type-option/"/>
    <id>http://yoursite.com/2016/07/14/kotlin-type-option/</id>
    <published>2016-07-14T10:52:57.000Z</published>
    <updated>2017-05-16T15:44:58.000Z</updated>
    <content type="html"><![CDATA[<p>tags: Kotlin</p>
<p>NullPointException (简称 NPE ) 被称作 <a href="https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions" target="_blank" rel="external">The Billion Dollar Mistake</a> 一直困扰着Java 和 Android 开发者。Kotlin 的类型系统中提供可选类型用于减少 NPE 问题带来的风险。</p>
<a id="more"></a>
<p>虽然，Kotlin 提供了可选类型用于减少 NPE 问题的风险，但是并没有办法完全消除 NPE 带来的隐患，本问将探讨如何巧妙地使用「可选型」更好的规避 NPE 的发生。</p>
<h2 id="u53EF_u9009_u578B_u5B9A_u4E49"><a href="#u53EF_u9009_u578B_u5B9A_u4E49" class="headerlink" title="可选型定义"></a>可选型定义</h2><h3 id="u975E_u7A7A_u7C7B_u578B"><a href="#u975E_u7A7A_u7C7B_u578B" class="headerlink" title="非空类型"></a>非空类型</h3><p>我们先从可选型的定义开始，当我们在 Kotlin 中定义一个变量时，默认就是非空类型的，当你将一个非空类型置空的时候，编译器会告诉你这不可行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> a</span>: String = <span class="string">"abc"</span></span><br><span class="line">a = <span class="literal">null</span> <span class="comment">// compilation error</span></span><br></pre></td></tr></table></figure>
<p>因此，如果你后面任何时候使用该变量时，都可以放心的使用而不用担心会发生 NPE。所以要想远离 NPE，首先需要<strong>「尽可能的使用非空类型的定义」</strong>。</p>
<h3 id="u53EF_u9009_u578B_uFF08_u53EF_u7A7A_u7C7B_u578B_uFF09"><a href="#u53EF_u9009_u578B_uFF08_u53EF_u7A7A_u7C7B_u578B_uFF09" class="headerlink" title="可选型（可空类型）"></a>可选型（可空类型）</h3><p>虽然「非空类型」能够有效避免 NPE 的问题，但是有时候我们总不可避免的需要使用「可选类型」。在定义可选型的时候，我们只要在非空类型的后面添加一个 <code>?</code> 就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> b</span>: String? = <span class="string">"abc"</span></span><br><span class="line">b = <span class="literal">null</span> <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>在使用可选型变量的时候，这个变量就有可能为空，所以在使用前我们应该对其进行空判断（在 Java 中我们经常这样做），这样往往带来带来大量的工作，这些空判断代码本身没有什么实际意义，并且让代码的可读性和简洁性带来了巨大的挑战。在网上可以看到许多人针对如何减少 NPE 提出了自己的建议，有的的确很不错，但成本依然很大。除此之外，还有一个最可恶的场景「我们会忘记」。</p>
<p>Kotlin 为了解决这个问题，它并不允许我们直接使用一个可选型的变量去调用方法或者属性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> l</span> = b.length <span class="comment">// compilation error</span></span><br></pre></td></tr></table></figure>
<p>你可以和 Java 中一样，在使用变量之前先进行空判断，然后再去调用。如果使用这种方法，那么空判断是必须的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> l</span> = <span class="keyword">if</span> (b != <span class="literal">null</span>) b.length <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>注意： 如果你定义的变量是全局变量，即使你做了空判断，依然不能使用变量去调用方法或者属性。</strong>这个时候你需要考虑使用下面的介绍的方法。</p>
<p>Kotlin 为可选型提供了一个安全调用操作符 <code>?.</code>，使用该操作符可以方便调用可选型的方法或者属性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> l</span> = b?.length</span><br></pre></td></tr></table></figure>
<p>这里 <code>l</code> 得到的返回依然是一个可选型 <code>Int?</code>。</p>
<p>Kotlin 还提供了一个强转的操作符 <code>!!</code>，这个操作符能够强行调用变量的方法或者属性，而不管这个变量是否为空，如果这个时候该变量为空时，那么就会发生 NPE。所以如果不想继续陷入 NPE 的困境无法自拔，请不要该操作符走的太近。</p>
<h2 id="Elvis__u64CD_u4F5C_u7B26"><a href="#Elvis__u64CD_u4F5C_u7B26" class="headerlink" title="Elvis 操作符"></a><code>Elvis</code> 操作符</h2><p>上面有提到一种情况，当 <code>b</code> 为空时，返回它的长度值给一个默认值 -1。要实现这样的逻辑当然可以用 <code>ifelse</code> 的逻辑判断实现，但 Kotlin 提供了一个更优雅的书写方式 <code>?:</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> l</span> = b?.length ?: -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>b?.length ?: -1</code> 和 <code>if (b != null) b.length else -1</code> 完全等价的。</p>
<p>其实你还可以在 <code>?:</code> 后面添加任何表达式，比如你可以在后面会用 <code>return</code> 和 <code>throw</code>（在 Kotlin 中它们都是表达式）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(node: <span class="typename">Node</span>)</span>: String? &#123;</span></span><br><span class="line">  <span class="variable"><span class="keyword">val</span> parent</span> = node.getParent() ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="variable"><span class="keyword">val</span> name</span> = node.getName() ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"name expected"</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="let__u51FD_u6570"><a href="#let__u51FD_u6570" class="headerlink" title="let 函数"></a><code>let</code> 函数</h2><p><code>let</code> 是官方 <code>stdlib</code> 提供的标准函数库里面的函数，这个函数巧妙的利用的 Kotlin 语言的特性让 <code>let</code> 接受的表达式参数中的调用方是非空的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> listWithNulls</span>: List<span class="type">&lt;String?&gt;</span> = listOf(<span class="string">"A"</span>, <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> listWithNulls) &#123;</span><br><span class="line">    item?.let &#123; println(it) &#125; <span class="comment">// prints A and ignores null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的只会输出 <code>A</code>，而不会输出 <code>null</code>。</p>
<p><strong>需要注意的是，这个方法调用的时候必须要使用 <code>?.</code> 操作符调用才能生效哦。</strong>如果你的部分代码依赖于一个可选型变量为非空的时候，就可以使用 <code>let</code> 函数。</p>
<p>参考这个函数的实现，下面我尝试提供几个自己定义的方法。</p>
<h2 id="u81EA_u5B9A_u4E49_u5904_u7406"><a href="#u81EA_u5B9A_u4E49_u5904_u7406" class="headerlink" title="自定义处理"></a>自定义处理</h2><p>这里定义的两个方法是参考 <code>Swift</code> 里面的 <code>if let</code> 和 <code>guard</code> 进行的抽象。</p>
<h3 id="orElse__u51FD_u6570"><a href="#orElse__u51FD_u6570" class="headerlink" title="orElse 函数"></a><code>orElse</code> 函数</h3><p><code>orElse</code> 是和 <code>Elvis</code> 函数结合使用的，默认 <code>Elvis</code> 后面只能直接或者执行一个表达式获取返回值或者直接通过 <code>return</code> 或者 <code>throw</code> 结束当前函数的执行。结合 <code>orElse</code> 函数，你能够更加灵活的处理前面的 <code>null</code>。</p>
<ul>
<li>你可以处理一些逻辑以后，再返回一个可用的值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> a</span>:String? = <span class="literal">null</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> b</span> = a ?: orElse &#123;</span><br><span class="line">	<span class="comment">// 做任何事</span></span><br><span class="line">   <span class="keyword">return</span>@orElse <span class="string">"s"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以处理一些逻辑后， 通过<code>return</code> 或者 <code>throw</code> 结束当前函数的执行。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> a</span>:String? = <span class="literal">null</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> b</span> = a ?: orElse &#123;</span><br><span class="line">	<span class="comment">// 做任何事</span></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="guard__u51FD_u6570"><a href="#guard__u51FD_u6570" class="headerlink" title="guard 函数"></a><code>guard</code> 函数</h3><p><code>Elvis</code> 默认只能对单个变量或表达式是否为空进行处理，当碰到多个变量需要一起判断时，就会束手无策，<code>guard</code> 就是为了解决这个问题。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun testGuard(a: String?, b: String?, c: String?)&#123;</span><br><span class="line">	guard(a, b, c) ?: orElse &#123;</span><br><span class="line">        print("a or b or c is null </span><br><span class="line">")</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // 现在 `a`，`b`，`c` 都是不为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于没有编译器的支持，所以暂时还不能实现 <a href="https://kotlinlang.org/docs/reference/null-safety.html#checking-for-null-keyword--in-conditions" target="_blank" rel="external">空屏蔽</a>。</p>
<p>这里定义的两个函数的实现，你可以自己尝试去实现一下，就当是个练习（鬼笑）。<a href="https://github.com/KotlinThree/AndroidExtension" target="_blank" rel="external">AndroidExtension</a>有具体的实现代码。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>经过一系列分析以后，我们已经对怎么使用好 Kotlin 可选型有一定的了解，如果不想 NPE 问题不断困扰，可以参考这里总结的几条。</p>
<ul>
<li>尽可能的使用非空类型的定义</li>
<li>远离 <code>!!</code>，如果非要用，请调用代码在前面「三行之内」进行非空判断</li>
<li>熟练使用 <code>Elvis</code> 操作符</li>
<li>自定义一些常用的函数，让自己的代码更流畅</li>
</ul>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://kotlinlang.org/docs/reference/null-safety.html" target="_blank" rel="external">null-safety</a></li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0056-trailing-closures-in-guard.md" target="_blank" rel="external">trailing-closures-in-guard</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>tags: Kotlin</p>
<p>NullPointException (简称 NPE ) 被称作 <a href="https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions">The Billion Dollar Mistake</a> 一直困扰着Java 和 Android 开发者。Kotlin 的类型系统中提供可选类型用于减少 NPE 问题带来的风险。</p>]]>
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin 函数式编程三板斧]]></title>
    <link href="http://yoursite.com/2016/07/05/kotlin_function_three_common_methods/"/>
    <id>http://yoursite.com/2016/07/05/kotlin_function_three_common_methods/</id>
    <published>2016-07-05T14:06:41.000Z</published>
    <updated>2017-05-16T15:54:44.000Z</updated>
    <content type="html"><![CDATA[<p>tags: kotlin, 函数式编程, map, filter, reduce</p>
<p>每个函数式语言都提供及几大类基本函数，这些函数在功能上一般都极为相似，但是在名称和调用方法上可能有一些细微的差别。今天就讲讲 <code>Kotlin</code> 中提供的函数式编程三板斧<code>filter</code>、<code>map</code>、<code>reduce</code>。</p>
<a id="more"></a>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>筛选函数将用户给定的布尔逻辑作用于集合，返回由原集合中符合条件的元素组合的一个子集。假设一个逻辑，将数组中是3的倍数的数筛选出来，和 <code>Java</code> 做一个简单的对比。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java 代码</span></span><br><span class="line"><span class="keyword">int</span>[] all = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a : all) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        filters.add(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kotlin 代码</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> all</span> = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"><span class="variable"><span class="keyword">val</span> filters</span> = all.filter &#123; it % <span class="number">3</span> == <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin 还提供一系列类似的过滤函数：</p>
<ul>
<li><code>filterIndexed</code>, 同 <code>filter</code>，不过在逻辑判断的方法块中可以拿到当前item的index</li>
<li><code>filterNot</code>，与<code>filter</code>相反，只返回不符合条件的元素组合</li>
</ul>
<p>针对 <code>Map</code> 类型数据集合，提供了 <code>filterKeys</code> 和 <code>filterValues</code> 方法，方便只做 key 或者 value 的判断。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>映射函数也是一个高阶函数，将一个集合经过一个传入的变换函数映射成另外一种集合。</p>
<p>假设我们现在需要将一系列的名字的长度保存到另一个数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 代码</span></span><br><span class="line">String[] names = &#123;<span class="string">"James"</span>, <span class="string">"Tom"</span>, <span class="string">"Jack"</span>, <span class="string">"Kobe"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] namesLength = <span class="keyword">new</span> <span class="keyword">int</span>[names.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.length ; i ++) &#123;</span><br><span class="line">    namesLength[i] = names[i].length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kotlin 代码</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> names</span> = arrayOf(<span class="string">"James"</span>, <span class="string">"Tom"</span>, <span class="string">"Jack"</span>, <span class="string">"Kobe"</span>);</span><br><span class="line"><span class="variable"><span class="keyword">val</span> namesLength</span> = names.map &#123; it.length &#125;</span><br></pre></td></tr></table></figure>
<p>映射函数是将一个集合映射成另外一种集合，所以当你需要见一个 HaspMap 映射成一个 List 的时候，会非常方便。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> params</span> = mapOf(<span class="string">"limit"</span> to <span class="string">"10"</span>, <span class="string">"offset"</span> to <span class="string">"20"</span>, <span class="string">"order"</span> to <span class="string">"asc"</span>)</span><br><span class="line"><span class="variable"><span class="keyword">val</span> s</span> = params.map &#123; <span class="string">"$&#123;it.key&#125;=$&#123;it.value&#125;"</span> &#125;.joinToString(<span class="string">"&amp;"</span>)</span><br><span class="line"><span class="comment">// s = limit=10&amp;offset=20&amp;order=asc</span></span><br></pre></td></tr></table></figure>
<p>同 <code>filter</code> 相似，Kotlin 也提供的 <code>mapIndexed</code> 的类似方法方便使用，针对 <code>Map</code> 类型的集合也有 <code>mapKeys</code> 和 <code>mapValues</code> 的封装。</p>
<h2 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h2><p>归纳函数将一个数据集合的所有元素通过传入的操作函数实现数据集合的积累叠加效果。</p>
<p>假设我们需要将一首藏头诗的每句诗的第一句拿出来拼成一句话。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 代码</span></span><br><span class="line">String[] texts = &#123;<span class="string">"芦花丛中一扁舟"</span>, <span class="string">"俊杰俄从此地游"</span>, <span class="string">"义士若能知此理"</span>, <span class="string">"反躬难逃可无忧"</span>&#125;;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; texts.length ; i ++) &#123;</span><br><span class="line">    sb.append(texts[i].substring(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">String result = sb.toString();</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kotlin 代码</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> texts</span> = arrayOf(<span class="string">"芦花丛中一扁舟"</span>, <span class="string">"俊杰俄从此地游"</span>, <span class="string">"义士若能知此理"</span>, <span class="string">"反躬难逃可无忧"</span>)</span><br><span class="line"><span class="variable"><span class="keyword">val</span> result</span> = texts.map &#123; it.substring(<span class="number">0</span>,<span class="number">1</span>) &#125;.reduce &#123; r, s -&gt; <span class="string">"$r$s"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>最后得到的结果是「卢俊义反」。</p>
<h2 id="u51FD_u6570_u5F0F_u7F16_u7A0B"><a href="#u51FD_u6570_u5F0F_u7F16_u7A0B" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程的精髓在于函数本身。在函数式编程中函数是第一等公民，与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p>
<p>函数式编程好的实践在于对运算过程的高度抽象和没有”副作用”（既保持函数的独立性），函数式编程三板斧是函数式编程的典型范式，在编程中被大量使用，即使人们不关注函数式编程，在使用函数式编程语言的时候，也会不自觉的使用这些函数。</p>
<p>函数式编程是一种思维方式，函数式编程鼓励放弃对状态的维持（是命令式编程的基础），将所有的操作都交给运行时去执行。当然为了保证程序运行的效率，这需要提供一些辅助性的手段（缓存、缓求值等）。</p>
<p>[参考资料]</p>
<ul>
<li><a href="https://book.douban.com/subject/26587213/" target="_blank" rel="external">函数式编程思维</a></li>
<li><a href="http://baike.baidu.com/view/1711147.htm" target="_blank" rel="external">函数式编程</a></li>
<li><a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="external">kotlin doc</a></li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/" target="_blank" rel="external">kotlin api doc</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>tags: kotlin, 函数式编程, map, filter, reduce</p>
<p>每个函数式语言都提供及几大类基本函数，这些函数在功能上一般都极为相似，但是在名称和调用方法上可能有一些细微的差别。今天就讲讲 <code>Kotlin</code> 中提供的函数式编程三板斧<code>filter</code>、<code>map</code>、<code>reduce</code>。</p>]]>
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="函数式编程" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin 实现配置化网络请求]]></title>
    <link href="http://yoursite.com/2016/06/13/kotlin_config_http_kolley/"/>
    <id>http://yoursite.com/2016/06/13/kotlin_config_http_kolley/</id>
    <published>2016-06-13T12:23:05.000Z</published>
    <updated>2017-05-16T15:54:37.000Z</updated>
    <content type="html"><![CDATA[<p>Kotlin官方提供一个DSL的典型应用场景，<a href="https://github.com/Kotlin/anko" target="_blank" rel="external">Anko</a>致力直接用Kotlin配置页面布局和视图的属性。将布局文件代码化能够带来许多如类型安全、解析效率、代码重用等好处，而<code>Anko</code>让代码布局和XML一样简洁清晰。</p>
<a id="more"></a>
<p>受到<code>Anko</code>的启发，让我萌生了把<code>Android</code>中网络请求纷繁复杂配置信息也封装成配置化方式，实现如下方式的网络请求。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Http.<span class="keyword">get</span> &#123;</span><br><span class="line">    url = <span class="string">"http://api.openweathermap.org/data/2.5/weather"</span></span><br><span class="line">    headers &#123;</span><br><span class="line">        <span class="string">"Content-Type"</span> - 'application/json'</span><br><span class="line">        <span class="string">"pragma-token"</span> - '<span class="number">33162</span>acxxxxxx5032ad21e0e79ff70d'</span><br><span class="line">    &#125;</span><br><span class="line">    params &#123;</span><br><span class="line">        <span class="string">"q"</span> - <span class="string">"shanghai"</span></span><br><span class="line">        <span class="string">"appid"</span> - <span class="string">"d7a98cf22463b1c0c3df4adfe5abbc77"</span></span><br><span class="line">    &#125;</span><br><span class="line">    onSuccess &#123; bytes -&gt;</span><br><span class="line">        <span class="comment">// handle data</span></span><br><span class="line">    &#125;</span><br><span class="line">    onFail &#123; error -&gt;</span><br><span class="line">        <span class="comment">// handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目前该框架已经完成，后面还会继续完善，项目地址<a href="https://github.com/ohmerhe/Kolley" target="_blank" rel="external">Kolley</a></p>
<p>奔着这个目标，我把之前自己简单封装的Volley库翻出来，用Kotlin重新封装一下。经过分析总体过程大概如下：</p>
<ul>
<li>基础代码转Kotlin</li>
<li>重定义原子Request</li>
<li>Request构造配置化</li>
<li>提供RESTful方法</li>
</ul>
<h2 id="u57FA_u7840_u4EE3_u7801_u8F6CKotlin"><a href="#u57FA_u7840_u4EE3_u7801_u8F6CKotlin" class="headerlink" title="基础代码转Kotlin"></a>基础代码转Kotlin</h2><p>之前的框架是参考<a href="https://github.com/loopj/android-async-http" target="_blank" rel="external">android-async-http</a>做的封装，用<code>okhttp</code>作为网络请求引擎，图片请求缓存模块使用的<code>jakewharton</code>提供的<code>disklrucache</code>，这两块都可以复用，先将这部分代码直接转成<code>Kotlin</code>实现。</p>
<p>这不需要花太多的功夫，将java代码复制过来以后，直接使用Android Studio的快速转换功能，转换后可能会有一些语法上的错误，稍微处理一下就可以了，得到类似的内容。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OkHttpStack</span> @<span class="title">JvmOverloads</span> <span class="title">constructor</span></span>(client: OkHttpClient = OkHttpClient()) : HurlStack() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> mFactory</span>: OkUrlFactory</span><br><span class="line">    init &#123;</span><br><span class="line">        mFactory = OkUrlFactory(client)</span><br><span class="line">    &#125;</span><br><span class="line">    @Throws(IOException::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createConnection</span><span class="params">(url: <span class="typename">URL</span>)</span>: HttpURLConnection &#123;</span></span><br><span class="line">        <span class="keyword">return</span> mFactory.<span class="keyword">open</span>(url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u91CD_u5B9A_u4E49_u539F_u5B50Request"><a href="#u91CD_u5B9A_u4E49_u539F_u5B50Request" class="headerlink" title="重定义原子Request"></a>重定义原子Request</h2><p>需要在Volley提供的<code>Request</code>基础上继承一个<code>BaseRequest</code>预处理一些信息，如params。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByteRequest</span></span>(method: <span class="typename">Int</span>, url: String, errorListener: Response.ErrorListener? = Response.ErrorListener &#123;&#125;)</span><br><span class="line">: BaseRequest<span class="type">&lt;ByteArray&gt;</span>(method, url, errorListener) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseNetworkResponse</span><span class="params">(response: <span class="typename">NetworkResponse?</span>)</span>: Response<span class="type">&lt;ByteArray&gt;</span>? &#123;</span></span><br><span class="line">        <span class="keyword">return</span> Response.success(response?.data, HttpHeaderParser.parseCacheHeaders(response))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">BaseRequest</span>&lt;<span class="type">D</span>&gt;</span>(method: <span class="typename">Int</span>, url: String, errorListener: Response.ErrorListener? = Response.ErrorListener &#123;&#125;)</span><br><span class="line">: Request<span class="type">&lt;D&gt;</span>(method, url, errorListener) &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable"><span class="keyword">val</span> DEFAULT_CHARSET</span> = <span class="string">"UTF-8"</span></span><br><span class="line">    internal <span class="variable"><span class="keyword">var</span> _listener</span>: Response.Listener<span class="type">&lt;D&gt;</span>? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable"><span class="keyword">val</span> _params</span>: MutableMap<span class="type">&lt;String, String&gt;</span> = HashMap() <span class="comment">// used for a POST or PUT request.</span></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Returns a Map of parameters to be used for a POST or PUT request.</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getParams</span><span class="params">()</span>: MutableMap<span class="type">&lt;String, String&gt;</span> &#123;</span></span><br><span class="line">        <span class="keyword">return</span> _params</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">deliverResponse</span><span class="params">(response: <span class="typename">D?</span>)</span> &#123;</span></span><br><span class="line">        _listener?.onResponse(response)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="typename">String</span>)</span> &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</span><br><span class="line">            Log.d(this.javaClass.simpleName, msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Request_u6784_u9020_u914D_u7F6E_u5316"><a href="#Request_u6784_u9020_u914D_u7F6E_u5316" class="headerlink" title="Request构造配置化"></a>Request构造配置化</h2><p>上一步封装的<code>Request</code>必须在构造器中提供一些参数，并且像<code>Listener</code>这样的参数不能直接传递表达式，为配置化调用的封装提供了一定的困难。需要重新封装一个<code>Request</code>构造器，再在最后交给执行队列的时候创建真正的<code>Request</code>传递给它，这样让所有网络请求需要的配置信息都可以很方便的构造。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseRequestWapper</span></span>() &#123;</span><br><span class="line">    internal lateinit <span class="variable"><span class="keyword">var</span> _request</span>: ByteRequest</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> url</span>: String = <span class="string">""</span></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> method</span>: <span class="typename">Int</span> = Request.Method.GET</span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> _start</span>: (() -&gt; <span class="typename">Unit</span>) = &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> _success</span>: (ByteArray) -&gt; <span class="typename">Unit</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> _fail</span>: (VolleyError) -&gt; <span class="typename">Unit</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> _finish</span>: (() -&gt; <span class="typename">Unit</span>) = &#123;&#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable"><span class="keyword">val</span> _params</span>: MutableMap<span class="type">&lt;String, String&gt;</span> = HashMap() <span class="comment">// used for a POST or PUT request.</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable"><span class="keyword">val</span> _headers</span>: MutableMap<span class="type">&lt;String, String&gt;</span> = HashMap()</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> tag</span>: Any? = <span class="literal">null</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">(onStart: <span class="typename">(</span>)</span> -&gt; Unit) &#123;</span></span><br><span class="line">        _start = onStart</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(onError: <span class="typename">(VolleyError</span>)</span> -&gt; Unit) &#123;</span></span><br><span class="line">        _fail = onError</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(onSuccess: <span class="typename">(ByteArray</span>)</span> -&gt; Unit) &#123;</span></span><br><span class="line">        _success = onSuccess</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onFinish</span><span class="params">(onFinish: <span class="typename">(</span>)</span> -&gt; Unit) &#123;</span></span><br><span class="line">        _finish = onFinish</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">params</span><span class="params">(makeParam: <span class="typename">RequestPairs.(</span>)</span> -&gt; Unit) &#123;</span></span><br><span class="line">        <span class="variable"><span class="keyword">val</span> requestPair</span> = RequestPairs()</span><br><span class="line">        requestPair.makeParam()</span><br><span class="line">        _params.putAll(requestPair.pairs)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">headers</span><span class="params">(makeHeader: <span class="typename">RequestPairs.(</span>)</span> -&gt; Unit) &#123;</span></span><br><span class="line">        <span class="variable"><span class="keyword">val</span> requestPair</span> = RequestPairs()</span><br><span class="line">        requestPair.makeHeader()</span><br><span class="line">        _headers.putAll(requestPair.pairs)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">excute</span><span class="params">()</span> &#123;</span></span><br><span class="line">        <span class="variable"><span class="keyword">var</span> url</span> = url</span><br><span class="line">        <span class="keyword">if</span> (Request.Method.GET == method) &#123;</span><br><span class="line">            url = getGetUrl(url, _params) &#123; it.toQueryString() &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _request = ByteRequest(method, url, Response.ErrorListener &#123;</span><br><span class="line">            _fail(it)</span><br><span class="line">            _finish()</span><br><span class="line">        &#125;)</span><br><span class="line">        _request._listener = Response.Listener &#123;</span><br><span class="line">            _success(it)</span><br><span class="line">            _finish()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tag != <span class="literal">null</span>) &#123;</span><br><span class="line">            _request.tag = tag</span><br><span class="line">        &#125;</span><br><span class="line">        Http.getRequestQueue().add(_request)</span><br><span class="line">        _start()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getGetUrl</span><span class="params">(url: <span class="typename">String, params: MutableMap&lt;String, String&gt;, toQueryString: (map: Map&lt;String, String&gt;</span>)</span> -&gt;</span></span><br><span class="line">    String): String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (params == <span class="literal">null</span> || params.isEmpty()) url <span class="keyword">else</span> <span class="string">"$url?$&#123;toQueryString(params)&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> Map<span class="type">&lt;K, V&gt;</span>.<span class="title">toQueryString</span><span class="params">()</span>: String = this.map &#123; "$&#123;it.key&#125;=$&#123;it.value&#125;" &#125;.<span class="title">joinToString</span><span class="params">("&amp;")</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中将网络请求需要的所有信息全部包装了一层，这样在调用的时候就可以很方便的逐个设置每个参数（当然会有一些默认值），最后在<code>excute()</code>方法中全部设置给真正的<code>Request</code>。这个封装保证了下面的调用方式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">"http://api.openweathermap.org/data/2.5/weather"</span></span><br><span class="line">params &#123;</span><br><span class="line">    <span class="string">"q"</span> - <span class="string">"shanghai"</span></span><br><span class="line">    <span class="string">"appid"</span> - <span class="string">"d7a98cf22463b1c0c3df4adfe5abbc77"</span></span><br><span class="line">&#125;</span><br><span class="line">onSuccess &#123; bytes -&gt;</span><br><span class="line">    <span class="comment">// handle data</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>PS：上面<code>params</code>是的书写方式，使用了<code>Kotlin</code>的操作符重载功能，具体实现可以下载<a href="https://github.com/ohmerhe/Kolley" target="_blank" rel="external">源码</a>看下。</p>
<h2 id="u63D0_u4F9BRESTful_u65B9_u6CD5"><a href="#u63D0_u4F9BRESTful_u65B9_u6CD5" class="headerlink" title="提供RESTful方法"></a>提供RESTful方法</h2><p>实现到上一步，已经准备的差不多了，接下来还需要最后一步，提供RESTful请求方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Http &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> mRequestQueue</span>: RequestQueue? = <span class="literal">null</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="typename">Context</span>)</span> &#123;</span></span><br><span class="line">        <span class="comment">// Set up the network to use OKHttpURLConnection as the HTTP client.</span></span><br><span class="line">        <span class="comment">// getApplicationContext() is key, it keeps you from leaking the</span></span><br><span class="line">        <span class="comment">// Activity or BroadcastReceiver if someone passes one in.</span></span><br><span class="line">        mRequestQueue = Volley.newRequestQueue(context.applicationContext, OkHttpStack(OkHttpClient()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getRequestQueue</span><span class="params">()</span>: RequestQueue &#123;</span></span><br><span class="line">        <span class="keyword">return</span> mRequestQueue!!</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> request</span>: (<span class="typename">Int</span>, BaseRequestWapper.() -&gt; <span class="typename">Unit</span>) -&gt; Request<span class="type">&lt;ByteArray&gt;</span> = &#123; method, request -&gt;</span><br><span class="line">        <span class="variable"><span class="keyword">val</span> baseRequest</span> = BaseRequestWapper()</span><br><span class="line">        baseRequest.method = method</span><br><span class="line">        baseRequest.request()</span><br><span class="line">        baseRequest.excute()</span><br><span class="line">        baseRequest._request</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> post</span> = request.partially1(Request.Method.POST)</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> put</span> = request.partially1(Request.Method.PUT)</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> delete</span> = request.partially1(Request.Method.DELETE)</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> head</span> = request.partially1(Request.Method.HEAD)</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> options</span> = request.partially1(Request.Method.OPTIONS)</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> trace</span> = request.partially1(Request.Method.TRACE)</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> patch</span> = request.partially1(Request.Method.PATCH)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>request: (Int, BaseRequestWapper.() -&gt; Unit) -&gt; Request&lt;ByteArray&gt;</code>方法为网络请求提供了入口、保证了配置化代码都可以在<code>{}</code>中调用、完成了真正网络请求添加到执行队列。用户可以通过<code>http.requset(method){}</code>方式发起各种请求。</p>
<p><code>val get = request.partially1(Request.Method.GET)</code>等提供了RESTful方法的封装，实现<code>Http.get{}</code>的方便调用。</p>
<h2 id="u540E_u7EED"><a href="#u540E_u7EED" class="headerlink" title="后续"></a>后续</h2><p>关于图片请求模块的实现，其实也是异曲同工，虽然更加复杂一点，但是具体思路是一样的。有兴趣的可以下载<a href="https://github.com/ohmerhe/Kolley" target="_blank" rel="external">源码</a>查看实现，也欢迎提交代码。</p>
<p>图片请求的方式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Image.display &#123;</span><br><span class="line">    url = <span class="string">"http://7xpox6.com1.z0.glb.clouddn.com/android_bg.jpg"</span></span><br><span class="line">    imageView = mImageView</span><br><span class="line">    options &#123;</span><br><span class="line">        <span class="comment">// these values are all default value , you do not need specific them if you do not want to custom</span></span><br><span class="line">        imageResOnLoading = R.drawable.default_image</span><br><span class="line">        imageResOnLoading = R.drawable.default_image</span><br><span class="line">        imageResOnFail = R.drawable.default_image</span><br><span class="line">        decodeConfig = Bitmap.Config.RGB_565</span><br><span class="line">        scaleType = ImageView.ScaleType.CENTER_CROP</span><br><span class="line">        maxWidth = ImageDisplayOption.DETAULT_IMAGE_WIDTH_MAX</span><br><span class="line">        maxHeight = ImageDisplayOption.DETAULT_IMAGE_HEIGHT_MAX</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Image.load &#123;</span><br><span class="line">    url = <span class="string">"http://7xpox6.com1.z0.glb.clouddn.com/android_bg.jpg"</span></span><br><span class="line">    options &#123;</span><br><span class="line">        scaleType = ImageView.ScaleType.CENTER_CROP</span><br><span class="line">        maxWidth = ImageDisplayOption.DETAULT_IMAGE_WIDTH_MAX</span><br><span class="line">        maxHeight = ImageDisplayOption.DETAULT_IMAGE_HEIGHT_MAX</span><br><span class="line">    &#125;</span><br><span class="line">    onSuccess &#123; bitmap -&gt;</span><br><span class="line">        _imageView2?.setImageBitmap(bitmap)</span><br><span class="line">    &#125;</span><br><span class="line">    onFail &#123; error -&gt;</span><br><span class="line">        log(error.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/Kotlin/anko" target="_blank" rel="external">Anko</a></li>
<li><a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="external">Kotlin Refrence</a></li>
<li><a href="https://developer.android.com/training/volley/index.html" target="_blank" rel="external">Volley</a></li>
<li><a href="http://square.github.io/okhttp" target="_blank" rel="external">OKHttp</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Kotlin官方提供一个DSL的典型应用场景，<a href="https://github.com/Kotlin/anko">Anko</a>致力直接用Kotlin配置页面布局和视图的属性。将布局文件代码化能够带来许多如类型安全、解析效率、代码重用等好处，而<code>Anko</code>让代码布局和XML一样简洁清晰。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="网络请求" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[kotlin中的语法糖]]></title>
    <link href="http://yoursite.com/2016/01/14/kotlin%E4%B8%AD%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <id>http://yoursite.com/2016/01/14/kotlin中的语法糖/</id>
    <published>2016-01-14T05:49:44.000Z</published>
    <updated>2016-02-01T11:29:28.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u57FA_u672C"><a href="#u57FA_u672C" class="headerlink" title="基本"></a>基本</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun <span class="function"><span class="title">sum</span><span class="params">(a: Int, b: Int)</span></span> = <span class="tag">a</span> + <span class="tag">b</span></span><br><span class="line">	</span><br><span class="line">fun <span class="function"><span class="title">max</span><span class="params">(a: Int, b: Int)</span></span> = <span class="keyword">if</span> (<span class="tag">a</span> &gt; b) <span class="tag">a</span> <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range in</span></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) </span><br><span class="line">	print(x)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span> ((k, v) <span class="keyword">in</span> map) &#123; </span><br><span class="line">	println(<span class="string">"$k -&gt; $v"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">val</span> list</span> = listOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">val</span> a</span> = array(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">val</span> map</span> = mapOf(<span class="string">"a"</span> to <span class="number">1</span>, <span class="string">"b"</span> to <span class="number">2</span>, <span class="string">"c"</span> to <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(color: <span class="typename">String</span>)</span>: Int = <span class="title">when</span> <span class="params">(color)</span> &#123;</span></span><br><span class="line">	<span class="string">"Red"</span> -&gt; <span class="number">0</span></span><br><span class="line">	<span class="string">"Green"</span> -&gt; <span class="number">1</span></span><br><span class="line">	<span class="string">"Blue"</span> -&gt; <span class="number">2</span></span><br><span class="line">	<span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Invalid color param value"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Null安全, user为null也不会报NullPointException</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> name</span> = user?.name ?: <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user.name不为null返回user.name，否者返回"unknow"</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> name</span> = user.name ?? <span class="string">"unknow"</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// 字符串模板</span></span><br><span class="line">print(<span class="string">"my name is $name or $&#123;user.name&#125;"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="lanmda_u8868_u8FBE_u5F0F"><a href="#lanmda_u8868_u8FBE_u5F0F" class="headerlink" title="lanmda表达式"></a>lanmda表达式</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names</span><br><span class="line">.<span class="built_in">filter</span> &#123; <span class="keyword">it</span>.startsWith(<span class="string">"A"</span>) &#125; </span><br><span class="line">.sortedBy &#123; <span class="keyword">it</span> &#125;</span><br><span class="line">.map &#123; <span class="keyword">it</span>.toUpperCase() &#125; </span><br><span class="line">.forEach &#123; print(<span class="keyword">it</span>) &#125;</span><br></pre></td></tr></table></figure>
<!--more-->
<h3 id="u5355_u4F8B"><a href="#u5355_u4F8B" class="headerlink" title="单例"></a>单例</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Singlton</span> &#123;</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u9759_u6001_u51FD_u6570"><a href="#u9759_u6001_u51FD_u6570" class="headerlink" title="静态函数"></a>静态函数</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">		<span class="function"><span class="keyword">fun</span> <span class="title">sayHi</span><span class="params">()</span>&#123; <span class="title">println</span><span class="params">("")</span> &#125;</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass.<span class="function"><span class="title">sayHi</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="u65B9_u6CD5_u6269_u5C55_28Extension_Functions_29"><a href="#u65B9_u6CD5_u6269_u5C55_28Extension_Functions_29" class="headerlink" title="方法扩展(Extension Functions)"></a>方法扩展(Extension Functions)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MutableList<span class="type">&lt;T&gt;</span>.<span class="title">swap</span><span class="params">(index1: <span class="typename">Int, index2: Int</span>)</span> &#123;</span></span><br><span class="line">	<span class="variable"><span class="keyword">val</span> tmp</span> = this[index1] <span class="comment">// 'this' corresponds to the list </span></span><br><span class="line">	this[index1] = this[index2]</span><br><span class="line">	this[index2] = tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">val</span> l</span> = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">l.swap(<span class="number">0</span>, <span class="number">2</span>) <span class="comment">// 'this' inside 'swap()' will hold the value of 'l'</span></span><br></pre></td></tr></table></figure>
<h3 id="u5C5E_u6027_u6269_u5C55"><a href="#u5C5E_u6027_u6269_u5C55" class="headerlink" title="属性扩展"></a>属性扩展</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val &lt;T&gt; List&lt;T&gt;<span class="class">.lastIndex</span>: Int </span><br><span class="line">	<span class="function"><span class="title">get</span><span class="params">()</span></span> = size - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="u65B9_u6CD5_u91CD_u8F7D"><a href="#u65B9_u6CD5_u91CD_u8F7D" class="headerlink" title="方法重载"></a>方法重载</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">View.setOnClickListener&#123; println('hello') &#125;</span><br><span class="line"></span><br><span class="line">ps： 这种写法仅限于只有一个重载方法的情况，多方法只能用下面形式</span><br><span class="line"></span><br><span class="line">window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123; </span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="typename">MouseEvent</span>)</span> &#123;</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="typename">MouseEvent</span>)</span> &#123;</span></span><br><span class="line">	 	<span class="comment">// ...</span></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="u89C2_u5BDF_u5C5E_u6027_u53D8_u5316_u81EA_u52A8_u901A_u77E5Observable"><a href="#u89C2_u5BDF_u5C5E_u6027_u53D8_u5316_u81EA_u52A8_u901A_u77E5Observable" class="headerlink" title="观察属性变化自动通知Observable"></a>观察属性变化自动通知Observable</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> &#123;</span></span><br><span class="line">	<span class="keyword">var</span> <span class="attribute">name</span>: String <span class="keyword">by</span> Delegates.observable(<span class="string">"&lt;no name&gt;"</span>) &#123;</span><br><span class="line">		prop, old, <span class="keyword">new</span><span class="function"> -&gt;</span> println(<span class="string">"$old -&gt; $new"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="typename">Array&lt;String&gt;</span>)</span> &#123;</span></span><br><span class="line">	<span class="variable"><span class="keyword">val</span> user</span> = User()</span><br><span class="line">	user.name = <span class="string">"first"</span></span><br><span class="line">	user.name = <span class="string">"second"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;no name&gt; -&gt; <span class="keyword">first</span></span><br><span class="line"><span class="keyword">first</span> -&gt; <span class="keyword">second</span></span><br></pre></td></tr></table></figure>
<h3 id="u6570_u636E_u7C7B"><a href="#u6570_u636E_u7C7B" class="headerlink" title="数据类"></a>数据类</h3><p>java代码</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Artist</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String mbid;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span>(<span class="params"><span class="keyword">long</span> id</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(<span class="params">String name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span>(<span class="params">String url</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMbid</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mbid;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMbid</span>(<span class="params">String mbid</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mbid = mbid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等同于下面kotlin代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data <span class="class"><span class="keyword">class</span> <span class="title">Artist</span></span>(<span class="variable"><span class="keyword">var</span> id</span>: <span class="typename">Long</span>, <span class="variable"><span class="keyword">var</span> name</span>: String, <span class="variable"><span class="keyword">var</span> url</span>: String, <span class="variable"><span class="keyword">var</span> mbid</span>: String)</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u57FA_u672C"><a href="#u57FA_u672C" class="headerlink" title="基本"></a>基本</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun <span class="function"><span class="title">sum</span><span class="params">(a: Int, b: Int)</span></span> = <span class="tag">a</span> + <span class="tag">b</span></span><br><span class="line">	</span><br><span class="line">fun <span class="function"><span class="title">max</span><span class="params">(a: Int, b: Int)</span></span> = <span class="keyword">if</span> (<span class="tag">a</span> &gt; b) <span class="tag">a</span> <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[类与对象 —— 类（一）]]></title>
    <link href="http://yoursite.com/2016/01/02/object-class-class/"/>
    <id>http://yoursite.com/2016/01/02/object-class-class/</id>
    <published>2016-01-02T08:01:28.000Z</published>
    <updated>2016-02-01T11:01:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u7C7B_u7684_u58F0_u660E"><a href="#u7C7B_u7684_u58F0_u660E" class="headerlink" title="类的声明"></a>类的声明</h2><p>kotlin用关键字<code>class</code>声明，声明一个类可以只声明头的部分，类的声明默认是<code>final</code>的。就像：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(name: String)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>类的构造函数可以有很多，但是只有一个可以声明在类的头部，这个构造函数被称做“主构造函数”，其他的被称做“次构造函数”。构造函数使用<code>constructor</code>关键字，主构造函数在没有可见性修饰符和注解的情况下，<code>constructor</code>可以被省略。默认的情况下，所有的构造函数的可见性都是<code>public</code>，对于使用方来说是与类的可见性保持一致。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Customer <span class="keyword">public</span> @Inject <span class="function"><span class="keyword">constructor</span><span class="params">(name: <span class="keyword">String</span>)</span> <span class="comment">&#123; ... &#125;</span></span></span><br></pre></td></tr></table></figure>
<p>主构造函数没有自己的函数体，它的参数可以在类的初始化块（<code>init</code>修饰）访问，在类的属性初始化时也可以访问。所以，在主构造函数里面想要做的事情，可以放在类的初始化块中实现。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>(<span class="title">name</span>: <span class="title">String</span>) </span>&#123;</span><br><span class="line">	val customerKey = name.toUpperCase()</span><br><span class="line">    init &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Customer initialized with value <span class="subst">$&#123;name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想要在类的全局都可以访问主构造函数的参数，可以在参数前面加上<code>val</code>或者<code>var</code>，这样主构造函数的参数就和类的属性一样了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="variable"><span class="keyword">val</span> name</span>: String,<span class="variable"><span class="keyword">val</span> age</span>: <span class="typename">Int</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">showName</span><span class="params">()</span>&#123;</span></span><br><span class="line">        print(<span class="string">"my name is $name"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">showAge</span><span class="params">()</span>&#123;</span></span><br><span class="line">        print(<span class="string">"my age is $age"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>次构造函数必须要使用<code>constructor</code>修饰，并且必须直接或者间接的委托给主构造函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person(val name: <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(name: String, parent: Person) : this(name) </span>&#123;</span><br><span class="line">        parent.children.add(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7EE7_u627F"><a href="#u7EE7_u627F" class="headerlink" title="继承"></a>继承</h2><h3 id="u7C7B_u7684_u7EE7_u627F"><a href="#u7C7B_u7684_u7EE7_u627F" class="headerlink" title="类的继承"></a>类的继承</h3><p>kotlin中所有的类都有一个父类<code>Any</code>，类似于java中的Object，但不存在对等关系。Any中只有<code>equals()</code>、<code>hashCode()</code>和<code>toString()</code>三个方法，所以其他的Object的方法都不能直接调用。详情请参见<a href="https://kotlinlang.org/docs/reference/java-interop.html#object-methods" target="_blank" rel="external">Java interoperability</a>。后面有机会我们会再讲到。</p>
<p>kotlin默认类都是<code>final</code>的，为了可以被继承，我们需要在类的声明前面加上<code>open</code>，让该类可以被其他类继承。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>(p: <span class="typename">Int</span>)</span><br></pre></td></tr></table></figure>
<p>如果父类有主构造函数的话，则必须在子类声明的头部被初始化。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class <span class="function"><span class="title">Derived</span><span class="params">(p: Int)</span></span> : <span class="function"><span class="title">Base</span><span class="params">(p)</span></span></span><br></pre></td></tr></table></figure>
<p>次构造函数也必须直接或间接的初始化父类的构造函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyView : View &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(ctx: Context) : super(ctx) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(ctx: Context, attrs: AttributeSet) : super(ctx, attrs) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u590D_u5199_u65B9_u6CD5"><a href="#u590D_u5199_u65B9_u6CD5" class="headerlink" title="复写方法"></a>复写方法</h3><p>同类一样，子类只能复写父类中被<code>open</code>修饰的函数，复写方法必须使用<code>override</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(name: String, age: <span class="typename">Int</span>)&#123;</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> name</span> = name;</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> age</span> = age;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">showName</span><span class="params">()</span>&#123;</span></span><br><span class="line">        print(<span class="string">"my name is $name"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">showAge</span><span class="params">()</span>&#123;</span></span><br><span class="line">        print(<span class="string">"my age is $age"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Women</span></span>(name: String, age: <span class="typename">Int</span>) : Person(name, age)&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">showAge</span><span class="params">()</span>&#123;</span></span><br><span class="line">        print(<span class="string">"my age is 18"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">showName</span><span class="params">()</span>&#123;</span></span><br><span class="line">        <span class="comment">// error, compiler complain</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类中复写的方法，默认也是<code>open</code>的，如果需要，可以在方法<code>override</code>之前添加<code>final</code>注解，让该子类的子类不能再复写该方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span> &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="u591A_u7EE7_u627F"><a href="#u591A_u7EE7_u627F" class="headerlink" title="多继承"></a>多继承</h3><p>kotlin和java8一样，本身并不能同时继承于多个类，但是可以实现多个接口，而且接口可以有自己的实现，所以当父类和接口或者接口和接口中的方法一样时，会发生冲突，我们需要明确这个时候的解决方案，不然就会<code>compiler complain</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Young&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">showAge</span><span class="params">()</span>&#123;</span></span><br><span class="line">        print(<span class="string">"my age is between 13 and 25"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(name: String, age: <span class="typename">Int</span>) : Person(name, age), Young&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">showAge</span><span class="params">()</span> &#123;</span></span><br><span class="line">        super<span class="type">&lt;Person&gt;</span>.showAge()</span><br><span class="line">        super<span class="type">&lt;Young&gt;</span>.showAge()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u59D4_u6258"><a href="#u59D4_u6258" class="headerlink" title="委托"></a>委托</h2><p>委托被认为是一个非常好的替代继承和实现的设计模式，kotlin也支持这种模式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseImpl</span></span>(<span class="variable"><span class="keyword">val</span> x</span>: <span class="typename">Int</span>) : Base &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span> &#123; <span class="title">print</span><span class="params">(x)</span> &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(b: Base) : Base by b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span> &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> b</span> = BaseImpl(<span class="number">10</span>)</span><br><span class="line">    Derived(b).print() <span class="comment">// prints 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类的声明过程中，在父类类型后面使用<code>by</code>关键字指明在Derived的对象中将会内部存储<code>b</code>对象，并且编译器会将<code>Base</code>的所有方法指向<code>b</code>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u7C7B_u7684_u58F0_u660E"><a href="#u7C7B_u7684_u58F0_u660E" class="headerlink" title="类的声明"></a>类的声明</h2><p>kotlin用关键字<code>class</code>声明，声明一个类可以只声明头的部分，类的声明默认是<code>final</code>的。就像：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(name: String)</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="class" scheme="http://yoursite.com/tags/class/"/>
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
      <category term="委托" scheme="http://yoursite.com/tags/%E5%A7%94%E6%89%98/"/>
    
      <category term="类" scheme="http://yoursite.com/tags/%E7%B1%BB/"/>
    
      <category term="继承" scheme="http://yoursite.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[类与对象——泛型]]></title>
    <link href="http://yoursite.com/2015/12/22/class-object-generic/"/>
    <id>http://yoursite.com/2015/12/22/class-object-generic/</id>
    <published>2015-12-22T15:08:50.000Z</published>
    <updated>2016-02-01T11:01:27.000Z</updated>
    <content type="html"><![CDATA[<p>与java一样，Kotlin也提供泛型，为类型安全提供保证，消除类型强转的烦恼。</p>
<h3 id="u6CDB_u578B_u5B9A_u4E49"><a href="#u6CDB_u578B_u5B9A_u4E49" class="headerlink" title="泛型定义"></a>泛型定义</h3><p>好吧，如果只是简单声明一个泛型，和<code>Java</code>没有什么大的区别，你可以这样声明：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span><span class="inheritance">&lt;<span class="parent">T</span></span>&gt;(<span class="title">t</span>: <span class="title">T</span>) &#123;</span></span><br><span class="line">    var value = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以这样使用</p>
<a id="more"></a>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val <span class="keyword">box</span>: <span class="built_in">Box</span>&lt;Int&gt; = <span class="built_in">Box</span>&lt;Int&gt;(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">val <span class="keyword">box</span> = <span class="built_in">Box</span>(<span class="number">1</span>) <span class="comment">// 编译器会进行类型推断</span></span><br></pre></td></tr></table></figure>
<h3 id="u6CDB_u578B_u7EA6_u675F"><a href="#u6CDB_u578B_u7EA6_u675F" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>和类的继承一样，<code>Kotlin</code>中使用<code>:</code>代替<code>extends</code>对泛型的的类型上限进行约束。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwipeRefreshableView</span><span class="inheritance">&lt;<span class="parent">T</span></span> : <span class="title">View</span>&gt;&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>不过这里你可以进行多个类型的上限约束：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwipeRefreshableView</span>&lt;<span class="type">T</span>&gt;</span></span><br><span class="line">    where T : View,</span><br><span class="line">          T : Refreshable &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">cloneWhenGreater</span><span class="params">(list: <span class="typename">List&lt;T&gt;, threshold: T</span>)</span>: List<span class="type">&lt;T&gt;</span></span></span><br><span class="line">    where T : Comparable,</span><br><span class="line">          T : Cloneable &#123;</span><br><span class="line">  <span class="keyword">return</span> list.filter &#123; it &gt; threshold &#125;.map &#123; it.clone() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，对于之前用过泛型的同学来说都没有什么难度。so，kotlin还有什么java里没有的东西吗？</p>
<h3 id="in_u548Cout"><a href="#in_u548Cout" class="headerlink" title="in和out"></a><code>in</code>和<code>out</code></h3><p><code>Kotlin</code>中引入两个新的泛型修饰符<code>in</code>和<code>out</code>，要解释这两个关键字的用法，我们先从另外两个概念说起‘covariant（协变性）’和‘contravariance（逆变性）’（不知道的可以<a href="http://www.cnblogs.com/Figgy/p/4575719.html" target="_blank" rel="external">参考</a>）。我们都知道在java中List不是协变的，而Array是协变的：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer<span class="string">[]</span> intArray = new Integer<span class="string">[10]</span>;</span><br><span class="line">Number<span class="string">[]</span> numberArray = intArray;</span><br><span class="line">numberArray<span class="string">[0]</span> = <span class="number">1</span>.0f;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>Integer[]</code>被认为是<code>Number[]</code>的子类型，所以可以将<code>intArray</code>赋值给<code>numberArray</code>，但是在随后的代码，我们将<code>1.0f</code>赋给<code>numberArray[0]</code>，因为在这里看来，将一个浮点型赋给一个Number对象不会有什么问题。最后悲剧发生了，当执行时，程序crash了。</p>
<p>但是当你使用泛型的的时候：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; strs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; objs = strs; <span class="comment">// error, compiler complain</span></span><br></pre></td></tr></table></figure>
<p><code>List&lt;String&gt;</code>并不是<code>List&lt;Object&gt;</code>的子类型，于是编译器告诉你，不能直接赋值。或许你会说我们可以使用通配符<code>? extends T</code>让它变得协变。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; strs = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">strs.add(<span class="string">"0"</span>);</span><br><span class="line">strs.add(<span class="string">"1"</span>);</span><br><span class="line"><span class="built_in">List</span>&lt;? <span class="keyword">extends</span> <span class="built_in">Object</span>&gt; objs = strs;</span><br><span class="line"><span class="comment">//编译通过</span></span><br></pre></td></tr></table></figure>
<p><code>List&lt;String&gt;</code>是<code>List&lt;? extends Object&gt;</code>的子类，所以上面的代码的确能够编译运行，但是当你尝试为<code>objs</code>添加内容时：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//然后添加一个int型试试</span></span><br><span class="line">objs.<span class="built_in">add</span>(<span class="number">1</span>); <span class="comment">// error, compiler complain</span></span><br><span class="line"><span class="comment">// 编译器编译出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在再添加一个String</span></span><br><span class="line">objs.<span class="built_in">add</span>(<span class="string">"1"</span>); <span class="comment">// error, compiler complain</span></span><br><span class="line"><span class="comment">// 编译出错</span></span><br></pre></td></tr></table></figure>
<p>对于objs并不会因为<code>objs = strs;</code>的赋值，而将<code>objs</code>的泛型类型转化为<code>String</code>类型，所以在不能判断objs的泛型类型的情况下，往objs添加任何类型的对象都是不被允许的。但是我们明确知道objs的所有类型上限（upper bound），于是我们可以通过<code>objs.get(0)</code>获取Object的对象。</p>
<p> 小结一下，我们可以用通配符<code>? extends T</code>让泛型类变得协变，但是对于具体泛型类型的对象我们不能赋值，只能获取。于是在下面的假设中java就可以这么写：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="keyword">Source</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T getT();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setT(T t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">copy</span>(<span class="keyword">Source</span>&lt;String&gt; strs)&#123;</span><br><span class="line">    <span class="keyword">Source</span>&lt;? <span class="keyword">extends</span> Object&gt; objs = strs;</span><br><span class="line">    objs.setT(<span class="string">"a"</span>); <span class="comment">// error, compiler complain</span></span><br><span class="line">	String str = (String) objs.getT();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Kotlin</code>中就可以这么写：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span><span class="inheritance">&lt;<span class="parent">T</span></span>&gt; &#123;</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">getT</span></span>(): <span class="constant">T</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">setT</span></span>(<span class="symbol">t:</span> <span class="constant">T</span>)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copyT</span></span>(<span class="symbol">strs:</span> <span class="constant">Source</span>&lt;<span class="constant">String</span>&gt;)&#123;</span><br><span class="line">    val <span class="symbol">objs:</span> <span class="constant">Source</span>&lt;<span class="keyword">out</span> <span class="constant">Any</span>?&gt; = strs;</span><br><span class="line">    objs.setT(<span class="string">"a"</span>) /<span class="regexp">/ error, compiler complain</span><br><span class="line">    objs.getT()</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的<code>out Any?</code>可以用<code>*</code>代替。</p>
<p>如果我们可以确定<code>Source</code>这个类不会有<code>abstract fun setT(t: T)</code>类似的操作，我们可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Source</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line">    abstract <span class="function"><span class="keyword">fun</span> <span class="title">getT</span><span class="params">()</span>: T</span></span><br><span class="line">    <span class="comment">// 如果下面出现会编译不过</span></span><br><span class="line">    <span class="comment">// abstract fun setT(t: T) // error, compiler complain</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copyT</span><span class="params">(strs: <span class="typename">Source&lt;String&gt;</span>)</span>&#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> objs</span>: Source<span class="type">&lt;Any&gt;</span> = strs;</span><br><span class="line">    objs.setT(<span class="string">"a"</span>) <span class="comment">// error, compiler complain</span></span><br><span class="line">    objs.getT()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结一下，在定义泛型类<code>C&lt;T&gt;</code>时，当我们在泛型类型<code>T</code>前面添加<code>out</code>，<code>C</code>为<code>T</code>的协变类。在该类的作用域内，类型<code>T</code>只能作为该类中函数的返回类型，不能作为参数传递进来，这时也称做<code>C</code>为<code>T</code>的生产者（Producer）。</p>
<p>以此类推，在定义泛型类<code>C&lt;T&gt;</code>时，当我们在泛型类型<code>T</code>前面添加<code>in</code>，<code>C</code>为<code>T</code>的逆变类。在该类的作用域内，类型<code>T</code>只能作为该类中函数的参数传递进来，不能作为返回类型，这时也称做<code>C</code>为<code>T</code>的消费者（Consumer）。</p>
<p>类似于<code>java</code>中的<a href="http://www.importnew.com/8966.html" target="_blank" rel="external">PECS</a>（Producer Extends，Consumer Super），我们可以总结出：‘Consumer in, Producer out’。</p>
<p>如果在泛型类型使用测，在对应泛型的具体类型前面使用<code>out</code>，则等同于使用<code>java</code>中的<code>extends</code>字段，<code>in</code>则等同于<code>super</code>。</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun copy(<span class="keyword">from</span>: <span class="built_in">Array</span>&lt;out String&gt;, <span class="keyword">to</span>: <span class="built_in">Array</span>&lt;<span class="built_in">in</span> String&gt;) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="keyword">from</span>.<span class="built_in">size</span> == <span class="keyword">to</span>.<span class="built_in">size</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="built_in">in</span> <span class="keyword">from</span>.indices)</span><br><span class="line">        <span class="keyword">to</span>[i] = <span class="keyword">from</span>[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">public void copy(<span class="built_in">List</span>&lt;? extends String&gt; <span class="keyword">from</span>, <span class="built_in">List</span>&lt;? super String&gt; <span class="keyword">to</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>PS： 这里Array 与 List 不是对等关系。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.cnblogs.com/panjun-Donet/archive/2008/09/27/1300609.html" target="_blank" rel="external">java泛型</a></li>
<li><a href="http://www.cnblogs.com/Figgy/p/4575719.html" target="_blank" rel="external">不变性、协变性和逆变性（Invariance, Covariance &amp; Contravariance</a></li>
<li><a href="http://www.importnew.com/8966.html" target="_blank" rel="external">Java 泛型: 什么是PECS（Producer Extends, Consumer Super）</a></li>
<li><a href="https://kotlinlang.org/docs/reference/generics.html" target="_blank" rel="external">Kotlin-Generics</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>与java一样，Kotlin也提供泛型，为类型安全提供保证，消除类型强转的烦恼。</p>
<h3 id="u6CDB_u578B_u5B9A_u4E49"><a href="#u6CDB_u578B_u5B9A_u4E49" class="headerlink" title="泛型定义"></a>泛型定义</h3><p>好吧，如果只是简单声明一个泛型，和<code>Java</code>没有什么大的区别，你可以这样声明：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span><span class="inheritance">&lt;<span class="parent">T</span></span>&gt;(<span class="title">t</span>: <span class="title">T</span>) &#123;</span></span><br><span class="line">    var value = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以这样使用</p>]]>
    
    </summary>
    
      <category term="generics" scheme="http://yoursite.com/tags/generics/"/>
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
      <category term="泛型" scheme="http://yoursite.com/tags/%E6%B3%9B%E5%9E%8B/"/>
    
      <category term="类与对象" scheme="http://yoursite.com/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[类与对象 -- object]]></title>
    <link href="http://yoursite.com/2015/12/19/class-object-object/"/>
    <id>http://yoursite.com/2015/12/19/class-object-object/</id>
    <published>2015-12-19T11:02:38.000Z</published>
    <updated>2016-02-01T11:01:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5BF9_u8C61_uFF08object_uFF09_u8868_u8FBE_u5F0F_u548C_u5BF9_u8C61_u58F0_u660E"><a href="#u5BF9_u8C61_uFF08object_uFF09_u8868_u8FBE_u5F0F_u548C_u5BF9_u8C61_u58F0_u660E" class="headerlink" title="对象（object）表达式和对象声明"></a>对象（object）表达式和对象声明</h2><p>Kotlin中提供关键object，与java中的“Object”不同（在java中“Object”是所有类的基类，等同于Kotlin的“Any”，参考<a href="https://kotlinlang.org/docs/reference/java-interop.html#mapped-types" target="_blank" rel="external">java-interop</a>），用于直接申明一个对象，有两种使用写法：对象表达式和对象声明</p>
<h3 id="u5BF9_u8C61_u8868_u8FBE_u5F0F"><a href="#u5BF9_u8C61_u8868_u8FBE_u5F0F" class="headerlink" title="对象表达式"></a>对象表达式</h3><p>通过对象表达式可以越过类的定义直接得到一个对象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> point</span> = <span class="keyword">object</span> &#123;</span><br><span class="line">	<span class="variable"><span class="keyword">var</span> x</span>: <span class="typename">Int</span> = <span class="number">0</span></span><br><span class="line">	<span class="variable"><span class="keyword">var</span> y</span>: <span class="typename">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个对象可以继承于某个基类，或者实现其他接口:</p>
<a id="more"></a>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Device</span></span>(<span class="variable"><span class="keyword">var</span> name</span>: String) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Vedio &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">play</span><span class="params">()</span>&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">var</span> television</span> = <span class="keyword">object</span> : Device(<span class="string">"Sony"</span>), Vedio&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这可以方便的实现一个匿名内部类的对象用于方法的参数中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="typename">MouseEvent</span>)</span> &#123;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="typename">MouseEvent</span>)</span> &#123;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在对象表达中可以方便的访问到作用域中的其他变量，及时这个变量并不是<code>final</code>的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countClicks</span><span class="params">(window: <span class="typename">JComponent</span>)</span> &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> clickCount</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> enterCount</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="typename">MouseEvent</span>)</span> &#123;</span></span><br><span class="line">            clickCount++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="typename">MouseEvent</span>)</span> &#123;</span></span><br><span class="line">            enterCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u5BF9_u8C61_u58F0_u660E"><a href="#u5BF9_u8C61_u58F0_u660E" class="headerlink" title="对象声明"></a>对象声明</h3><p>对象声明可类似定义一个类一样定义一个对象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> RCtrl : Device(<span class="string">"Remote Control"</span>), Infrared &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(command: <span class="typename">Int</span>)</span> &#123;</span></span><br><span class="line">        <span class="comment">// send command</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> RCtrl : Device(<span class="string">"Remote Control"</span>), Infrared &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用的时候可以直接使用定义的对象：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span></span>(<span class="symbol">args:</span> <span class="constant">Array</span>&lt;<span class="constant">String</span>&gt;) &#123;</span><br><span class="line">    <span class="constant">RCtrl</span>.send(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然你也可以定义一个变量来获取获取这个对象，当时当你定义两个不同的变量来获取这个对象时，你会发现你并不能得到两个不同的变量。也就是说通过这种方式，我们获得一个<strong><em>单例</em></strong>。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> rCtrl1 = RCtrl</span><br><span class="line"><span class="tag">var</span> rCtrl2 = RCtrl</span><br><span class="line">rCtrl1<span class="class">.name</span> = <span class="string">"TV Control"</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"rCtrl2 name = $&#123;rCtrl2.name&#125;"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>在Kotlin中我们可以方便的通过对象声明来获得一个单例。</p>
<p>不过需要注意的是，对象声明不能直接定义在一个函数中。</p>
<p>与对象表达式不同，当对象声明在另一个类的内部时，这个对象并不能通过外部类的实例访问到该对象，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desk</span></span>&#123;</span><br><span class="line">	<span class="variable"><span class="keyword">var</span> legCount</span> = <span class="number">4</span></span><br><span class="line">	<span class="keyword">object</span> DeskTop&#123;</span><br><span class="line">       <span class="variable"><span class="keyword">var</span> area</span> = <span class="number">0</span></span><br><span class="line">       <span class="function"><span class="keyword">fun</span> <span class="title">showLegs</span><span class="params">()</span>&#123;</span></span><br><span class="line">       	print&#123;<span class="string">"desk legs $legCount"</span>&#125; <span class="comment">// error, compile complain</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="typename">Array&lt;String&gt;</span>)</span> &#123;</span></span><br><span class="line">	<span class="variable"><span class="keyword">var</span> desk</span> = Desk()</span><br><span class="line">   	desk.DeskTop.area <span class="comment">// error, compile complain</span></span><br><span class="line">   	Desk.DeskTop.area <span class="comment">// right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="companion_u5BF9_u8C61"><a href="#companion_u5BF9_u8C61" class="headerlink" title="companion对象"></a>companion对象</h3><p>当对象声明在另一个对象中时，我们可以通过关键字<code>companion</code>将对象与外部类关联在一起，这样我们就可以直接通过外部类访问到对象的内部元素。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Factory &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span>: MyClass = <span class="title">MyClass</span><span class="params">()</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">val</span> instance</span> = MyClass.create()</span><br></pre></td></tr></table></figure>
<p>我们甚至可以省略掉该对象的对象名，然后使用<code>Companion</code>替代需要声明的对象名：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">val</span> x</span> = MyClass.Companion</span><br></pre></td></tr></table></figure>
<p>看到上面的例子我们我们就会思考如果我们定义两个内部关联对象怎么办，答案当然是不行，不管是否声明对象名，一个类里面只能声明一个内部关联对象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desk</span></span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> DeskTop &#123;</span><br><span class="line">        <span class="variable"><span class="keyword">var</span> area</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Leg&#123;  <span class="comment">// error, compile complain</span></span><br><span class="line">        <span class="variable"><span class="keyword">var</span> lenght</span> = <span class="number">80</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://kotlinlang.org" target="_blank" rel="external">kotlin</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5BF9_u8C61_uFF08object_uFF09_u8868_u8FBE_u5F0F_u548C_u5BF9_u8C61_u58F0_u660E"><a href="#u5BF9_u8C61_uFF08object_uFF09_u8868_u8FBE_u5F0F_u548C_u5BF9_u8C61_u58F0_u660E" class="headerlink" title="对象（object）表达式和对象声明"></a>对象（object）表达式和对象声明</h2><p>Kotlin中提供关键object，与java中的“Object”不同（在java中“Object”是所有类的基类，等同于Kotlin的“Any”，参考<a href="https://kotlinlang.org/docs/reference/java-interop.html#mapped-types">java-interop</a>），用于直接申明一个对象，有两种使用写法：对象表达式和对象声明</p>
<h3 id="u5BF9_u8C61_u8868_u8FBE_u5F0F"><a href="#u5BF9_u8C61_u8868_u8FBE_u5F0F" class="headerlink" title="对象表达式"></a>对象表达式</h3><p>通过对象表达式可以越过类的定义直接得到一个对象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> point</span> = <span class="keyword">object</span> &#123;</span><br><span class="line">	<span class="variable"><span class="keyword">var</span> x</span>: <span class="typename">Int</span> = <span class="number">0</span></span><br><span class="line">	<span class="variable"><span class="keyword">var</span> y</span>: <span class="typename">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个对象可以继承于某个基类，或者实现其他接口:</p>]]>
    
    </summary>
    
      <category term="companion" scheme="http://yoursite.com/tags/companion/"/>
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
      <category term="object" scheme="http://yoursite.com/tags/object/"/>
    
      <category term="单例" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B/"/>
    
      <category term="对象" scheme="http://yoursite.com/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2015/12/17/new-to-kotlin/"/>
    <id>http://yoursite.com/2015/12/17/new-to-kotlin/</id>
    <published>2015-12-17T04:07:11.000Z</published>
    <updated>2015-12-17T04:07:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Kotlin_u7B80_u4ECB"><a href="#Kotlin_u7B80_u4ECB" class="headerlink" title="Kotlin简介"></a>Kotlin简介</h1><h2 id="Kotlin_u662F_u4EC0_u4E48"><a href="#Kotlin_u662F_u4EC0_u4E48" class="headerlink" title="Kotlin是什么"></a>Kotlin是什么</h2><p>发布于2011年，是一门适用于JVM, Android以及浏览器静态语言，<strong><em>100% 兼容Java™</em></strong></p>
<h2 id="u4E3A_u4EC0_u4E48_u9009_u62E9Kotlin"><a href="#u4E3A_u4EC0_u4E48_u9009_u62E9Kotlin" class="headerlink" title="为什么选择Kotlin"></a>为什么选择Kotlin</h2><ul>
<li>简洁，大幅度减少你需要写的重复代码</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用lambda表达式来过滤链表：</span><br><span class="line">val positiveNumbers = <span class="type">list</span>.filter &#123;<span class="keyword">it</span> &gt; <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>安全，避免整个类中类似空指针异常这样的错误，测试妹妹再也不用担心你的NullPointException了</p>
</li>
<li><p>通用，可以用于构建服务器端程序、Android程序或者运行在浏览器里的前端程序</p>
</li>
<li><p>互操作，重用已有的JVM平台框架或库，与Java无缝兼容，可直接在之前项目上面使用Kotlin</p>
</li>
<li><p>工具，一门语言需要工具化，这正是JetBrains做得最好的地方</p>
</li>
<li><p>可靠，JetBrains提供技术支持</p>
</li>
</ul>
<a id="more"></a>
<h2 id="u8BD5_u7528Kotlin"><a href="#u8BD5_u7528Kotlin" class="headerlink" title="试用Kotlin"></a>试用Kotlin</h2><ul>
<li>单独编译，你可以使用ant、maven或者gradle编译kotlin，<a href="https://kotlinlang.org/docs/tutorials/command-line.html" target="_blank" rel="external">编译器下载</a></li>
<li>在IntelliJ IDEA或者Android Studio上编写kotlin，<a href="https://kotlinlang.org/docs/tutorials/getting-started.html" target="_blank" rel="external">安装插件</a></li>
<li>在eclipse上编写kotlin，<a href="https://kotlinlang.org/docs/tutorials/getting-started-eclipse.html" target="_blank" rel="external">安装插件</a></li>
<li><a href="http://try.kotlinlang.org/" target="_blank" rel="external">在线编辑</a></li>
</ul>
<h2 id="u76F8_u5173_u8D44_u6E90"><a href="#u76F8_u5173_u8D44_u6E90" class="headerlink" title="相关资源"></a>相关资源</h2><ul>
<li><a href="https://kotlinlang.org/" target="_blank" rel="external">官方网站</a></li>
<li><a href="http://kotlinlang.cn/" target="_blank" rel="external">中文网站</a></li>
<li><a href="https://kotlinlang.org/docs/kotlin-docs.pdf" target="_blank" rel="external">文档下载</a></li>
<li><a href="https://kotlinthree.github.io/" target="_blank" rel="external">KotlinThree</a></li>
</ul>
<h2 id="u53C2_u8003_u5185_u5BB9"><a href="#u53C2_u8003_u5185_u5BB9" class="headerlink" title="参考内容"></a>参考内容</h2><p><a href="http://kotlinlang.cn/" target="_blank" rel="external">Kotlin</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Kotlin_u7B80_u4ECB"><a href="#Kotlin_u7B80_u4ECB" class="headerlink" title="Kotlin简介"></a>Kotlin简介</h1><h2 id="Kotlin_u662F_u4EC0_u4E48"><a href="#Kotlin_u662F_u4EC0_u4E48" class="headerlink" title="Kotlin是什么"></a>Kotlin是什么</h2><p>发布于2011年，是一门适用于JVM, Android以及浏览器静态语言，<strong><em>100% 兼容Java™</em></strong></p>
<h2 id="u4E3A_u4EC0_u4E48_u9009_u62E9Kotlin"><a href="#u4E3A_u4EC0_u4E48_u9009_u62E9Kotlin" class="headerlink" title="为什么选择Kotlin"></a>为什么选择Kotlin</h2><ul>
<li>简洁，大幅度减少你需要写的重复代码</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用lambda表达式来过滤链表：</span><br><span class="line">val positiveNumbers = <span class="type">list</span>.filter &#123;<span class="keyword">it</span> &gt; <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>安全，避免整个类中类似空指针异常这样的错误，测试妹妹再也不用担心你的NullPointException了</p>
</li>
<li><p>通用，可以用于构建服务器端程序、Android程序或者运行在浏览器里的前端程序</p>
</li>
<li><p>互操作，重用已有的JVM平台框架或库，与Java无缝兼容，可直接在之前项目上面使用Kotlin</p>
</li>
<li><p>工具，一门语言需要工具化，这正是JetBrains做得最好的地方</p>
</li>
<li><p>可靠，JetBrains提供技术支持</p>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Welcome]]></title>
    <link href="http://yoursite.com/2015/12/15/welcome/"/>
    <id>http://yoursite.com/2015/12/15/welcome/</id>
    <published>2015-12-15T13:36:29.000Z</published>
    <updated>2017-05-16T15:52:55.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xpox6.com1.z0.glb.clouddn.com/104429.88533097_620X620.jpg" alt="Zenus"></p>
<a id="more"></a>
<h2 id="KotlinThree_u7EC4_u7EC7_u6210_u7ACB_u4E86_uFF01_uFF01_uFF01_u6B22_u8FCE_u5927_u5BB6_u524D_u6765_u505A_u5BA2_uFF01_28_u6B64_u5904_u5E94_u6709_u638C_u58F0_7E_29_2C__u6B22_u8FCE_u5927_u5BB6_u4E00_u8D77_u6765_u5B66_u4E60_u63A2_u8BA8Kotlin"><a href="#KotlinThree_u7EC4_u7EC7_u6210_u7ACB_u4E86_uFF01_uFF01_uFF01_u6B22_u8FCE_u5927_u5BB6_u524D_u6765_u505A_u5BA2_uFF01_28_u6B64_u5904_u5E94_u6709_u638C_u58F0_7E_29_2C__u6B22_u8FCE_u5927_u5BB6_u4E00_u8D77_u6765_u5B66_u4E60_u63A2_u8BA8Kotlin" class="headerlink" title="KotlinThree组织成立了！！！欢迎大家前来做客！(此处应有掌声~), 欢迎大家一起来学习探讨Kotlin"></a><strong>KotlinThree组织成立了</strong>！！！欢迎大家前来做客！(此处应有掌声~), 欢迎大家一起来学习探讨Kotlin</h2>]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xpox6.com1.z0.glb.clouddn.com/104429.88533097_620X620.jpg" alt="Zenus"></p>]]>
    
    </summary>
    
      <category term="star" scheme="http://yoursite.com/tags/star/"/>
    
  </entry>
  
</feed>
